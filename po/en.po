msgid ""
msgstr ""
"Project-Id-Version: AxVisor Book\n"
"POT-Creation-Date: 2025-04-09T01:49:26Z\n"
"PO-Revision-Date: 2025-04-09 01:50+0000\n"
"Last-Translator: ZCShou <zcsexp@gmail.com>\n"
"Language-Team: English\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: en\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

#: src/SUMMARY.md:1
msgid "AxVisor Book"
msgstr "AxVisor Book"

#: src/SUMMARY.md:3
msgid "关于 AxVisor"
msgstr "About AxVisor"

#: src/SUMMARY.md:5 src/overview/overview.md:1
#: src/architecture/vcpu/riscv_vcpu.md:1
msgid "概述"
msgstr "Overview"

#: src/SUMMARY.md:7
msgid "硬件平台支持"
msgstr "Hardware platform"

#: src/SUMMARY.md:9 src/overview/guest.md:1
msgid "客户机系统支持"
msgstr "Guest OS"

#: src/SUMMARY.md:11
msgid "快速上手"
msgstr "Quick Start"

#: src/SUMMARY.md:13
msgid "QEMU"
msgstr "QEMU"

#: src/SUMMARY.md:14
msgid "QEMU-aarch64"
msgstr "QEMU-aarch64"

#: src/SUMMARY.md:15
msgid "QEMU-x86_64"
msgstr "QEMU-x86_64"

#: src/SUMMARY.md:16
msgid "QEMU-riscv64"
msgstr "QEMU-riscv64"

#: src/SUMMARY.md:18 src/quickstart/aarch64_a1000.md:1
msgid "黑芝麻 A1000"
msgstr "黑芝麻 A1000"

#: src/SUMMARY.md:20 src/quickstart/aarch64_rk3588.md:1
msgid "RK3588"
msgstr "RK3588"

#: src/SUMMARY.md:22
msgid "ROC-RK3568-PC"
msgstr "ROC-RK3568-PC"

#: src/SUMMARY.md:24
msgid "架构设计手册"
msgstr "Architecture Design Manual"

#: src/SUMMARY.md:26 src/architecture/arch.md:1
msgid "总体设计"
msgstr "总体设计"

#: src/SUMMARY.md:28 src/architecture/axvisor.md:1
msgid "AxVisor"
msgstr "AxVisor"

#: src/SUMMARY.md:30
msgid "AxVisor API"
msgstr "AxVisor API"

#: src/SUMMARY.md:32
msgid "axvm"
msgstr "axvm"

#: src/SUMMARY.md:34
msgid "axvcpu"
msgstr "axvcpu"

#: src/SUMMARY.md:35 src/architecture/vcpu/x86_vcpu.md:3
msgid "x86_vcpu"
msgstr "x86_vcpu"

#: src/SUMMARY.md:36 src/architecture/vcpu/arm_vcpu.md:3
msgid "arm_vcpu"
msgstr "arm_vcpu"

#: src/SUMMARY.md:37
msgid "riscv_vcpu"
msgstr "riscv_vcpu"

#: src/SUMMARY.md:38
msgid "loongarch_vcpu"
msgstr "loongarch_vcpu"

#: src/SUMMARY.md:40 src/architecture/memory.md:1
msgid "axaddrspace"
msgstr "axaddrspace"

#: src/SUMMARY.md:42
msgid "Virtual IRQ"
msgstr "Virtual IRQ"

#: src/SUMMARY.md:43
msgid "vGIC"
msgstr "vGIC"

#: src/SUMMARY.md:44
msgid "vLapic"
msgstr "vLapic"

#: src/SUMMARY.md:46
msgid "Passthrough Device"
msgstr "Passthrough Device"

#: src/SUMMARY.md:48
msgid "Emulated Device"
msgstr "Emulated Device"

#: src/SUMMARY.md:49
msgid "emulated PCI"
msgstr "emulated PCI"

#: src/SUMMARY.md:50
msgid "virtio device"
msgstr "virtio device"

#: src/SUMMARY.md:52
msgid "VM-Exit"
msgstr "VM-Exit"

#: src/SUMMARY.md:54
msgid "测试"
msgstr "测试"

#: src/SUMMARY.md:56
msgid "开发指导手册"
msgstr "开发指导手册"

#: src/SUMMARY.md:58 src/development/build.md:1
msgid "构建"
msgstr "构建"

#: src/SUMMARY.md:60
msgid "硬件适配"
msgstr "硬件适配"

#: src/SUMMARY.md:62 src/development/guest_vms/guest_vms.md:1
msgid "客户机适配"
msgstr "客户机适配"

#: src/SUMMARY.md:64
msgid "2 VM Timer Nimbos"
msgstr "2 VM Timer Nimbos"

#: src/SUMMARY.md:66
msgid "用户指导手册"
msgstr "用户指导手册"

#: src/SUMMARY.md:68 src/user_manual/usage.md:1
msgid "使用"
msgstr "使用"

#: src/SUMMARY.md:70 src/user_manual/manage.md:1
msgid "管理"
msgstr "管理"

#: src/SUMMARY.md:72 src/user_manual/depoly.md:1
msgid "部署"
msgstr "部署"

#: src/SUMMARY.md:74
msgid "开发计划"
msgstr "开发计划"

#: src/SUMMARY.md:76
msgid "Roadmap"
msgstr "Roadmap"

#: src/SUMMARY.md:78
msgid "Discussions"
msgstr "Discussions"

#: src/overview/overview.md:3
msgid ""
"AxVisor 是一个基于 [ArceOS](https://github.com/arceos-org/arceos) 框架实现的 "
"Hypervisor（也叫 Virtual Machine Manager，VMM）。其目标是利用 ArceOS 提供的基"
"础操作系统功能作为基础实现一个统一的模块化 Hypervisor。"
msgstr ""
"AxVisor 是一个基于 [ArceOS](https://github.com/arceos-org/arceos) 框架实现的 "
"Hypervisor（也叫 Virtual Machine Manager，VMM）。其目标是利用 ArceOS 提供的基"
"础操作系统功能作为基础实现一个统一的模块化 Hypervisor。"

#: src/overview/overview.md:5
msgid "![AxVisor](../assets/overview/axvisor.png)"
msgstr "![AxVisor](../assets/overview/axvisor.png)"

#: src/overview/overview.md:7
msgid ""
"**统一**是指使用同一套代码同时支持 x86_64、AArch64 、RISC-V LoongArch 这四种"
"架构，以最大化复用架构无关代码，简化代码开发和维护成本。"
msgstr ""
"**统一**是指使用同一套代码同时支持 x86_64、AArch64 、RISC-V LoongArch 这四种"
"架构，以最大化复用架构无关代码，简化代码开发和维护成本。"

#: src/overview/overview.md:9
msgid ""
"**模块化**则是指 Hypervisor 的功能被分解为多个模块，每个模块实现一个特定的功"
"能，模块之间通过标准接口进行通信，以实现功能的解耦和复用。"
msgstr ""
"**模块化**则是指 Hypervisor 的功能被分解为多个模块，每个模块实现一个特定的功"
"能，模块之间通过标准接口进行通信，以实现功能的解耦和复用。"

#: src/overview/overview.md:128 src/overview/platform.md:126
#: src/overview/guest.md:139 src/quickstart/qemu/qemu.md:123
#: src/quickstart/qemu/qemu_aarch64.md:1099
#: src/quickstart/qemu/qemu_x86_64.md:154
#: src/quickstart/qemu/qemu_riscv64.md:121 src/quickstart/aarch64_a1000.md:1303
#: src/quickstart/aarch64_rk3588.md:292
#: src/quickstart/aarch64_roc-rk3568-pc.md:120 src/architecture/arch.md:214
#: src/architecture/axvisor.md:336
#: src/architecture/axvisor_api/comparison.md:303 src/architecture/axvm.md:149
#: src/architecture/vcpu/x86_vcpu.md:345 src/architecture/vcpu/arm_vcpu.md:437
#: src/architecture/vcpu/riscv_vcpu.md:341
#: src/architecture/vcpu/loongarch_vcpu.md:119 src/architecture/memory.md:263
#: src/architecture/irq/irq.md:202 src/architecture/irq/vlapic.md:305
#: src/architecture/device/passthrough_device.md:173
#: src/architecture/device/device.md:128 src/architecture/device/pci.md:211
#: src/architecture/device/virtio.md:207 src/architecture/test/test.md:119
#: src/development/build.md:120
#: src/development/platform_port/platform_port.md:119
#: src/development/guest_vms/guest_vms.md:120
#: src/development/guest_vms/2vm_timer.md:439 src/user_manual/usage.md:120
#: src/user_manual/manage.md:120 src/user_manual/depoly.md:120
#: src/roadmap/roadmap.md:119 src/roadmap/discusstions.md:120
msgid "<button type=\"button\">X</button>"
msgstr "<button type=\"button\">X</button>"

#: src/overview/platform.md:1
msgid "硬件平台"
msgstr "硬件平台"

#: src/overview/platform.md:3
msgid ""
"AxVisor 被设计为可以在 x86_64、AArch64 、RISC-V LoongArch 四大芯片架构上运"
"行，目前，已经在如下平台进行了验证："
msgstr ""
"AxVisor 被设计为可以在 x86_64、AArch64 、RISC-V LoongArch 四大芯片架构上运"
"行，目前，已经在如下平台进行了验证："

#: src/overview/platform.md:5
msgid "QEMU ARM64 virt (qemu-max)"
msgstr "QEMU ARM64 virt (qemu-max)"

#: src/overview/platform.md:6
msgid "Rockchip RK3568 / RK3588"
msgstr "Rockchip RK3568 / RK3588"

#: src/overview/platform.md:7
msgid "黑芝麻华山 A1000"
msgstr "黑芝麻华山 A1000"

#: src/overview/platform.md:8
msgid ""
"更多硬件平台逐步添加中<style> .scroll-to-top { font-size: 2.5rem; width: "
"3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: "
"center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem "
"+ 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; "
"color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-"
"top.hidden { display: none; } .scroll-to-top i { transform: "
"translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: "
"flex; } } </style> <button type=\"button\" aria-label=\"scroll-to-top\" "
"class=\"scroll-to-top hidden\" onclick=\"scrollToTop()\"> <i class=\"fa fa-"
"angle-up\"></i> </button>"
msgstr ""
"更多硬件平台逐步添加中<style> .scroll-to-top { font-size: 2.5rem; width: "
"3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: "
"center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem "
"+ 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; "
"color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-"
"top.hidden { display: none; } .scroll-to-top i { transform: "
"translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: "
"flex; } } </style> <button type=\"button\" aria-label=\"scroll-to-top\" "
"class=\"scroll-to-top hidden\" onclick=\"scrollToTop()\"> <i class=\"fa fa-"
"angle-up\"></i> </button>"

#: src/overview/guest.md:3
msgid "目前，AxVisor 已经在对如下系统作为客户机的情况进行了验证。"
msgstr "目前，AxVisor 已经在对如下系统作为客户机的情况进行了验证。"

#: src/overview/guest.md:5 src/quickstart/qemu/qemu_aarch64.md:5
#: src/quickstart/aarch64_a1000.md:5 src/quickstart/aarch64_rk3588.md:5
msgid "ArceOS"
msgstr "ArceOS"

#: src/overview/guest.md:7
msgid ""
"[ArceOS](https://github.com/arceos-org/arceos) 是一个用 Rust 编写的专为嵌入式"
"系统和物联网设备设计的轻量级操作系统，提供简单、高效、可定制的功能，适合需要"
"实时响应和低资源开销的应用场景。"
msgstr ""
"[ArceOS](https://github.com/arceos-org/arceos) 是一个用 Rust 编写的专为嵌入式"
"系统和物联网设备设计的轻量级操作系统，提供简单、高效、可定制的功能，适合需要"
"实时响应和低资源开销的应用场景。"

#: src/overview/guest.md:8
msgid "Starry-OS"
msgstr "Starry-OS"

#: src/overview/guest.md:10
msgid ""
"[Starry-OS](https://github.com/Starry-OS) 是一款轻量级、模块化且高效的操作系"
"统，专为嵌入式系统和物联网设备设计。它具有实时性支持、跨平台能力以及灵活的定"
"制选项，适合在资源受限的环境中运行。"
msgstr ""
"[Starry-OS](https://github.com/Starry-OS) 是一款轻量级、模块化且高效的操作系"
"统，专为嵌入式系统和物联网设备设计。它具有实时性支持、跨平台能力以及灵活的定"
"制选项，适合在资源受限的环境中运行。"

#: src/overview/guest.md:12 src/quickstart/qemu/qemu_aarch64.md:231
msgid "NimbOS"
msgstr "NimbOS"

#: src/overview/guest.md:14
msgid ""
"[NimbOS](https://github.com/equation314/nimbos) 是一款用 Rust 编写的专为资源"
"受限环境和嵌入式设备设计的实时操作系统，具有轻量化、实时支持、低功耗、模块化"
"架构等优点。"
msgstr ""
"[NimbOS](https://github.com/equation314/nimbos) 是一款用 Rust 编写的专为资源"
"受限环境和嵌入式设备设计的实时操作系统，具有轻量化、实时支持、低功耗、模块化"
"架构等优点。"

#: src/overview/guest.md:16 src/quickstart/qemu/qemu_aarch64.md:405
#: src/quickstart/aarch64_a1000.md:9 src/quickstart/aarch64_rk3588.md:9
msgid "Linux"
msgstr "Linux"

#: src/overview/guest.md:18
msgid "currently only Linux with passthrough device on aarch64 is tested."
msgstr "currently only Linux with passthrough device on aarch64 is tested."

#: src/overview/guest.md:19
msgid ""
"single core: [config.toml](configs/vms/linux-qemu-aarch64.toml) | [dts]"
"(configs/vms/linux-qemu.dts)"
msgstr ""
"single core: [config.toml](configs/vms/linux-qemu-aarch64.toml) | [dts]"
"(configs/vms/linux-qemu.dts)"

#: src/overview/guest.md:20
msgid ""
"smp: [config.toml](configs/vms/linux-qemu-aarch64-smp2.toml) | [dts](configs/"
"vms/linux-qemu-smp2.dts)"
msgstr ""
"smp: [config.toml](configs/vms/linux-qemu-aarch64-smp2.toml) | [dts](configs/"
"vms/linux-qemu-smp2.dts)"

#: src/quickstart/qemu/qemu.md:1
msgid "Run AxVisor on QEMU"
msgstr "Run AxVisor on QEMU"

#: src/quickstart/qemu/qemu.md:3
msgid ""
"目前，AxVisor 支持在 [aarch64](./qemu_aarch64.md)、[x86_64](./qemu_x86_64."
"md) 以及 [riscv64](./qemu_riscv64.md) 三个体系结构下的 QEMU 上运行。"
msgstr ""
"目前，AxVisor 支持在 [aarch64](./qemu_aarch64.md)、[x86_64](./qemu_x86_64."
"md) 以及 [riscv64](./qemu_riscv64.md) 三个体系结构下的 QEMU 上运行。"

#: src/quickstart/qemu/qemu_aarch64.md:1
msgid "Run AxVisor on QEMU AArch64"
msgstr "Run AxVisor on QEMU AArch64"

#: src/quickstart/qemu/qemu_aarch64.md:3
msgid ""
"目前，在 QEMU AArch64 平台上已经对独立运行 ArceOS 和 Linux 以及同时运行 "
"ArceOS + Linux 的情况进行了验证。"
msgstr ""
"目前，在 QEMU AArch64 平台上已经对独立运行 ArceOS 和 Linux 以及同时运行 "
"ArceOS + Linux 的情况进行了验证。"

#: src/quickstart/qemu/qemu_aarch64.md:7
msgid ""
"首先，获取 ArceOS 主线代码 `git clone https://github.com/arceos-org/arceos."
"git`，然后执行 `make PLATFORM=aarch64-qemu-virt SMP=1 A=examples/helloworld` "
"获取 `helloworld_aarch64-qemu-virt.bin`"
msgstr ""
"首先，获取 ArceOS 主线代码 `git clone https://github.com/arceos-org/arceos."
"git`，然后执行 `make PLATFORM=aarch64-qemu-virt SMP=1 A=examples/helloworld` "
"获取 `helloworld_aarch64-qemu-virt.bin`"

#: src/quickstart/qemu/qemu_aarch64.md:9
#: src/quickstart/qemu/qemu_aarch64.md:237
msgid "从文件系统加载运行"
msgstr "从文件系统加载运行"

#: src/quickstart/qemu/qemu_aarch64.md:11
#: src/quickstart/qemu/qemu_aarch64.md:239
msgid "制作一个磁盘镜像文件，并将客户机镜像放到文件系统中"
msgstr "制作一个磁盘镜像文件，并将客户机镜像放到文件系统中"

#: src/quickstart/qemu/qemu_aarch64.md:13
#: src/quickstart/qemu/qemu_aarch64.md:241
msgid "使用 `make disk_img` 命令生成一个空的 FAT32 磁盘镜像文件 `disk.img`"
msgstr "使用 `make disk_img` 命令生成一个空的 FAT32 磁盘镜像文件 `disk.img`"

#: src/quickstart/qemu/qemu_aarch64.md:14
msgid "手动挂载 `disk.img`，然后将自己的客户机镜像复制到该文件系统中"
msgstr "手动挂载 `disk.img`，然后将自己的客户机镜像复制到该文件系统中"

#: src/quickstart/qemu/qemu_aarch64.md:23
msgid ""
"修改对应的 `./configs/vms/arceos-aarch64.toml` 文件中的配置项 ![](../assets/"
"quickstart/aarch64_qemu_arceos_config_fs.png)"
msgstr ""
"修改对应的 `./configs/vms/arceos-aarch64.toml` 文件中的配置项 ![](../assets/"
"quickstart/aarch64_qemu_arceos_config_fs.png)"

#: src/quickstart/qemu/qemu_aarch64.md:25
#: src/quickstart/qemu/qemu_aarch64.md:254
#: src/quickstart/qemu/qemu_aarch64.md:425
#: src/quickstart/qemu/qemu_aarch64.md:909
msgid "`image_location=\"fs\"` 表示从文件系统加载"
msgstr "`image_location=\"fs\"` 表示从文件系统加载"

#: src/quickstart/qemu/qemu_aarch64.md:26
#: src/quickstart/qemu/qemu_aarch64.md:255
#: src/quickstart/qemu/qemu_aarch64.md:426
#: src/quickstart/qemu/qemu_aarch64.md:910
msgid "`kernel_path` 指出内核镜像在文件系统中的路径"
msgstr "`kernel_path` 指出内核镜像在文件系统中的路径"

#: src/quickstart/qemu/qemu_aarch64.md:27
#: src/quickstart/qemu/qemu_aarch64.md:137
#: src/quickstart/qemu/qemu_aarch64.md:256
#: src/quickstart/qemu/qemu_aarch64.md:427
#: src/quickstart/qemu/qemu_aarch64.md:441
#: src/quickstart/qemu/qemu_aarch64.md:911
#: src/quickstart/qemu/qemu_aarch64.md:931
msgid "`entry_point` 指出内核镜像的入口地址"
msgstr "`entry_point` 指出内核镜像的入口地址"

#: src/quickstart/qemu/qemu_aarch64.md:28
#: src/quickstart/qemu/qemu_aarch64.md:138
#: src/quickstart/qemu/qemu_aarch64.md:257
#: src/quickstart/qemu/qemu_aarch64.md:428
#: src/quickstart/qemu/qemu_aarch64.md:442
#: src/quickstart/qemu/qemu_aarch64.md:912
#: src/quickstart/qemu/qemu_aarch64.md:932
msgid "`kernel_load_addr` 指出内核镜像的加载地址"
msgstr "`kernel_load_addr` 指出内核镜像的加载地址"

#: src/quickstart/qemu/qemu_aarch64.md:29
#: src/quickstart/qemu/qemu_aarch64.md:139
#: src/quickstart/qemu/qemu_aarch64.md:429
#: src/quickstart/qemu/qemu_aarch64.md:443
#: src/quickstart/qemu/qemu_aarch64.md:913
#: src/quickstart/qemu/qemu_aarch64.md:933
msgid "其他"
msgstr "其他"

#: src/quickstart/qemu/qemu_aarch64.md:31
msgid ""
"执行 `make ACCEL=n ARCH=aarch64 LOG=info VM_CONFIGS=configs/vms/arceos-"
"aarch64.toml FEATURES=page-alloc-64g APP_FEATURES=fs run` 构建 AxVisor，并在 "
"QEMU 中启动。"
msgstr ""
"执行 `make ACCEL=n ARCH=aarch64 LOG=info VM_CONFIGS=configs/vms/arceos-"
"aarch64.toml FEATURES=page-alloc-64g APP_FEATURES=fs run` 构建 AxVisor，并在 "
"QEMU 中启动。"

#: src/quickstart/qemu/qemu_aarch64.md:34
#: src/quickstart/qemu/qemu_aarch64.md:145
#: src/quickstart/qemu/qemu_aarch64.md:265
msgid "\" \""
msgstr "\" \""

#: src/quickstart/qemu/qemu_aarch64.md:36
#: src/quickstart/qemu/qemu_aarch64.md:147
#: src/quickstart/qemu/qemu_aarch64.md:267
msgid "\"Y888b.\n"
msgstr "\"Y888b.\n"

#: src/quickstart/qemu/qemu_aarch64.md:37
#: src/quickstart/qemu/qemu_aarch64.md:148
#: src/quickstart/qemu/qemu_aarch64.md:268
msgid "\"    d8P  Y8b 888     888     \""
msgstr "\"    d8P  Y8b 888     888     \""

#: src/quickstart/qemu/qemu_aarch64.md:38
#: src/quickstart/qemu/qemu_aarch64.md:149
#: src/quickstart/qemu/qemu_aarch64.md:269
msgid "\"888\n"
msgstr "\"888\n"

#: src/quickstart/qemu/qemu_aarch64.md:40
#: src/quickstart/qemu/qemu_aarch64.md:151
#: src/quickstart/qemu/qemu_aarch64.md:271
msgid "\"Y8888   \""
msgstr "\"Y8888   \""

#: src/quickstart/qemu/qemu_aarch64.md:40
#: src/quickstart/qemu/qemu_aarch64.md:151
#: src/quickstart/qemu/qemu_aarch64.md:271
msgid "\"   \""
msgstr "\"   \""

#: src/quickstart/qemu/qemu_aarch64.md:40
#: src/quickstart/qemu/qemu_aarch64.md:151
#: src/quickstart/qemu/qemu_aarch64.md:271
msgid ""
"\"\n"
"\n"
msgstr ""
"\"\n"
"\n"

#: src/quickstart/qemu/qemu_aarch64.md:76
#: src/quickstart/qemu/qemu_aarch64.md:78
#: src/quickstart/qemu/qemu_aarch64.md:89
#: src/quickstart/qemu/qemu_aarch64.md:189
#: src/quickstart/qemu/qemu_aarch64.md:307
#: src/quickstart/qemu/qemu_aarch64.md:309
#: src/quickstart/qemu/qemu_aarch64.md:320
msgid "\"\n"
msgstr "\"\n"

#: src/quickstart/qemu/qemu_aarch64.md:103
#: src/quickstart/qemu/qemu_aarch64.md:203
#: src/quickstart/qemu/qemu_aarch64.md:334
msgid "\") created cpumask: [0, ]\n"
msgstr "\") created cpumask: [0, ]\n"

#: src/quickstart/qemu/qemu_aarch64.md:111
#: src/quickstart/qemu/qemu_aarch64.md:211
msgid "\"Y88b d88P  Y88b\n"
msgstr "\"Y88b d88P  Y88b\n"

#: src/quickstart/qemu/qemu_aarch64.md:114
#: src/quickstart/qemu/qemu_aarch64.md:214
msgid "\"   d88P\""
msgstr "\"   d88P\""

#: src/quickstart/qemu/qemu_aarch64.md:114
#: src/quickstart/qemu/qemu_aarch64.md:214
msgid "\"Y88b.\n"
msgstr "\"Y88b.\n"

#: src/quickstart/qemu/qemu_aarch64.md:117
#: src/quickstart/qemu/qemu_aarch64.md:217
msgid "\"Y8888P  \""
msgstr "\"Y8888P  \""

#: src/quickstart/qemu/qemu_aarch64.md:117
#: src/quickstart/qemu/qemu_aarch64.md:217
msgid "\"Y88888P\"   \"Y8888P\""
msgstr "\"Y88888P\"   \"Y8888P\""

#: src/quickstart/qemu/qemu_aarch64.md:131
#: src/quickstart/qemu/qemu_aarch64.md:433
#: src/quickstart/qemu/qemu_aarch64.md:924
msgid "从内存加载运行"
msgstr "从内存加载运行"

#: src/quickstart/qemu/qemu_aarch64.md:133
msgid ""
"修改对应的 `./configs/vms/arceos-aarch64.toml` 中的配置项 ![](../assets/"
"quickstart/aarch64_qemu_arceos_config_mem.png)"
msgstr ""
"修改对应的 `./configs/vms/arceos-aarch64.toml` 中的配置项 ![](../assets/"
"quickstart/aarch64_qemu_arceos_config_mem.png)"

#: src/quickstart/qemu/qemu_aarch64.md:135
#: src/quickstart/qemu/qemu_aarch64.md:439
#: src/quickstart/qemu/qemu_aarch64.md:929
msgid "`image_location=\"memory\"` 配置项"
msgstr "`image_location=\"memory\"` 配置项"

#: src/quickstart/qemu/qemu_aarch64.md:136
#: src/quickstart/qemu/qemu_aarch64.md:440
#: src/quickstart/qemu/qemu_aarch64.md:930
msgid "`kernel_path` 指定内核镜像在工作空间中的相对/绝对路径"
msgstr "`kernel_path` 指定内核镜像在工作空间中的相对/绝对路径"

#: src/quickstart/qemu/qemu_aarch64.md:141
msgid ""
"执行 `make ACCEL=n ARCH=aarch64 LOG=info VM_CONFIGS=configs/vms/arceos-"
"aarch64.toml FEATURES=page-alloc-64g run` 构建 AxVisor，并在 QEMU 中启动。"
msgstr ""
"执行 `make ACCEL=n ARCH=aarch64 LOG=info VM_CONFIGS=configs/vms/arceos-"
"aarch64.toml FEATURES=page-alloc-64g run` 构建 AxVisor，并在 QEMU 中启动。"

#: src/quickstart/qemu/qemu_aarch64.md:233
msgid ""
"[NimbOS](https://github.com/arceos-hypervisor/nimbos) 仓库的 [release]"
"(https://github.com/arceos-hypervisor/nimbos/releases/) 页面已经编译生成了可"
"以直接运行的 NimbOS 二进制镜像文件压缩包："
msgstr ""
"[NimbOS](https://github.com/arceos-hypervisor/nimbos) 仓库的 [release]"
"(https://github.com/arceos-hypervisor/nimbos/releases/) 页面已经编译生成了可"
"以直接运行的 NimbOS 二进制镜像文件压缩包："

#: src/quickstart/qemu/qemu_aarch64.md:234
msgid ""
"不带 `_usertests` 后缀的 NimbOS 二进制镜像包中编译的 NimbOS 启动后会进入 "
"NimbOS 的 shell，本示例启动的就是这个 NimbOS"
msgstr ""
"不带 `_usertests` 后缀的 NimbOS 二进制镜像包中编译的 NimbOS 启动后会进入 "
"NimbOS 的 shell，本示例启动的就是这个 NimbOS"

#: src/quickstart/qemu/qemu_aarch64.md:235
msgid ""
"带 `usertests` 后缀的 NimbOS 二进制镜像压缩包中编译的 NimbOS 启动后会自动运行"
"用户态测例用于测试，这个镜像用于 AxVisor 的CI测试，见 [setup-nimbos-guest-"
"image/action.yml](https://github.com/arceos-hypervisor/axvisor/blob/master/."
"github/workflows/actions/setup-nimbos-guest-image/action.yml)"
msgstr ""
"带 `usertests` 后缀的 NimbOS 二进制镜像压缩包中编译的 NimbOS 启动后会自动运行"
"用户态测例用于测试，这个镜像用于 AxVisor 的CI测试，见 [setup-nimbos-guest-"
"image/action.yml](https://github.com/arceos-hypervisor/axvisor/blob/master/."
"github/workflows/actions/setup-nimbos-guest-image/action.yml)"

#: src/quickstart/qemu/qemu_aarch64.md:242
msgid "手动挂载 `disk.img`，然后拉取并解压二进制镜像"
msgstr "手动挂载 `disk.img`，然后拉取并解压二进制镜像"

#: src/quickstart/qemu/qemu_aarch64.md:248
msgid "# 得到 nimbos.bin\n"
msgstr "# 得到 nimbos.bin\n"

#: src/quickstart/qemu/qemu_aarch64.md:253
msgid ""
"直接使用 [`configs/vms/nimbos-aarch64.toml`](https://github.com/arceos-"
"hypervisor/axvisor/blob/master/configs/vms/nimbos-aarch64.toml) 文件中的配置"
"项"
msgstr ""
"直接使用 [`configs/vms/nimbos-aarch64.toml`](https://github.com/arceos-"
"hypervisor/axvisor/blob/master/configs/vms/nimbos-aarch64.toml) 文件中的配置"
"项"

#: src/quickstart/qemu/qemu_aarch64.md:259
msgid ""
"执行 `make ACCEL=n ARCH=aarch64 LOG=info VM_CONFIGS=configs/vms/nimbos-"
"aarch64.toml FEATURES=page-alloc-64g APP_FEATURES=fs defconfig` 创建 `."
"axconfig.toml` 配置文件"
msgstr ""
"执行 `make ACCEL=n ARCH=aarch64 LOG=info VM_CONFIGS=configs/vms/nimbos-"
"aarch64.toml FEATURES=page-alloc-64g APP_FEATURES=fs defconfig` 创建 `."
"axconfig.toml` 配置文件"

#: src/quickstart/qemu/qemu_aarch64.md:260
msgid ""
"执行 `make ACCEL=n ARCH=aarch64 LOG=info VM_CONFIGS=configs/vms/nimbos-"
"aarch64.toml FEATURES=page-alloc-64g APP_FEATURES=fs run` 构建 AxVisor，并在 "
"QEMU 中启动。"
msgstr ""
"执行 `make ACCEL=n ARCH=aarch64 LOG=info VM_CONFIGS=configs/vms/nimbos-"
"aarch64.toml FEATURES=page-alloc-64g APP_FEATURES=fs run` 构建 AxVisor，并在 "
"QEMU 中启动。"

#: src/quickstart/qemu/qemu_aarch64.md:398
msgid "从内存中加载运行"
msgstr "从内存中加载运行"

#: src/quickstart/qemu/qemu_aarch64.md:400
msgid ""
"参考别的 guest VM 的运行指导，修改对应的 `./configs/vms/nimbos-aarch64.toml` "
"中的配置项即可："
msgstr ""
"参考别的 guest VM 的运行指导，修改对应的 `./configs/vms/nimbos-aarch64.toml` "
"中的配置项即可："

#: src/quickstart/qemu/qemu_aarch64.md:401
msgid "将 `image_location` 配置项修改为 `image_location=\"memory\"`"
msgstr "将 `image_location` 配置项修改为 `image_location=\"memory\"`"

#: src/quickstart/qemu/qemu_aarch64.md:402
msgid ""
"并设置 `kernel_path` 为 nimbos 二进制内核镜像在工作空间中的相对/绝对路径"
msgstr ""
"并设置 `kernel_path` 为 nimbos 二进制内核镜像在工作空间中的相对/绝对路径"

#: src/quickstart/qemu/qemu_aarch64.md:407
msgid ""
"首先，获取 Linux 主线代码 `git clone git@github.com:arceos-hypervisor/"
"linux-6.2.0.git`，然后执行 `make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- "
"defconfig` 再执行 `make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -"
"j$(nproc)` 以获取 `Image`"
msgstr ""
"首先，获取 Linux 主线代码 `git clone git@github.com:arceos-hypervisor/"
"linux-6.2.0.git`，然后执行 `make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- "
"defconfig` 再执行 `make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -"
"j$(nproc)` 以获取 `Image`"

#: src/quickstart/qemu/qemu_aarch64.md:409
msgid ""
"然后，执行 `dtc -I dts -O dtb -o linux-qemu.dtb configs/vms/linux-qemu.dts` "
"编译 Linux 客户机需要使用的设备树文件 `linux-qemu.dtb`"
msgstr ""
"然后，执行 `dtc -I dts -O dtb -o linux-qemu.dtb configs/vms/linux-qemu.dts` "
"编译 Linux 客户机需要使用的设备树文件 `linux-qemu.dtb`"

#: src/quickstart/qemu/qemu_aarch64.md:411
#: src/quickstart/qemu/qemu_aarch64.md:895
msgid "~~从文件系统加载运行~~"
msgstr "~~从文件系统加载运行~~"

#: src/quickstart/qemu/qemu_aarch64.md:413
#: src/quickstart/qemu/qemu_aarch64.md:897
msgid ""
"执行 `make ubuntu_img ARCH=aarch64` 制作一个简单的根文件系统镜像 `disk.img` "
"作为 Linux 客户机启动之后的文件系统，然后手动挂载 `disk.img`，然后将 Image "
"和 linux-qemu.dtb 复制到该文件系统中"
msgstr ""
"执行 `make ubuntu_img ARCH=aarch64` 制作一个简单的根文件系统镜像 `disk.img` "
"作为 Linux 客户机启动之后的文件系统，然后手动挂载 `disk.img`，然后将 Image "
"和 linux-qemu.dtb 复制到该文件系统中"

#: src/quickstart/qemu/qemu_aarch64.md:423
msgid ""
"修改对应的 `./configs/vms/linux-qemu-aarch64.toml` 文件中的配置项 ![](../"
"assets/quickstart/aarch64_qemu_linux_config_fs.png)"
msgstr ""
"修改对应的 `./configs/vms/linux-qemu-aarch64.toml` 文件中的配置项 ![](../"
"assets/quickstart/aarch64_qemu_linux_config_fs.png)"

#: src/quickstart/qemu/qemu_aarch64.md:431
msgid ""
"执行 `make ARCH=aarch64 VM_CONFIGS=configs/vms/linux-qemu-aarch64.toml "
"LOG=debug BUS=mmio NET=y FEATURES=page-alloc-64g,ext4fs APP_FEATURES=fs "
"MEM=8g BLK=y run` 构建 AxVisor，并在 QEMU 中启动。"
msgstr ""
"执行 `make ARCH=aarch64 VM_CONFIGS=configs/vms/linux-qemu-aarch64.toml "
"LOG=debug BUS=mmio NET=y FEATURES=page-alloc-64g,ext4fs APP_FEATURES=fs "
"MEM=8g BLK=y run` 构建 AxVisor，并在 QEMU 中启动。"

#: src/quickstart/qemu/qemu_aarch64.md:435
#: src/quickstart/qemu/qemu_aarch64.md:926
msgid ""
"执行 `make ubuntu_img ARCH=aarch64` 制作一个简单的根文件系统镜像 `disk.img` "
"作为 Linux 客户机启动之后的文件系统"
msgstr ""
"执行 `make ubuntu_img ARCH=aarch64` 制作一个简单的根文件系统镜像 `disk.img` "
"作为 Linux 客户机启动之后的文件系统"

#: src/quickstart/qemu/qemu_aarch64.md:437
msgid ""
"修改对应的 `./configs/vms/linux-qemu-aarch64.toml` 中的配置项 ![](../assets/"
"quickstart/aarch64_qemu_linux_config_mem.png)"
msgstr ""
"修改对应的 `./configs/vms/linux-qemu-aarch64.toml` 中的配置项 ![](../assets/"
"quickstart/aarch64_qemu_linux_config_mem.png)"

#: src/quickstart/qemu/qemu_aarch64.md:445
msgid ""
"执行 `make ARCH=aarch64 VM_CONFIGS=configs/vms/linux-qemu-aarch64.toml "
"LOG=debug BUS=mmio NET=y FEATURES=page-alloc-64g MEM=8g run` 构建 AxVisor，并"
"在 QEMU 中启动。"
msgstr ""
"执行 `make ARCH=aarch64 VM_CONFIGS=configs/vms/linux-qemu-aarch64.toml "
"LOG=debug BUS=mmio NET=y FEATURES=page-alloc-64g MEM=8g run` 构建 AxVisor，并"
"在 QEMU 中启动。"

#: src/quickstart/qemu/qemu_aarch64.md:446
msgid ""
"```\n"
"\n"
"      d8888                            .d88888b.   .d8888b.\n"
"      d88888                           d88P\" \"Y88b d88P  Y88b\n"
"   d88P888                           888     888 Y88b.\n"
"   d88P 888 888d888  .d8888b  .d88b.  888     888  \"Y888b.\n"
"   d88P  888 888P\"   d88P\"    d8P  Y8b 888     888     \"Y88b.\n"
"d88P   888 888     888      88888888 888     888       \"888\n"
"d8888888888 888     Y88b.    Y8b.     Y88b. .d88P Y88b  d88P\n"
"d88P     888 888      \"Y8888P  \"Y8888   \"Y88888P\"   \"Y8888P\"\n"
"\n"
"arch = aarch64\n"
"platform = aarch64-qemu-virt-hv\n"
"target = aarch64-unknown-none-softfloat\n"
"build_mode = release\n"
"log_level = debug\n"
"smp = 1\n"
"\n"
"[  0.021692 0 axruntime:130] Logging is enabled.\n"
"[  0.027480 0 axruntime:131] Primary CPU 0 started, dtb = 0x48000000.\n"
"[  0.029740 0 axruntime:133] Found physcial memory regions:\n"
"[  0.032052 0 axruntime:135]   [PA:0x40080000, PA:0x400d9000) .text (READ | "
"EXECUTE | RESERVED)\n"
"[  0.035160 0 axruntime:135]   [PA:0x400d9000, PA:0x42a86000) .rodata (READ "
"| RESERVED)\n"
"[  0.036925 0 axruntime:135]   [PA:0x42a86000, PA:0x42a8c000) .data .tdata ."
"tbss .percpu (READ | WRITE | RESERVED)\n"
"[  0.038841 0 axruntime:135]   [PA:0x42a8c000, PA:0x42acc000) boot stack "
"(READ | WRITE | RESERVED)\n"
"[  0.040473 0 axruntime:135]   [PA:0x42acc000, PA:0x42cf2000) .bss (READ | "
"WRITE | RESERVED)\n"
"[  0.042098 0 axruntime:135]   [PA:0x42cf2000, PA:0xc0000000) free memory "
"(READ | WRITE | FREE)\n"
"[  0.043965 0 axruntime:135]   [PA:0x9000000, PA:0x9001000) mmio (READ | "
"WRITE | DEVICE | RESERVED)\n"
"[  0.045674 0 axruntime:135]   [PA:0x9040000, PA:0x9041000) mmio (READ | "
"WRITE | DEVICE | RESERVED)\n"
"[  0.047300 0 axruntime:135]   [PA:0x9100000, PA:0x9101000) mmio (READ | "
"WRITE | DEVICE | RESERVED)\n"
"[  0.048928 0 axruntime:135]   [PA:0x8000000, PA:0x8020000) mmio (READ | "
"WRITE | DEVICE | RESERVED)\n"
"[  0.050556 0 axruntime:135]   [PA:0xa000000, PA:0xa004000) mmio (READ | "
"WRITE | DEVICE | RESERVED)\n"
"[  0.052173 0 axruntime:135]   [PA:0x10000000, PA:0x3eff0000) mmio (READ | "
"WRITE | DEVICE | RESERVED)\n"
"[  0.053811 0 axruntime:135]   [PA:0x4010000000, PA:0x4020000000) mmio (READ "
"| WRITE | DEVICE | RESERVED)\n"
"[  0.055851 0 axruntime:208] Initialize global memory allocator...\n"
"[  0.057323 0 axruntime:209]   use TLSF allocator.\n"
"[  0.060322 0 axalloc:230] initialize global allocator at: [0x42cf2000, "
"0xc0000000)\n"
"[  0.073349 0 axmm:60] Initialize virtual memory management...\n"
"[  0.179788 0 axmm:63] kernel address space init OK: AddrSpace {\n"
"   va_range: VA:0x0..VA:0xfffffffff000,\n"
"   page_table_root: PA:0x42cfa000,\n"
"}\n"
"[  0.186432 0 axruntime:150] Initialize platform devices...\n"
"[  0.187828 0 axhal::platform::aarch64_common::gic:67] Initialize GICv2...\n"
"[  0.194027 0 axtask::api:73] Initialize scheduling...\n"
"[  0.199817 0 axtask::task:115] new task: Task(1, \"idle\")\n"
"[  0.204617 0 axtask::task:115] new task: Task(3, \"gc\")\n"
"[  0.207868 0 axalloc:118] expand heap memory: [0x432fb000, 0x4333b000)\n"
"[  0.210474 0 axalloc:118] expand heap memory: [0x4333b000, 0x433bb000)\n"
"[  0.213193 0 axtask::api:79]   use FIFO scheduler.\n"
"[  0.214543 0 axruntime:176] Initialize interrupt handlers...\n"
"[  0.218724 0 axruntime:186] Primary CPU 0 init OK.\n"
"[  0.220417 0:2 axvisor:17] Starting virtualization...\n"
"[  0.222465 0:2 axvisor:19] Hardware support: true\n"
"[  0.224491 0:2 axtask::task:115] new task: Task(4, \"\")\n"
"[  0.226959 0:2 axalloc:118] expand heap memory: [0x433bb000, 0x434bb000)\n"
"[  0.229776 0:2 axtask::run_queue:234] task add: Task(4, \"\") on run_queue "
"0\n"
"[  0.235809 0:3 axtask::run_queue:418] task block: Task(3, \"gc\")\n"
"[  0.237961 0:4 axvisor::vmm::timer:103] Initing HV Timer...\n"
"[  0.239881 0:4 axvisor::hal:117] Hardware virtualization support enabled on "
"core 0\n"
"[  0.243229 0:4 axtask::run_queue:357] task exit: Task(4, \"\"), "
"exit_code=0\n"
"[  0.247022 0:4 axtask::run_queue:260] task unblock: Task(3, \"gc\") on "
"run_queue 0\n"
"[  0.249708 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  0.257112 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  0.267113 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  0.277201 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  0.287106 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  0.297082 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  0.307110 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  0.317084 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  0.327094 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  0.337102 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  0.347177 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  0.357112 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  0.367086 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  0.377094 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  0.386480 0:2 axvisor::vmm::config:33] Creating VM [1] \"linux-qemu\"\n"
"[  0.387827 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  0.393430 0:2 axvm::vm:113] Setting up memory region: "
"[0x80000000~0xc0000000] READ | WRITE | EXECUTE\n"
"[  1.583826 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.586436 0:2 axaddrspace::address_space::backend::linear:22] map_linear: "
"[GPA:0x80000000, GPA:0xc0000000) -> [PA:0x80000000, PA:0xc0000000) READ | "
"WRITE | EXECUTE\n"
"[  1.594936 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.604917 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.614900 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.624917 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.634917 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.644916 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.654915 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.664915 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.674915 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.684915 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.694903 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.704908 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.714920 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.724914 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.734915 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.744914 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.754913 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.764913 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.774916 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.784914 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.794914 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.804913 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.814915 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.824915 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.834914 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.844915 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.854913 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.864923 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.874918 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.884924 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.894922 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.904899 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.914915 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.924915 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.934916 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.944916 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.954902 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.964918 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.974916 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.984900 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.994922 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.004915 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.014914 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.024915 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.034917 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.044913 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.054912 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.064917 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.074909 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.084897 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.094911 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.104912 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.114910 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.124910 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.134897 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.144913 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.154911 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.164912 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.174910 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.184910 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.194914 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.204916 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.214910 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.224910 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.234903 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.244914 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.254911 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.264896 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.274910 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.284909 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.294913 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.297840 0:2 axvm::vm:156] Setting up passthrough device memory region: "
"[0x8000000~0x8050000] -> [0x8000000~0x8050000]\n"
"[  2.300794 0:2 axaddrspace::address_space::backend::linear:22] map_linear: "
"[GPA:0x8000000, GPA:0x8050000) -> [PA:0x8000000, PA:0x8050000) READ | WRITE "
"| DEVICE\n"
"[  2.304533 0:2 axvm::vm:156] Setting up passthrough device memory region: "
"[0x9000000~0x9001000] -> [0x9000000~0x9001000]\n"
"[  2.306624 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.308195 0:2 axaddrspace::address_space::backend::linear:22] map_linear: "
"[GPA:0x9000000, GPA:0x9001000) -> [PA:0x9000000, PA:0x9001000) READ | WRITE "
"| DEVICE\n"
"[  2.310767 0:2 axvm::vm:156] Setting up passthrough device memory region: "
"[0x9010000~0x9011000] -> [0x9010000~0x9011000]\n"
"[  2.312735 0:2 axaddrspace::address_space::backend::linear:22] map_linear: "
"[GPA:0x9010000, GPA:0x9011000) -> [PA:0x9010000, PA:0x9011000) READ | WRITE "
"| DEVICE\n"
"[  2.315260 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.316282 0:2 axvm::vm:156] Setting up passthrough device memory region: "
"[0x9030000~0x9031000] -> [0x9030000~0x9031000]\n"
"[  2.318198 0:2 axaddrspace::address_space::backend::linear:22] map_linear: "
"[GPA:0x9030000, GPA:0x9031000) -> [PA:0x9030000, PA:0x9031000) READ | WRITE "
"| DEVICE\n"
"[  2.320626 0:2 axvm::vm:156] Setting up passthrough device memory region: "
"[0xa000000~0xa004000] -> [0xa000000~0xa004000]\n"
"[  2.322538 0:2 axaddrspace::address_space::backend::linear:22] map_linear: "
"[GPA:0xa000000, GPA:0xa004000) -> [PA:0xa000000, PA:0xa004000) READ | WRITE "
"| DEVICE\n"
"[  2.325021 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.327226 0:2 axvm::vm:191] VM created: id=1\n"
"[  2.329017 0:2 arm_vcpu::vcpu:88] set vcpu entry:GPA:0x80080000\n"
"[  2.330596 0:2 arm_vcpu::vcpu:94] set vcpu ept root:PA:0x434bb000\n"
"[  2.332432 0:2 axvm::vm:206] VM setup: id=1\n"
"[  2.334321 0:2 axvisor::vmm::config:40] VM[1] created success, loading "
"images...\n"
"[  2.335835 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.338162 0:2 axvisor::vmm::images:24] Loading VM[1] images from memory\n"
"[  2.340095 0:2 axvisor::vmm::images:55] loading VM image from memory "
"GPA:0x80080000 43637248\n"
"[  2.343410 0:2 axaddrspace::address_space:203] start GPA:0x80080000 end "
"GPA:0x82a1da00 area size 0x40000000\n"
"[  2.345222 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.354929 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.364922 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.374933 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.384936 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.394937 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.404922 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.414931 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.424933 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.434932 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.444935 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.454932 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.464935 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.474919 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.484932 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.495088 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.504934 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.514933 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.524932 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.534915 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.541916 0:2 axvisor::vmm::images:81] copy size: 2560\n"
"[  2.543664 0:2 axvisor::vmm::images:55] loading VM image from memory "
"GPA:0x80000000 6252\n"
"[  2.545260 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.546363 0:2 axaddrspace::address_space:203] start GPA:0x80000000 end "
"GPA:0x8000186c area size 0x40000000\n"
"[  2.548185 0:2 axvisor::vmm::images:81] copy size: 2156\n"
"[  2.552657 0:2 axvisor::vmm:29] Setting up vcpus...\n"
"[  2.554935 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.557954 0:2 axvisor::vmm::vcpus:176] Initializing VM[1]'s 1 vcpus\n"
"[  2.560474 0:2 axvisor::vmm::vcpus:207] Spawning task for VM[1] Vcpu[0]\n"
"[  2.563430 0:2 axtask::task:115] new task: Task(5, \"VM[1]-VCpu[0]\")\n"
"[  2.564932 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.567172 0:2 axvisor::vmm::vcpus:219] Vcpu task Task(5, \"VM[1]-"
"VCpu[0]\") created cpumask: [0, ]\n"
"[  2.569574 0:2 axtask::run_queue:234] task add: Task(5, \"VM[1]-VCpu[0]\") "
"on run_queue 0\n"
"[  2.572270 0:2 axvisor::vmm:36] VMM starting, booting VMs...\n"
"[  2.573899 0:2 axvm::vm:273] Booting VM[1]\n"
"[  2.574910 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.576666 0:2 axvisor::vmm:42] VM[1] boot success\n"
"[  2.579350 0:2 axtask::run_queue:418] task block: Task(2, \"main\")\n"
"[  2.581788 0:3 axtask::task:433] task drop: Task(4, \"\")\n"
"[  2.583866 0:3 axtask::run_queue:418] task block: Task(3, \"gc\")\n"
"[  2.585237 0:5 axvisor::hal:78] IRQ handler 26\n"
"[  2.587055 0:5 axvisor::vmm::vcpus:240] VM[1] Vcpu[0] waiting for running\n"
"[  2.589337 0:5 axvisor::vmm::vcpus:243] VM[1] Vcpu[0] running...\n"
"[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x410fd083]\n"
"[    0.000000] Linux version 6.9.0-rc5-00159-gc942a0cd3603 (zcs@server) "
"(aarch64-linux-gnu-gcc (Linaro GCC 6.3-2017.05) 6.3.1 20170404, GNU ld "
"(Linaro_Binutils-2017.05) 2.27.0.20161019) #1 SMP PREEMPT Thu Mar 27 "
"08:38:03 UTC 2025\n"
"[    0.000000] KASLR enabled\n"
"[    0.000000] random: crng init done\n"
"[    0.000000] Machine model: linux,dummy-virt\n"
"[    0.000000] efi: UEFI not found.\n"
"[    0.000000] [Firmware Bug]: Kernel image misaligned at boot, please fix "
"your bootloader!\n"
"[    0.000000] earlycon: pl11 at MMIO 0x0000000009000000 (options '')\n"
"[    0.000000] printk: legacy bootconsole [pl11] enabled\n"
"[    0.000000] NUMA: No NUMA configuration found\n"
"[    0.000000] NUMA: Faking a node at [mem "
"0x0000000080000000-0x00000000bfffffff]\n"
"[    0.000000] NUMA: NODE_DATA [mem 0xbfdfd9c0-0xbfdfffff]\n"
"[    0.000000] Zone ranges:\n"
"[    0.000000]   DMA      [mem 0x0000000080000000-0x00000000bfffffff]\n"
"[    0.000000]   DMA32    empty\n"
"[    0.000000]   Normal   empty\n"
"[    0.000000] Movable zone start for each node\n"
"[    0.000000] Early memory node ranges\n"
"[    0.000000]   node   0: [mem 0x0000000080000000-0x00000000bfffffff]\n"
"[    0.000000] Initmem setup node 0 [mem "
"0x0000000080000000-0x00000000bfffffff]\n"
"[    0.000000] cma: Reserved 32 MiB at 0x00000000bcc00000 on node -1\n"
"[    0.000000] psci: probing for conduit method from DT.\n"
"[    0.000000] psci: PSCIv1.1 detected in firmware.\n"
"[    0.000000] psci: Using standard PSCI v0.2 function IDs\n"
"[    0.000000] psci: Trusted OS migration not required\n"
"[    0.000000] psci: SMC Calling Convention v1.0\n"
"[    0.000000] percpu: Embedded 24 pages/cpu s58728 r8192 d31384 u98304\n"
"[    0.000000] Detected PIPT I-cache on CPU0\n"
"[    0.000000] CPU features: detected: Spectre-v2\n"
"[    0.000000] CPU features: detected: Spectre-v3a\n"
"[    0.000000] CPU features: detected: Spectre-v4\n"
"[    0.000000] CPU features: detected: Spectre-BHB\n"
"[    0.000000] CPU features: kernel page table isolation forced ON by KASLR\n"
"[    0.000000] CPU features: detected: Kernel page table isolation (KPTI)\n"
"[    0.000000] CPU features: detected: ARM erratum 1742098\n"
"[    0.000000] CPU features: detected: ARM errata 1165522, 1319367, or "
"1530923\n"
"[    0.000000] alternatives: applying boot alternatives\n"
"[    0.000000] Kernel command line: earlycon console=ttyAMA0 root=/dev/vda "
"rw audit=0 default_hugepagesz=32M hugepagesz=32M hugepages=4\n"
"[    0.000000] audit: disabled (until reboot)\n"
"[    0.000000] Dentry cache hash table entries: 131072 (order: 8, 1048576 "
"bytes, linear)\n"
"[    0.000000] Inode-cache hash table entries: 65536 (order: 7, 524288 "
"bytes, linear)\n"
"[    0.000000] Fallback order for Node 0: 0 \n"
"[    0.000000] Built 1 zonelists, mobility grouping on.  Total pages: "
"258048\n"
"[    0.000000] Policy zone: DMA\n"
"[    0.000000] mem auto-init: stack:off, heap alloc:off, heap free:off\n"
"[    0.000000] software IO TLB: SWIOTLB bounce buffer size adjusted to 1MB\n"
"[    0.000000] software IO TLB: area num 1.\n"
"[    0.000000] software IO TLB: mapped [mem "
"0x00000000bca00000-0x00000000bcb00000] (1MB)\n"
"[    0.000000] Memory: 819184K/1048576K available (16320K kernel code, 4790K "
"rwdata, 11436K rodata, 9920K init, 754K bss, 196624K reserved, 32768K cma-"
"reserved)\n"
"[    0.000000] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1\n"
"[    0.000000] rcu: Preemptible hierarchical RCU implementation.\n"
"[    0.000000] rcu:     RCU event tracing is enabled.\n"
"[    0.000000] rcu:     RCU restricting CPUs from NR_CPUS=512 to "
"nr_cpu_ids=1.\n"
"[    0.000000]  Trampoline variant of Tasks RCU enabled.\n"
"[    0.000000]  Tracing variant of Tasks RCU enabled.\n"
"[    0.000000] rcu: RCU calculated value of scheduler-enlistment delay is 25 "
"jiffies.\n"
"[    0.000000] rcu: Adjusting geometry for rcu_fanout_leaf=16, nr_cpu_ids=1\n"
"[    0.000000] RCU Tasks: Setting shift to 0 and lim to 1 "
"rcu_task_cb_adjust=1.\n"
"[    0.000000] RCU Tasks Trace: Setting shift to 0 and lim to 1 "
"rcu_task_cb_adjust=1.\n"
"[    0.000000] NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0\n"
"[    0.000000] Root IRQ handler: gic_handle_irq\n"
"[    0.000000] GICv2m: range[mem 0x08020000-0x08020fff], SPI[80:143]\n"
"[    0.000000] rcu: srcu_init: Setting srcu_struct sizes based on "
"contention.\n"
"[    0.000000] arch_timer: cp15 timer(s) running at 62.50MHz (virt).\n"
"[    0.000000] clocksource: arch_sys_counter: mask: 0x1ffffffffffffff "
"max_cycles: 0x1cd42e208c, max_idle_ns: 881590405314 ns\n"
"[    0.000582] sched_clock: 57 bits at 63MHz, resolution 16ns, wraps every "
"4398046511096ns\n"
"[    0.067811] Console: colour dummy device 80x25\n"
"[    0.088580] Calibrating delay loop (skipped), value calculated using "
"timer frequency.. 125.00 BogoMIPS (lpj=250000)\n"
"[    0.091632] pid_max: default: 32768 minimum: 301\n"
"[    0.105076] LSM: initializing lsm=capability\n"
"[    0.124408] Mount-cache hash table entries: 2048 (order: 2, 16384 bytes, "
"linear)\n"
"[    0.126743] Mountpoint-cache hash table entries: 2048 (order: 2, 16384 "
"bytes, linear)\n"
"[    0.313628] spectre-v4 mitigation disabled by command-line option\n"
"[    0.345800] cacheinfo: Unable to detect cache hierarchy for CPU 0\n"
"[    0.451040] rcu: Hierarchical SRCU implementation.\n"
"[    0.452834] rcu:     Max phase no-delay instances is 1000.\n"
"[    0.536606] EFI services will not be available.\n"
"[    0.542738] smp: Bringing up secondary CPUs ...\n"
"[    0.550670] smp: Brought up 1 node, 1 CPU\n"
"[    0.551832] SMP: Total of 1 processors activated.\n"
"[    0.553025] CPU: All CPU(s) started at EL1\n"
"[    0.557774] CPU features: detected: 32-bit EL0 Support\n"
"[    0.560104] CPU features: detected: 32-bit EL1 Support\n"
"[    0.561614] CPU features: detected: CRC32 instructions\n"
"[    0.624983] alternatives: applying system-wide alternatives\n"
"[    1.013809] devtmpfs: initialized\n"
"[    1.283345] clocksource: jiffies: mask: 0xffffffff max_cycles: "
"0xffffffff, max_idle_ns: 7645041785100000 ns\n"
"[    1.302370] futex hash table entries: 256 (order: 2, 16384 bytes, "
"linear)\n"
"[    1.359878] pinctrl core: initialized pinctrl subsystem\n"
"[    1.466896] DMI not present or invalid.\n"
"[    1.634290] NET: Registered PF_NETLINK/PF_ROUTE protocol family\n"
"[    1.746001] DMA: preallocated 128 KiB GFP_KERNEL pool for atomic "
"allocations\n"
"[    1.753769] DMA: preallocated 128 KiB GFP_KERNEL|GFP_DMA pool for atomic "
"allocations\n"
"[    1.765784] DMA: preallocated 128 KiB GFP_KERNEL|GFP_DMA32 pool for "
"atomic allocations\n"
"[    1.835254] thermal_sys: Registered thermal governor 'step_wise'\n"
"[    1.835916] thermal_sys: Registered thermal governor 'power_allocator'\n"
"[    1.841594] cpuidle: using governor menu\n"
"[    1.868129] hw-breakpoint: found 6 breakpoint and 4 watchpoint "
"registers.\n"
"[    1.873418] ASID allocator initialised with 32768 entries\n"
"[    1.990036] Serial: AMBA PL011 UART driver\n"
"[    2.870540] 9000000.pl011: ttyAMA0 at MMIO 0x9000000 (irq = 14, base_baud "
"= 0) is a PL011 rev1\n"
"[    2.884892] printk: legacy console [ttyAMA0] enabled\n"
"[    2.884892] printk: legacy console [ttyAMA0] enabled\n"
"[    2.889249] printk: legacy bootconsole [pl11] disabled\n"
"[    2.889249] printk: legacy bootconsole [pl11] disabled\n"
"[    3.023638] Modules: 2G module region forced by "
"RANDOMIZE_MODULE_REGION_FULL\n"
"[    3.025756] Modules: 0 pages in range for non-PLT usage\n"
"[    3.026019] Modules: 513424 pages in range for PLT usage\n"
"[    3.126024] HugeTLB: registered 32.0 MiB page size, pre-allocated 4 "
"pages\n"
"[    3.128534] HugeTLB: 0 KiB vmemmap can be freed for a 32.0 MiB page\n"
"[    3.130469] HugeTLB: registered 1.00 GiB page size, pre-allocated 0 "
"pages\n"
"[    3.131849] HugeTLB: 0 KiB vmemmap can be freed for a 1.00 GiB page\n"
"[    3.133547] HugeTLB: registered 2.00 MiB page size, pre-allocated 0 "
"pages\n"
"[    3.134940] HugeTLB: 0 KiB vmemmap can be freed for a 2.00 MiB page\n"
"[    3.136327] HugeTLB: registered 64.0 KiB page size, pre-allocated 0 "
"pages\n"
"[    3.138049] HugeTLB: 0 KiB vmemmap can be freed for a 64.0 KiB page\n"
"[    3.173964] Demotion targets for Node 0: null\n"
"[    3.249986] ACPI: Interpreter disabled.\n"
"[    3.379952] iommu: Default domain type: Translated\n"
"[    3.382071] iommu: DMA domain TLB invalidation policy: strict mode\n"
"[    3.398457] SCSI subsystem initialized\n"
"[    3.424136] usbcore: registered new interface driver usbfs\n"
"[    3.427239] usbcore: registered new interface driver hub\n"
"[    3.430188] usbcore: registered new device driver usb\n"
"[    3.480030] pps_core: LinuxPPS API ver. 1 registered\n"
"[    3.481191] pps_core: Software ver. 5.3.6 - Copyright 2005-2007 Rodolfo "
"Giometti <giometti@linux.it>\n"
"[    3.483999] PTP clock support registered\n"
"[    3.491134] EDAC MC: Ver: 3.0.0\n"
"[    3.517522] scmi_core: SCMI protocol bus registered\n"
"[    3.567538] FPGA manager framework\n"
"[    3.575630] Advanced Linux Sound Architecture Driver Initialized.\n"
"[    3.698975] vgaarb: loaded\n"
"[    3.740264] clocksource: Switched to clocksource arch_sys_counter\n"
"[    3.769981] VFS: Disk quotas dquot_6.6.0\n"
"[    3.772637] VFS: Dquot-cache hash table entries: 512 (order 0, 4096 "
"bytes)\n"
"[    3.787827] pnp: PnP ACPI: disabled\n"
"[    4.076486] NET: Registered PF_INET protocol family\n"
"[    4.090068] IP idents hash table entries: 16384 (order: 5, 131072 bytes, "
"linear)\n"
"[    4.138853] tcp_listen_portaddr_hash hash table entries: 512 (order: 1, "
"8192 bytes, linear)\n"
"[    4.141016] Table-perturb hash table entries: 65536 (order: 6, 262144 "
"bytes, linear)\n"
"[    4.143752] TCP established hash table entries: 8192 (order: 4, 65536 "
"bytes, linear)\n"
"[    4.146811] TCP bind hash table entries: 8192 (order: 6, 262144 bytes, "
"linear)\n"
"[    4.149988] TCP: Hash tables configured (established 8192 bind 8192)\n"
"[    4.161535] UDP hash table entries: 512 (order: 2, 16384 bytes, linear)\n"
"[    4.164626] UDP-Lite hash table entries: 512 (order: 2, 16384 bytes, "
"linear)\n"
"[    4.174972] NET: Registered PF_UNIX/PF_LOCAL protocol family\n"
"[    4.199967] RPC: Registered named UNIX socket transport module.\n"
"[    4.201931] RPC: Registered udp transport module.\n"
"[    4.203097] RPC: Registered tcp transport module.\n"
"[    4.204199] RPC: Registered tcp-with-tls transport module.\n"
"[    4.205786] RPC: Registered tcp NFSv4.1 backchannel transport module.\n"
"[    4.207904] PCI: CLS 0 bytes, default 64\n"
"[    4.246417] kvm [1]: HYP mode not available\n"
"[    4.310161] Initialise system trusted keyrings\n"
"[    4.323677] workingset: timestamp_bits=42 max_order=18 bucket_order=0\n"
"[    4.346518] squashfs: version 4.0 (2009/01/31) Phillip Lougher\n"
"[    4.361970] NFS: Registering the id_resolver key type\n"
"[    4.366154] Key type id_resolver registered\n"
"[    4.367310] Key type id_legacy registered\n"
"[    4.370932] nfs4filelayout_init: NFSv4 File Layout Driver Registering...\n"
"[    4.372907] nfs4flexfilelayout_init: NFSv4 Flexfile Layout Driver "
"Registering...\n"
"[    4.380570] 9p: Installing v9fs 9p2000 file system support\n"
"[    4.996390] Key type asymmetric registered\n"
"[    4.998188] Asymmetric key parser 'x509' registered\n"
"[    5.001702] Block layer SCSI generic (bsg) driver version 0.4 loaded "
"(major 245)\n"
"[    5.004042] io scheduler mq-deadline registered\n"
"[    5.005987] io scheduler kyber registered\n"
"[    5.009909] io scheduler bfq registered\n"
"[    5.533535] pl061_gpio 9030000.pl061: PL061 GPIO chip registered\n"
"[    7.293859] Serial: 8250/16550 driver, 4 ports, IRQ sharing enabled\n"
"[    7.463278] msm_serial: driver initialized\n"
"[    7.483055] SuperH (H)SCI(F) driver initialized\n"
"[    7.494097] STM32 USART driver initialized\n"
"[    7.837823] loop: module loaded\n"
"[    7.845491] virtio_blk virtio1: 1/0/0 default/read/poll queues\n"
"[    7.881698] virtio_blk virtio1: [vda] 409600 512-byte logical blocks (210 "
"MB/200 MiB)\n"
"[    8.067674] megasas: 07.727.03.00-rc1\n"
"[    8.417069] tun: Universal TUN/TAP device driver, 1.6\n"
"[    8.530353] thunder_xcv, ver 1.0\n"
"[    8.532526] thunder_bgx, ver 1.0\n"
"[    8.534871] nicpf, ver 1.0\n"
"[    8.599326] hns3: Hisilicon Ethernet Network Driver for Hip08 Family - "
"version\n"
"[    8.600813] hns3: Copyright (c) 2017 Huawei Corporation.\n"
"[    8.604631] hclge is initializing\n"
"[    8.607113] e1000: Intel(R) PRO/1000 Network Driver\n"
"[    8.608211] e1000: Copyright (c) 1999-2006 Intel Corporation.\n"
"[    8.611096] e1000e: Intel(R) PRO/1000 Network Driver\n"
"[    8.612176] e1000e: Copyright(c) 1999 - 2015 Intel Corporation.\n"
"[    8.614814] igb: Intel(R) Gigabit Ethernet Network Driver\n"
"[    8.616017] igb: Copyright (c) 2007-2014 Intel Corporation.\n"
"[    8.618576] igbvf: Intel(R) Gigabit Virtual Function Network Driver\n"
"[    8.619876] igbvf: Copyright (c) 2009 - 2012 Intel Corporation.\n"
"[    8.637868] sky2: driver version 1.30\n"
"[    8.706118] VFIO - User Level meta-driver version: 0.3\n"
"[    8.871414] usbcore: registered new interface driver usb-storage\n"
"[    9.042230] rtc-pl031 9010000.pl031: registered as rtc0\n"
"[    9.048077] rtc-pl031 9010000.pl031: setting system clock to "
"2025-03-28T00:22:57 UTC (1743121377)\n"
"[    9.089588] i2c_dev: i2c /dev entries driver\n"
"[    9.482386] sdhci: Secure Digital Host Controller Interface driver\n"
"[    9.483722] sdhci: Copyright(c) Pierre Ossman\n"
"[    9.527371] Synopsys Designware Multimedia Card Interface Driver\n"
"[    9.581108] sdhci-pltfm: SDHCI platform and OF driver helper\n"
"[    9.693508] ledtrig-cpu: registered to indicate activity on CPUs\n"
"[    9.786376] usbcore: registered new interface driver usbhid\n"
"[    9.787707] usbhid: USB HID core driver\n"
"[    9.987141] hw perfevents: enabled with armv8_pmuv3 PMU driver, 7 "
"counters available\n"
"[   10.250455] NET: Registered PF_PACKET protocol family\n"
"[   10.263124] 9pnet: Installing 9P2000 support\n"
"[   10.266705] Key type dns_resolver registered\n"
"[   10.912946] registered taskstats version 1\n"
"[   10.946074] Loading compiled-in X.509 certificates\n"
"[   11.433115] input: gpio-keys as /devices/platform/gpio-keys/input/input0\n"
"[   11.482267] clk: Disabling unused clocks\n"
"[   11.485549] PM: genpd: Disabling unused power domains\n"
"[   11.488619] ALSA device list:\n"
"[   11.490399]   No soundcards found.\n"
"[   11.791974] EXT4-fs (vda): mounted filesystem a30d5de0-4011-48c0-9e48-"
"a4556726e425 r/w with ordered data mode. Quota mode: none.\n"
"[   11.797909] VFS: Mounted root (ext4 filesystem) on device 254:0.\n"
"[   11.815481] devtmpfs: mounted\n"
"[   12.252692] Freeing unused kernel memory: 9920K\n"
"[   12.262413] Run /sbin/init as init process\n"
"[   12.331806] Run /etc/init as init process\n"
"[   12.336529] Run /bin/init as init process\n"
"[   12.355530] Run /bin/sh as init process\n"
"/bin/sh: 0: can't access tty; job control turned off\n"
"# \n"
"```"
msgstr ""
"```\n"
"\n"
"      d8888                            .d88888b.   .d8888b.\n"
"      d88888                           d88P\" \"Y88b d88P  Y88b\n"
"   d88P888                           888     888 Y88b.\n"
"   d88P 888 888d888  .d8888b  .d88b.  888     888  \"Y888b.\n"
"   d88P  888 888P\"   d88P\"    d8P  Y8b 888     888     \"Y88b.\n"
"d88P   888 888     888      88888888 888     888       \"888\n"
"d8888888888 888     Y88b.    Y8b.     Y88b. .d88P Y88b  d88P\n"
"d88P     888 888      \"Y8888P  \"Y8888   \"Y88888P\"   \"Y8888P\"\n"
"\n"
"arch = aarch64\n"
"platform = aarch64-qemu-virt-hv\n"
"target = aarch64-unknown-none-softfloat\n"
"build_mode = release\n"
"log_level = debug\n"
"smp = 1\n"
"\n"
"[  0.021692 0 axruntime:130] Logging is enabled.\n"
"[  0.027480 0 axruntime:131] Primary CPU 0 started, dtb = 0x48000000.\n"
"[  0.029740 0 axruntime:133] Found physcial memory regions:\n"
"[  0.032052 0 axruntime:135]   [PA:0x40080000, PA:0x400d9000) .text (READ | "
"EXECUTE | RESERVED)\n"
"[  0.035160 0 axruntime:135]   [PA:0x400d9000, PA:0x42a86000) .rodata (READ "
"| RESERVED)\n"
"[  0.036925 0 axruntime:135]   [PA:0x42a86000, PA:0x42a8c000) .data .tdata ."
"tbss .percpu (READ | WRITE | RESERVED)\n"
"[  0.038841 0 axruntime:135]   [PA:0x42a8c000, PA:0x42acc000) boot stack "
"(READ | WRITE | RESERVED)\n"
"[  0.040473 0 axruntime:135]   [PA:0x42acc000, PA:0x42cf2000) .bss (READ | "
"WRITE | RESERVED)\n"
"[  0.042098 0 axruntime:135]   [PA:0x42cf2000, PA:0xc0000000) free memory "
"(READ | WRITE | FREE)\n"
"[  0.043965 0 axruntime:135]   [PA:0x9000000, PA:0x9001000) mmio (READ | "
"WRITE | DEVICE | RESERVED)\n"
"[  0.045674 0 axruntime:135]   [PA:0x9040000, PA:0x9041000) mmio (READ | "
"WRITE | DEVICE | RESERVED)\n"
"[  0.047300 0 axruntime:135]   [PA:0x9100000, PA:0x9101000) mmio (READ | "
"WRITE | DEVICE | RESERVED)\n"
"[  0.048928 0 axruntime:135]   [PA:0x8000000, PA:0x8020000) mmio (READ | "
"WRITE | DEVICE | RESERVED)\n"
"[  0.050556 0 axruntime:135]   [PA:0xa000000, PA:0xa004000) mmio (READ | "
"WRITE | DEVICE | RESERVED)\n"
"[  0.052173 0 axruntime:135]   [PA:0x10000000, PA:0x3eff0000) mmio (READ | "
"WRITE | DEVICE | RESERVED)\n"
"[  0.053811 0 axruntime:135]   [PA:0x4010000000, PA:0x4020000000) mmio (READ "
"| WRITE | DEVICE | RESERVED)\n"
"[  0.055851 0 axruntime:208] Initialize global memory allocator...\n"
"[  0.057323 0 axruntime:209]   use TLSF allocator.\n"
"[  0.060322 0 axalloc:230] initialize global allocator at: [0x42cf2000, "
"0xc0000000)\n"
"[  0.073349 0 axmm:60] Initialize virtual memory management...\n"
"[  0.179788 0 axmm:63] kernel address space init OK: AddrSpace {\n"
"   va_range: VA:0x0..VA:0xfffffffff000,\n"
"   page_table_root: PA:0x42cfa000,\n"
"}\n"
"[  0.186432 0 axruntime:150] Initialize platform devices...\n"
"[  0.187828 0 axhal::platform::aarch64_common::gic:67] Initialize GICv2...\n"
"[  0.194027 0 axtask::api:73] Initialize scheduling...\n"
"[  0.199817 0 axtask::task:115] new task: Task(1, \"idle\")\n"
"[  0.204617 0 axtask::task:115] new task: Task(3, \"gc\")\n"
"[  0.207868 0 axalloc:118] expand heap memory: [0x432fb000, 0x4333b000)\n"
"[  0.210474 0 axalloc:118] expand heap memory: [0x4333b000, 0x433bb000)\n"
"[  0.213193 0 axtask::api:79]   use FIFO scheduler.\n"
"[  0.214543 0 axruntime:176] Initialize interrupt handlers...\n"
"[  0.218724 0 axruntime:186] Primary CPU 0 init OK.\n"
"[  0.220417 0:2 axvisor:17] Starting virtualization...\n"
"[  0.222465 0:2 axvisor:19] Hardware support: true\n"
"[  0.224491 0:2 axtask::task:115] new task: Task(4, \"\")\n"
"[  0.226959 0:2 axalloc:118] expand heap memory: [0x433bb000, 0x434bb000)\n"
"[  0.229776 0:2 axtask::run_queue:234] task add: Task(4, \"\") on run_queue "
"0\n"
"[  0.235809 0:3 axtask::run_queue:418] task block: Task(3, \"gc\")\n"
"[  0.237961 0:4 axvisor::vmm::timer:103] Initing HV Timer...\n"
"[  0.239881 0:4 axvisor::hal:117] Hardware virtualization support enabled on "
"core 0\n"
"[  0.243229 0:4 axtask::run_queue:357] task exit: Task(4, \"\"), "
"exit_code=0\n"
"[  0.247022 0:4 axtask::run_queue:260] task unblock: Task(3, \"gc\") on "
"run_queue 0\n"
"[  0.249708 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  0.257112 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  0.267113 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  0.277201 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  0.287106 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  0.297082 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  0.307110 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  0.317084 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  0.327094 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  0.337102 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  0.347177 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  0.357112 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  0.367086 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  0.377094 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  0.386480 0:2 axvisor::vmm::config:33] Creating VM [1] \"linux-qemu\"\n"
"[  0.387827 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  0.393430 0:2 axvm::vm:113] Setting up memory region: "
"[0x80000000~0xc0000000] READ | WRITE | EXECUTE\n"
"[  1.583826 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.586436 0:2 axaddrspace::address_space::backend::linear:22] map_linear: "
"[GPA:0x80000000, GPA:0xc0000000) -> [PA:0x80000000, PA:0xc0000000) READ | "
"WRITE | EXECUTE\n"
"[  1.594936 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.604917 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.614900 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.624917 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.634917 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.644916 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.654915 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.664915 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.674915 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.684915 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.694903 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.704908 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.714920 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.724914 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.734915 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.744914 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.754913 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.764913 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.774916 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.784914 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.794914 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.804913 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.814915 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.824915 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.834914 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.844915 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.854913 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.864923 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.874918 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.884924 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.894922 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.904899 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.914915 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.924915 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.934916 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.944916 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.954902 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.964918 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.974916 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.984900 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  1.994922 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.004915 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.014914 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.024915 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.034917 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.044913 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.054912 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.064917 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.074909 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.084897 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.094911 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.104912 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.114910 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.124910 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.134897 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.144913 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.154911 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.164912 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.174910 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.184910 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.194914 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.204916 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.214910 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.224910 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.234903 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.244914 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.254911 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.264896 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.274910 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.284909 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.294913 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.297840 0:2 axvm::vm:156] Setting up passthrough device memory region: "
"[0x8000000~0x8050000] -> [0x8000000~0x8050000]\n"
"[  2.300794 0:2 axaddrspace::address_space::backend::linear:22] map_linear: "
"[GPA:0x8000000, GPA:0x8050000) -> [PA:0x8000000, PA:0x8050000) READ | WRITE "
"| DEVICE\n"
"[  2.304533 0:2 axvm::vm:156] Setting up passthrough device memory region: "
"[0x9000000~0x9001000] -> [0x9000000~0x9001000]\n"
"[  2.306624 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.308195 0:2 axaddrspace::address_space::backend::linear:22] map_linear: "
"[GPA:0x9000000, GPA:0x9001000) -> [PA:0x9000000, PA:0x9001000) READ | WRITE "
"| DEVICE\n"
"[  2.310767 0:2 axvm::vm:156] Setting up passthrough device memory region: "
"[0x9010000~0x9011000] -> [0x9010000~0x9011000]\n"
"[  2.312735 0:2 axaddrspace::address_space::backend::linear:22] map_linear: "
"[GPA:0x9010000, GPA:0x9011000) -> [PA:0x9010000, PA:0x9011000) READ | WRITE "
"| DEVICE\n"
"[  2.315260 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.316282 0:2 axvm::vm:156] Setting up passthrough device memory region: "
"[0x9030000~0x9031000] -> [0x9030000~0x9031000]\n"
"[  2.318198 0:2 axaddrspace::address_space::backend::linear:22] map_linear: "
"[GPA:0x9030000, GPA:0x9031000) -> [PA:0x9030000, PA:0x9031000) READ | WRITE "
"| DEVICE\n"
"[  2.320626 0:2 axvm::vm:156] Setting up passthrough device memory region: "
"[0xa000000~0xa004000] -> [0xa000000~0xa004000]\n"
"[  2.322538 0:2 axaddrspace::address_space::backend::linear:22] map_linear: "
"[GPA:0xa000000, GPA:0xa004000) -> [PA:0xa000000, PA:0xa004000) READ | WRITE "
"| DEVICE\n"
"[  2.325021 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.327226 0:2 axvm::vm:191] VM created: id=1\n"
"[  2.329017 0:2 arm_vcpu::vcpu:88] set vcpu entry:GPA:0x80080000\n"
"[  2.330596 0:2 arm_vcpu::vcpu:94] set vcpu ept root:PA:0x434bb000\n"
"[  2.332432 0:2 axvm::vm:206] VM setup: id=1\n"
"[  2.334321 0:2 axvisor::vmm::config:40] VM[1] created success, loading "
"images...\n"
"[  2.335835 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.338162 0:2 axvisor::vmm::images:24] Loading VM[1] images from memory\n"
"[  2.340095 0:2 axvisor::vmm::images:55] loading VM image from memory "
"GPA:0x80080000 43637248\n"
"[  2.343410 0:2 axaddrspace::address_space:203] start GPA:0x80080000 end "
"GPA:0x82a1da00 area size 0x40000000\n"
"[  2.345222 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.354929 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.364922 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.374933 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.384936 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.394937 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.404922 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.414931 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.424933 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.434932 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.444935 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.454932 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.464935 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.474919 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.484932 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.495088 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.504934 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.514933 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.524932 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.534915 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.541916 0:2 axvisor::vmm::images:81] copy size: 2560\n"
"[  2.543664 0:2 axvisor::vmm::images:55] loading VM image from memory "
"GPA:0x80000000 6252\n"
"[  2.545260 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.546363 0:2 axaddrspace::address_space:203] start GPA:0x80000000 end "
"GPA:0x8000186c area size 0x40000000\n"
"[  2.548185 0:2 axvisor::vmm::images:81] copy size: 2156\n"
"[  2.552657 0:2 axvisor::vmm:29] Setting up vcpus...\n"
"[  2.554935 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.557954 0:2 axvisor::vmm::vcpus:176] Initializing VM[1]'s 1 vcpus\n"
"[  2.560474 0:2 axvisor::vmm::vcpus:207] Spawning task for VM[1] Vcpu[0]\n"
"[  2.563430 0:2 axtask::task:115] new task: Task(5, \"VM[1]-VCpu[0]\")\n"
"[  2.564932 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.567172 0:2 axvisor::vmm::vcpus:219] Vcpu task Task(5, \"VM[1]-"
"VCpu[0]\") created cpumask: [0, ]\n"
"[  2.569574 0:2 axtask::run_queue:234] task add: Task(5, \"VM[1]-VCpu[0]\") "
"on run_queue 0\n"
"[  2.572270 0:2 axvisor::vmm:36] VMM starting, booting VMs...\n"
"[  2.573899 0:2 axvm::vm:273] Booting VM[1]\n"
"[  2.574910 0:2 axvisor::hal:78] IRQ handler 26\n"
"[  2.576666 0:2 axvisor::vmm:42] VM[1] boot success\n"
"[  2.579350 0:2 axtask::run_queue:418] task block: Task(2, \"main\")\n"
"[  2.581788 0:3 axtask::task:433] task drop: Task(4, \"\")\n"
"[  2.583866 0:3 axtask::run_queue:418] task block: Task(3, \"gc\")\n"
"[  2.585237 0:5 axvisor::hal:78] IRQ handler 26\n"
"[  2.587055 0:5 axvisor::vmm::vcpus:240] VM[1] Vcpu[0] waiting for running\n"
"[  2.589337 0:5 axvisor::vmm::vcpus:243] VM[1] Vcpu[0] running...\n"
"[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x410fd083]\n"
"[    0.000000] Linux version 6.9.0-rc5-00159-gc942a0cd3603 (zcs@server) "
"(aarch64-linux-gnu-gcc (Linaro GCC 6.3-2017.05) 6.3.1 20170404, GNU ld "
"(Linaro_Binutils-2017.05) 2.27.0.20161019) #1 SMP PREEMPT Thu Mar 27 "
"08:38:03 UTC 2025\n"
"[    0.000000] KASLR enabled\n"
"[    0.000000] random: crng init done\n"
"[    0.000000] Machine model: linux,dummy-virt\n"
"[    0.000000] efi: UEFI not found.\n"
"[    0.000000] [Firmware Bug]: Kernel image misaligned at boot, please fix "
"your bootloader!\n"
"[    0.000000] earlycon: pl11 at MMIO 0x0000000009000000 (options '')\n"
"[    0.000000] printk: legacy bootconsole [pl11] enabled\n"
"[    0.000000] NUMA: No NUMA configuration found\n"
"[    0.000000] NUMA: Faking a node at [mem "
"0x0000000080000000-0x00000000bfffffff]\n"
"[    0.000000] NUMA: NODE_DATA [mem 0xbfdfd9c0-0xbfdfffff]\n"
"[    0.000000] Zone ranges:\n"
"[    0.000000]   DMA      [mem 0x0000000080000000-0x00000000bfffffff]\n"
"[    0.000000]   DMA32    empty\n"
"[    0.000000]   Normal   empty\n"
"[    0.000000] Movable zone start for each node\n"
"[    0.000000] Early memory node ranges\n"
"[    0.000000]   node   0: [mem 0x0000000080000000-0x00000000bfffffff]\n"
"[    0.000000] Initmem setup node 0 [mem "
"0x0000000080000000-0x00000000bfffffff]\n"
"[    0.000000] cma: Reserved 32 MiB at 0x00000000bcc00000 on node -1\n"
"[    0.000000] psci: probing for conduit method from DT.\n"
"[    0.000000] psci: PSCIv1.1 detected in firmware.\n"
"[    0.000000] psci: Using standard PSCI v0.2 function IDs\n"
"[    0.000000] psci: Trusted OS migration not required\n"
"[    0.000000] psci: SMC Calling Convention v1.0\n"
"[    0.000000] percpu: Embedded 24 pages/cpu s58728 r8192 d31384 u98304\n"
"[    0.000000] Detected PIPT I-cache on CPU0\n"
"[    0.000000] CPU features: detected: Spectre-v2\n"
"[    0.000000] CPU features: detected: Spectre-v3a\n"
"[    0.000000] CPU features: detected: Spectre-v4\n"
"[    0.000000] CPU features: detected: Spectre-BHB\n"
"[    0.000000] CPU features: kernel page table isolation forced ON by KASLR\n"
"[    0.000000] CPU features: detected: Kernel page table isolation (KPTI)\n"
"[    0.000000] CPU features: detected: ARM erratum 1742098\n"
"[    0.000000] CPU features: detected: ARM errata 1165522, 1319367, or "
"1530923\n"
"[    0.000000] alternatives: applying boot alternatives\n"
"[    0.000000] Kernel command line: earlycon console=ttyAMA0 root=/dev/vda "
"rw audit=0 default_hugepagesz=32M hugepagesz=32M hugepages=4\n"
"[    0.000000] audit: disabled (until reboot)\n"
"[    0.000000] Dentry cache hash table entries: 131072 (order: 8, 1048576 "
"bytes, linear)\n"
"[    0.000000] Inode-cache hash table entries: 65536 (order: 7, 524288 "
"bytes, linear)\n"
"[    0.000000] Fallback order for Node 0: 0 \n"
"[    0.000000] Built 1 zonelists, mobility grouping on.  Total pages: "
"258048\n"
"[    0.000000] Policy zone: DMA\n"
"[    0.000000] mem auto-init: stack:off, heap alloc:off, heap free:off\n"
"[    0.000000] software IO TLB: SWIOTLB bounce buffer size adjusted to 1MB\n"
"[    0.000000] software IO TLB: area num 1.\n"
"[    0.000000] software IO TLB: mapped [mem "
"0x00000000bca00000-0x00000000bcb00000] (1MB)\n"
"[    0.000000] Memory: 819184K/1048576K available (16320K kernel code, 4790K "
"rwdata, 11436K rodata, 9920K init, 754K bss, 196624K reserved, 32768K cma-"
"reserved)\n"
"[    0.000000] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1\n"
"[    0.000000] rcu: Preemptible hierarchical RCU implementation.\n"
"[    0.000000] rcu:     RCU event tracing is enabled.\n"
"[    0.000000] rcu:     RCU restricting CPUs from NR_CPUS=512 to "
"nr_cpu_ids=1.\n"
"[    0.000000]  Trampoline variant of Tasks RCU enabled.\n"
"[    0.000000]  Tracing variant of Tasks RCU enabled.\n"
"[    0.000000] rcu: RCU calculated value of scheduler-enlistment delay is 25 "
"jiffies.\n"
"[    0.000000] rcu: Adjusting geometry for rcu_fanout_leaf=16, nr_cpu_ids=1\n"
"[    0.000000] RCU Tasks: Setting shift to 0 and lim to 1 "
"rcu_task_cb_adjust=1.\n"
"[    0.000000] RCU Tasks Trace: Setting shift to 0 and lim to 1 "
"rcu_task_cb_adjust=1.\n"
"[    0.000000] NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0\n"
"[    0.000000] Root IRQ handler: gic_handle_irq\n"
"[    0.000000] GICv2m: range[mem 0x08020000-0x08020fff], SPI[80:143]\n"
"[    0.000000] rcu: srcu_init: Setting srcu_struct sizes based on "
"contention.\n"
"[    0.000000] arch_timer: cp15 timer(s) running at 62.50MHz (virt).\n"
"[    0.000000] clocksource: arch_sys_counter: mask: 0x1ffffffffffffff "
"max_cycles: 0x1cd42e208c, max_idle_ns: 881590405314 ns\n"
"[    0.000582] sched_clock: 57 bits at 63MHz, resolution 16ns, wraps every "
"4398046511096ns\n"
"[    0.067811] Console: colour dummy device 80x25\n"
"[    0.088580] Calibrating delay loop (skipped), value calculated using "
"timer frequency.. 125.00 BogoMIPS (lpj=250000)\n"
"[    0.091632] pid_max: default: 32768 minimum: 301\n"
"[    0.105076] LSM: initializing lsm=capability\n"
"[    0.124408] Mount-cache hash table entries: 2048 (order: 2, 16384 bytes, "
"linear)\n"
"[    0.126743] Mountpoint-cache hash table entries: 2048 (order: 2, 16384 "
"bytes, linear)\n"
"[    0.313628] spectre-v4 mitigation disabled by command-line option\n"
"[    0.345800] cacheinfo: Unable to detect cache hierarchy for CPU 0\n"
"[    0.451040] rcu: Hierarchical SRCU implementation.\n"
"[    0.452834] rcu:     Max phase no-delay instances is 1000.\n"
"[    0.536606] EFI services will not be available.\n"
"[    0.542738] smp: Bringing up secondary CPUs ...\n"
"[    0.550670] smp: Brought up 1 node, 1 CPU\n"
"[    0.551832] SMP: Total of 1 processors activated.\n"
"[    0.553025] CPU: All CPU(s) started at EL1\n"
"[    0.557774] CPU features: detected: 32-bit EL0 Support\n"
"[    0.560104] CPU features: detected: 32-bit EL1 Support\n"
"[    0.561614] CPU features: detected: CRC32 instructions\n"
"[    0.624983] alternatives: applying system-wide alternatives\n"
"[    1.013809] devtmpfs: initialized\n"
"[    1.283345] clocksource: jiffies: mask: 0xffffffff max_cycles: "
"0xffffffff, max_idle_ns: 7645041785100000 ns\n"
"[    1.302370] futex hash table entries: 256 (order: 2, 16384 bytes, "
"linear)\n"
"[    1.359878] pinctrl core: initialized pinctrl subsystem\n"
"[    1.466896] DMI not present or invalid.\n"
"[    1.634290] NET: Registered PF_NETLINK/PF_ROUTE protocol family\n"
"[    1.746001] DMA: preallocated 128 KiB GFP_KERNEL pool for atomic "
"allocations\n"
"[    1.753769] DMA: preallocated 128 KiB GFP_KERNEL|GFP_DMA pool for atomic "
"allocations\n"
"[    1.765784] DMA: preallocated 128 KiB GFP_KERNEL|GFP_DMA32 pool for "
"atomic allocations\n"
"[    1.835254] thermal_sys: Registered thermal governor 'step_wise'\n"
"[    1.835916] thermal_sys: Registered thermal governor 'power_allocator'\n"
"[    1.841594] cpuidle: using governor menu\n"
"[    1.868129] hw-breakpoint: found 6 breakpoint and 4 watchpoint "
"registers.\n"
"[    1.873418] ASID allocator initialised with 32768 entries\n"
"[    1.990036] Serial: AMBA PL011 UART driver\n"
"[    2.870540] 9000000.pl011: ttyAMA0 at MMIO 0x9000000 (irq = 14, base_baud "
"= 0) is a PL011 rev1\n"
"[    2.884892] printk: legacy console [ttyAMA0] enabled\n"
"[    2.884892] printk: legacy console [ttyAMA0] enabled\n"
"[    2.889249] printk: legacy bootconsole [pl11] disabled\n"
"[    2.889249] printk: legacy bootconsole [pl11] disabled\n"
"[    3.023638] Modules: 2G module region forced by "
"RANDOMIZE_MODULE_REGION_FULL\n"
"[    3.025756] Modules: 0 pages in range for non-PLT usage\n"
"[    3.026019] Modules: 513424 pages in range for PLT usage\n"
"[    3.126024] HugeTLB: registered 32.0 MiB page size, pre-allocated 4 "
"pages\n"
"[    3.128534] HugeTLB: 0 KiB vmemmap can be freed for a 32.0 MiB page\n"
"[    3.130469] HugeTLB: registered 1.00 GiB page size, pre-allocated 0 "
"pages\n"
"[    3.131849] HugeTLB: 0 KiB vmemmap can be freed for a 1.00 GiB page\n"
"[    3.133547] HugeTLB: registered 2.00 MiB page size, pre-allocated 0 "
"pages\n"
"[    3.134940] HugeTLB: 0 KiB vmemmap can be freed for a 2.00 MiB page\n"
"[    3.136327] HugeTLB: registered 64.0 KiB page size, pre-allocated 0 "
"pages\n"
"[    3.138049] HugeTLB: 0 KiB vmemmap can be freed for a 64.0 KiB page\n"
"[    3.173964] Demotion targets for Node 0: null\n"
"[    3.249986] ACPI: Interpreter disabled.\n"
"[    3.379952] iommu: Default domain type: Translated\n"
"[    3.382071] iommu: DMA domain TLB invalidation policy: strict mode\n"
"[    3.398457] SCSI subsystem initialized\n"
"[    3.424136] usbcore: registered new interface driver usbfs\n"
"[    3.427239] usbcore: registered new interface driver hub\n"
"[    3.430188] usbcore: registered new device driver usb\n"
"[    3.480030] pps_core: LinuxPPS API ver. 1 registered\n"
"[    3.481191] pps_core: Software ver. 5.3.6 - Copyright 2005-2007 Rodolfo "
"Giometti <giometti@linux.it>\n"
"[    3.483999] PTP clock support registered\n"
"[    3.491134] EDAC MC: Ver: 3.0.0\n"
"[    3.517522] scmi_core: SCMI protocol bus registered\n"
"[    3.567538] FPGA manager framework\n"
"[    3.575630] Advanced Linux Sound Architecture Driver Initialized.\n"
"[    3.698975] vgaarb: loaded\n"
"[    3.740264] clocksource: Switched to clocksource arch_sys_counter\n"
"[    3.769981] VFS: Disk quotas dquot_6.6.0\n"
"[    3.772637] VFS: Dquot-cache hash table entries: 512 (order 0, 4096 "
"bytes)\n"
"[    3.787827] pnp: PnP ACPI: disabled\n"
"[    4.076486] NET: Registered PF_INET protocol family\n"
"[    4.090068] IP idents hash table entries: 16384 (order: 5, 131072 bytes, "
"linear)\n"
"[    4.138853] tcp_listen_portaddr_hash hash table entries: 512 (order: 1, "
"8192 bytes, linear)\n"
"[    4.141016] Table-perturb hash table entries: 65536 (order: 6, 262144 "
"bytes, linear)\n"
"[    4.143752] TCP established hash table entries: 8192 (order: 4, 65536 "
"bytes, linear)\n"
"[    4.146811] TCP bind hash table entries: 8192 (order: 6, 262144 bytes, "
"linear)\n"
"[    4.149988] TCP: Hash tables configured (established 8192 bind 8192)\n"
"[    4.161535] UDP hash table entries: 512 (order: 2, 16384 bytes, linear)\n"
"[    4.164626] UDP-Lite hash table entries: 512 (order: 2, 16384 bytes, "
"linear)\n"
"[    4.174972] NET: Registered PF_UNIX/PF_LOCAL protocol family\n"
"[    4.199967] RPC: Registered named UNIX socket transport module.\n"
"[    4.201931] RPC: Registered udp transport module.\n"
"[    4.203097] RPC: Registered tcp transport module.\n"
"[    4.204199] RPC: Registered tcp-with-tls transport module.\n"
"[    4.205786] RPC: Registered tcp NFSv4.1 backchannel transport module.\n"
"[    4.207904] PCI: CLS 0 bytes, default 64\n"
"[    4.246417] kvm [1]: HYP mode not available\n"
"[    4.310161] Initialise system trusted keyrings\n"
"[    4.323677] workingset: timestamp_bits=42 max_order=18 bucket_order=0\n"
"[    4.346518] squashfs: version 4.0 (2009/01/31) Phillip Lougher\n"
"[    4.361970] NFS: Registering the id_resolver key type\n"
"[    4.366154] Key type id_resolver registered\n"
"[    4.367310] Key type id_legacy registered\n"
"[    4.370932] nfs4filelayout_init: NFSv4 File Layout Driver Registering...\n"
"[    4.372907] nfs4flexfilelayout_init: NFSv4 Flexfile Layout Driver "
"Registering...\n"
"[    4.380570] 9p: Installing v9fs 9p2000 file system support\n"
"[    4.996390] Key type asymmetric registered\n"
"[    4.998188] Asymmetric key parser 'x509' registered\n"
"[    5.001702] Block layer SCSI generic (bsg) driver version 0.4 loaded "
"(major 245)\n"
"[    5.004042] io scheduler mq-deadline registered\n"
"[    5.005987] io scheduler kyber registered\n"
"[    5.009909] io scheduler bfq registered\n"
"[    5.533535] pl061_gpio 9030000.pl061: PL061 GPIO chip registered\n"
"[    7.293859] Serial: 8250/16550 driver, 4 ports, IRQ sharing enabled\n"
"[    7.463278] msm_serial: driver initialized\n"
"[    7.483055] SuperH (H)SCI(F) driver initialized\n"
"[    7.494097] STM32 USART driver initialized\n"
"[    7.837823] loop: module loaded\n"
"[    7.845491] virtio_blk virtio1: 1/0/0 default/read/poll queues\n"
"[    7.881698] virtio_blk virtio1: [vda] 409600 512-byte logical blocks (210 "
"MB/200 MiB)\n"
"[    8.067674] megasas: 07.727.03.00-rc1\n"
"[    8.417069] tun: Universal TUN/TAP device driver, 1.6\n"
"[    8.530353] thunder_xcv, ver 1.0\n"
"[    8.532526] thunder_bgx, ver 1.0\n"
"[    8.534871] nicpf, ver 1.0\n"
"[    8.599326] hns3: Hisilicon Ethernet Network Driver for Hip08 Family - "
"version\n"
"[    8.600813] hns3: Copyright (c) 2017 Huawei Corporation.\n"
"[    8.604631] hclge is initializing\n"
"[    8.607113] e1000: Intel(R) PRO/1000 Network Driver\n"
"[    8.608211] e1000: Copyright (c) 1999-2006 Intel Corporation.\n"
"[    8.611096] e1000e: Intel(R) PRO/1000 Network Driver\n"
"[    8.612176] e1000e: Copyright(c) 1999 - 2015 Intel Corporation.\n"
"[    8.614814] igb: Intel(R) Gigabit Ethernet Network Driver\n"
"[    8.616017] igb: Copyright (c) 2007-2014 Intel Corporation.\n"
"[    8.618576] igbvf: Intel(R) Gigabit Virtual Function Network Driver\n"
"[    8.619876] igbvf: Copyright (c) 2009 - 2012 Intel Corporation.\n"
"[    8.637868] sky2: driver version 1.30\n"
"[    8.706118] VFIO - User Level meta-driver version: 0.3\n"
"[    8.871414] usbcore: registered new interface driver usb-storage\n"
"[    9.042230] rtc-pl031 9010000.pl031: registered as rtc0\n"
"[    9.048077] rtc-pl031 9010000.pl031: setting system clock to "
"2025-03-28T00:22:57 UTC (1743121377)\n"
"[    9.089588] i2c_dev: i2c /dev entries driver\n"
"[    9.482386] sdhci: Secure Digital Host Controller Interface driver\n"
"[    9.483722] sdhci: Copyright(c) Pierre Ossman\n"
"[    9.527371] Synopsys Designware Multimedia Card Interface Driver\n"
"[    9.581108] sdhci-pltfm: SDHCI platform and OF driver helper\n"
"[    9.693508] ledtrig-cpu: registered to indicate activity on CPUs\n"
"[    9.786376] usbcore: registered new interface driver usbhid\n"
"[    9.787707] usbhid: USB HID core driver\n"
"[    9.987141] hw perfevents: enabled with armv8_pmuv3 PMU driver, 7 "
"counters available\n"
"[   10.250455] NET: Registered PF_PACKET protocol family\n"
"[   10.263124] 9pnet: Installing 9P2000 support\n"
"[   10.266705] Key type dns_resolver registered\n"
"[   10.912946] registered taskstats version 1\n"
"[   10.946074] Loading compiled-in X.509 certificates\n"
"[   11.433115] input: gpio-keys as /devices/platform/gpio-keys/input/input0\n"
"[   11.482267] clk: Disabling unused clocks\n"
"[   11.485549] PM: genpd: Disabling unused power domains\n"
"[   11.488619] ALSA device list:\n"
"[   11.490399]   No soundcards found.\n"
"[   11.791974] EXT4-fs (vda): mounted filesystem a30d5de0-4011-48c0-9e48-"
"a4556726e425 r/w with ordered data mode. Quota mode: none.\n"
"[   11.797909] VFS: Mounted root (ext4 filesystem) on device 254:0.\n"
"[   11.815481] devtmpfs: mounted\n"
"[   12.252692] Freeing unused kernel memory: 9920K\n"
"[   12.262413] Run /sbin/init as init process\n"
"[   12.331806] Run /etc/init as init process\n"
"[   12.336529] Run /bin/init as init process\n"
"[   12.355530] Run /bin/sh as init process\n"
"/bin/sh: 0: can't access tty; job control turned off\n"
"# \n"
"```"

#: src/quickstart/qemu/qemu_aarch64.md:891 src/quickstart/aarch64_a1000.md:13
#: src/quickstart/aarch64_rk3588.md:172
msgid "ArceOS + Linux"
msgstr "ArceOS + Linux"

#: src/quickstart/qemu/qemu_aarch64.md:893
msgid ""
"首先，根据以上两个章节的介绍分别制作 `helloworld_aarch64-qemu-virt.bin`、"
"`Image` 及 `linux-qemu.dtb` 镜像文件"
msgstr ""
"首先，根据以上两个章节的介绍分别制作 `helloworld_aarch64-qemu-virt.bin`、"
"`Image` 及 `linux-qemu.dtb` 镜像文件"

#: src/quickstart/qemu/qemu_aarch64.md:908
#: src/quickstart/qemu/qemu_aarch64.md:928
msgid ""
"修改对应的 `./configs/vms/linux-qemu-aarch64.toml` 和 `arceos-aarch64.toml` "
"中的配置项"
msgstr ""
"修改对应的 `./configs/vms/linux-qemu-aarch64.toml` 和 `arceos-aarch64.toml` "
"中的配置项"

#: src/quickstart/qemu/qemu_aarch64.md:915
#: src/quickstart/qemu/qemu_aarch64.md:935
msgid ""
"执行 `make ARCH=aarch64 VM_CONFIGS=configs/vms/arceos-aarch64.toml:configs/"
"vms/linux-qemu-aarch64-vm2.toml LOG=info BUS=mmio NET=y FEATURES=page-"
"alloc-64g MEM=8g SECOND_SERIAL=y SMP=2 run` 构建 AxVisor，并在 QEMU 中启动。"
"此时，终端将阻等待 Telnet 命令"
msgstr ""
"执行 `make ARCH=aarch64 VM_CONFIGS=configs/vms/arceos-aarch64.toml:configs/"
"vms/linux-qemu-aarch64-vm2.toml LOG=info BUS=mmio NET=y FEATURES=page-"
"alloc-64g MEM=8g SECOND_SERIAL=y SMP=2 run` 构建 AxVisor，并在 QEMU 中启动。"
"此时，终端将阻等待 Telnet 命令"

#: src/quickstart/qemu/qemu_aarch64.md:922
#: src/quickstart/qemu/qemu_aarch64.md:942
msgid ""
"启动另一个终端，然后执行 `telnet localhost 4321`，上一个终端将继续运行，并输"
"出第一个虚拟机启动信息，第二个虚拟机启动信息将在当前终端输出。"
msgstr ""
"启动另一个终端，然后执行 `telnet localhost 4321`，上一个终端将继续运行，并输"
"出第一个虚拟机启动信息，第二个虚拟机启动信息将在当前终端输出。"

#: src/quickstart/qemu/qemu_aarch64.md:946
msgid "注意事项"
msgstr "注意事项"

#: src/quickstart/qemu/qemu_aarch64.md:948
msgid ""
"在同时启动 ArceOS 和 Linux 客户机时，若启动 axvisor 后只有一个 vm 有输出，另"
"一个无显示，可能是 qemu 配置选项不全，需查看当前 qemu 版本，建议使用 9.2.2 版"
"本，安装过程如下"
msgstr ""
"在同时启动 ArceOS 和 Linux 客户机时，若启动 axvisor 后只有一个 vm 有输出，另"
"一个无显示，可能是 qemu 配置选项不全，需查看当前 qemu 版本，建议使用 9.2.2 版"
"本，安装过程如下"

#: src/quickstart/qemu/qemu_aarch64.md:950
msgid ""
"```plain\n"
"# 安装编译所需的依赖包\n"
"sudo apt install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev "
"libgmp-dev \\\n"
"              gawk build-essential bison flex texinfo gperf libtool "
"patchutils bc \\\n"
"              zlib1g-dev libexpat-dev pkg-config  libglib2.0-dev libpixman-1-"
"dev libsdl2-dev \\\n"
"              git tmux python3 python3-pip ninja-build\n"
"# 下载源码\n"
"wget https://download.qemu.org/qemu-9.2.2.tar.xz\n"
"# 解压\n"
"tar xvJf qemu-9.2.2.tar.xz\n"
"cd qemu-9.2.2\n"
"#生成设置文件\n"
"./configure --enable-kvm --enable-slirp --enable-debug --target-list=aarch64-"
"softmmu,x86_64-softmmu\n"
"#编译\n"
"make -j$(nproc)\n"
"```"
msgstr ""
"```plain\n"
"# 安装编译所需的依赖包\n"
"sudo apt install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev "
"libgmp-dev \\\n"
"              gawk build-essential bison flex texinfo gperf libtool "
"patchutils bc \\\n"
"              zlib1g-dev libexpat-dev pkg-config  libglib2.0-dev libpixman-1-"
"dev libsdl2-dev \\\n"
"              git tmux python3 python3-pip ninja-build\n"
"# 下载源码\n"
"wget https://download.qemu.org/qemu-9.2.2.tar.xz\n"
"# 解压\n"
"tar xvJf qemu-9.2.2.tar.xz\n"
"cd qemu-9.2.2\n"
"#生成设置文件\n"
"./configure --enable-kvm --enable-slirp --enable-debug --target-list=aarch64-"
"softmmu,x86_64-softmmu\n"
"#编译\n"
"make -j$(nproc)\n"
"```"

#: src/quickstart/qemu/qemu_aarch64.md:967
msgid "之后编辑 `~/.bashrc` 文件，在文件的末尾加入几行："
msgstr "之后编辑 `~/.bashrc` 文件，在文件的末尾加入几行："

#: src/quickstart/qemu/qemu_aarch64.md:973
msgid "最后，执行 `source ~/.bashrc` 更新当前 shell 即可"
msgstr "最后，执行 `source ~/.bashrc` 更新当前 shell 即可"

#: src/quickstart/qemu/qemu_aarch64.md:976
msgid "已知问题"
msgstr "已知问题"

#: src/quickstart/qemu/qemu_aarch64.md:978
msgid "ArceOS 从内存中加载启动时，如果没有 disk.img 将报错"
msgstr "ArceOS 从内存中加载启动时，如果没有 disk.img 将报错"

#: src/quickstart/qemu/qemu_aarch64.md:979
msgid "Linux 无法从文件系统加载启动"
msgstr "Linux 无法从文件系统加载启动"

#: src/quickstart/qemu/qemu_aarch64.md:980
msgid ""
"多客户机，例如 ArceOS + Linux，如果其中一个虚拟机结束，将无法正常启动第二个虚"
"拟机"
msgstr ""
"多客户机，例如 ArceOS + Linux，如果其中一个虚拟机结束，将无法正常启动第二个虚"
"拟机"

#: src/quickstart/qemu/qemu_x86_64.md:1
msgid "Run AxVisor on QEMU x86_64"
msgstr "Run AxVisor on QEMU x86_64"

#: src/quickstart/qemu/qemu_x86_64.md:3
msgid ""
"目前，在 qemu-system-x86_64 平台上已经对独立运行 ArceOS, Nimbos 以及 Starry "
"进行验证。"
msgstr ""
"目前，在 qemu-system-x86_64 平台上已经对独立运行 ArceOS, Nimbos 以及 Starry "
"进行验证。"

#: src/quickstart/qemu/qemu_x86_64.md:5
msgid "axvm-bios"
msgstr "axvm-bios"

#: src/quickstart/qemu/qemu_x86_64.md:7
msgid ""
"[axvm-bios](https://github.com/arceos-hypervisor/axvm-bios-x86) 是针对 "
"x86_64 用户虚拟机的一个极简BIOS实现。"
msgstr ""
"[axvm-bios](https://github.com/arceos-hypervisor/axvm-bios-x86) 是针对 "
"x86_64 用户虚拟机的一个极简BIOS实现。"

#: src/quickstart/qemu/qemu_x86_64.md:9
msgid ""
"它可以承担引导 NimbOS 以及 ArceOS 启动的任务，二进制文件[链接](https://"
"github.com/arceos-hypervisor/axvm-bios-x86/releases/download/v0.1/axvm-bios."
"bin)."
msgstr ""
"它可以承担引导 NimbOS 以及 ArceOS 启动的任务，二进制文件[链接](https://"
"github.com/arceos-hypervisor/axvm-bios-x86/releases/download/v0.1/axvm-bios."
"bin)."

#: src/quickstart/qemu/qemu_x86_64.md:11
msgid "Guest VM configuration"
msgstr "Guest VM configuration"

#: src/quickstart/qemu/qemu_x86_64.md:13
msgid ""
"需要修改 guest VM 的配置文件 `xxx-x86_64.toml` 中的 `bios_path` 以及 "
"`bios_load_addr` 域，可参考 [arceos-x86_64.toml](https://github.com/arceos-"
"hypervisor/axvisor/blob/master/configs/vms/arceos-x86_64.toml)。"
msgstr ""
"需要修改 guest VM 的配置文件 `xxx-x86_64.toml` 中的 `bios_path` 以及 "
"`bios_load_addr` 域，可参考 [arceos-x86_64.toml](https://github.com/arceos-"
"hypervisor/axvisor/blob/master/configs/vms/arceos-x86_64.toml)。"

#: src/quickstart/qemu/qemu_x86_64.md:15
msgid ""
"```toml\n"
"#\n"
"# Vm kernel configs\n"
"#\n"
"[kernel]\n"
"# ...\n"
"# The file path of the BIOS image.\n"
"bios_path = \"axvm-bios.bin\"\n"
"# The load address of the BIOS image.\n"
"bios_load_addr = 0x8000\n"
"```"
msgstr ""
"```toml\n"
"#\n"
"# Vm kernel configs\n"
"#\n"
"[kernel]\n"
"# ...\n"
"# The file path of the BIOS image.\n"
"bios_path = \"axvm-bios.bin\"\n"
"# The load address of the BIOS image.\n"
"bios_load_addr = 0x8000\n"
"```"

#: src/quickstart/qemu/qemu_x86_64.md:27
msgid "QEMU arguments"
msgstr "QEMU arguments"

#: src/quickstart/qemu/qemu_x86_64.md:29
msgid ""
"目前 qemu-system-x86_64 平台提供的 virt CPU 实现不支持 VMX feature，需要在启"
"动时开启 `-enable-kvm` 参数（Makefile 定义的环境变量为 `ACCEL=y`）。"
msgstr ""
"目前 qemu-system-x86_64 平台提供的 virt CPU 实现不支持 VMX feature，需要在启"
"动时开启 `-enable-kvm` 参数（Makefile 定义的环境变量为 `ACCEL=y`）。"

#: src/quickstart/qemu/qemu_x86_64.md:31
msgid "参考运行命令："
msgstr "参考运行命令："

#: src/quickstart/qemu/qemu_riscv64.md:1
msgid "Run AxVisor on QEMU riscv64"
msgstr "Run AxVisor on QEMU riscv64"

#: src/quickstart/qemu/qemu_riscv64.md:3
msgid ""
"参考 [QEMU-aarch64](./quickstart/qemu/qemu_aarch64.md) 的内容。<style> ."
"scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: "
"none; align-items: center; justify-content: center; position: fixed; "
"padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-"
"padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); "
"background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden "
"{ display: none; } .scroll-to-top i { transform: translateY(-2px); } @media "
"(min-width: 1080px) { .scroll-to-top { display: flex; } } </style> <button "
"type=\"button\" aria-label=\"scroll-to-top\" class=\"scroll-to-top hidden\" "
"onclick=\"scrollToTop()\"> <i class=\"fa fa-angle-up\"></i> </button>"
msgstr ""
"参考 [QEMU-aarch64](./quickstart/qemu/qemu_aarch64.md) 的内容。<style> ."
"scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: "
"none; align-items: center; justify-content: center; position: fixed; "
"padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-"
"padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); "
"background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden "
"{ display: none; } .scroll-to-top i { transform: translateY(-2px); } @media "
"(min-width: 1080px) { .scroll-to-top { display: flex; } } </style> <button "
"type=\"button\" aria-label=\"scroll-to-top\" class=\"scroll-to-top hidden\" "
"onclick=\"scrollToTop()\"> <i class=\"fa fa-angle-up\"></i> </button>"

#: src/quickstart/aarch64_a1000.md:3
msgid ""
"目前，在黑芝麻 A1000 平台上已经对同时运行 ArceOS + Linux 的情况进行了验证。"
msgstr ""
"目前，在黑芝麻 A1000 平台上已经对同时运行 ArceOS + Linux 的情况进行了验证。"

#: src/quickstart/aarch64_a1000.md:7 src/quickstart/aarch64_a1000.md:11
#: src/quickstart/aarch64_rk3588.md:7
msgid "TODO"
msgstr "TODO"

#: src/quickstart/aarch64_a1000.md:15
msgid "镜像准备"
msgstr "镜像准备"

#: src/quickstart/aarch64_a1000.md:17
msgid "编译一个适合黑芝麻a1000平台的linux镜像，以及对应的dtb文件"
msgstr "编译一个适合黑芝麻a1000平台的linux镜像，以及对应的dtb文件"

#: src/quickstart/aarch64_a1000.md:18
msgid "编译一个只使用串口设备的arceos hello_world"
msgstr "编译一个只使用串口设备的arceos hello_world"

#: src/quickstart/aarch64_a1000.md:19
msgid "在qemu使用的配置信息上进行修改即可"
msgstr "在qemu使用的配置信息上进行修改即可"

#: src/quickstart/aarch64_a1000.md:20
msgid "将串口更改为使用uart8250，将相应的串口地址进行改动"
msgstr "将串口更改为使用uart8250，将相应的串口地址进行改动"

#: src/quickstart/aarch64_a1000.md:21
msgid "将起始地址和内存信息配置为guest arceos toml中使用的对应内存"
msgstr "将起始地址和内存信息配置为guest arceos toml中使用的对应内存"

#: src/quickstart/aarch64_a1000.md:22
msgid ""
"配合guest arceos toml中使用的内存，在`mem.rs`文件中增加对应的一级页表信息，使"
"arceos能够使用相应的内存"
msgstr ""
"配合guest arceos toml中使用的内存，在`mem.rs`文件中增加对应的一级页表信息，使"
"arceos能够使用相应的内存"

#: src/quickstart/aarch64_a1000.md:24
msgid ""
"修改目前的`build.rs` 、`image.rs` 、`config.rs`文件，使其支持两个os从内存中加"
"载（目前实现方式比较暴力）"
msgstr ""
"修改目前的`build.rs` 、`image.rs` 、`config.rs`文件，使其支持两个os从内存中加"
"载（目前实现方式比较暴力）"

#: src/quickstart/aarch64_a1000.md:26
msgid ""
"配置`arceos-umhv/arceos-vmm/configs/platforms/aarch64-bsta1000b-virt-hv.toml`"
"文件"
msgstr ""
"配置`arceos-umhv/arceos-vmm/configs/platforms/aarch64-bsta1000b-virt-hv.toml`"
"文件"

#: src/quickstart/aarch64_a1000.md:28
msgid ""
"```toml\n"
"# Architecture identifier.\n"
"arch = \"aarch64\"                    # str    //host 架构\n"
"# Platform identifier.\n"
"platform = \"aarch64-bsta1000b-hv\"   # str    //host 平台\n"
"\n"
"#\n"
"# Platform configs\n"
"#\n"
"[plat]\n"
"# Platform family.\n"
"family = \"aarch64-bsta1000b\"        # str\n"
"\n"
"# Base address of the whole physical memory.\n"
"phys-memory-base = 0x1_9800_0000   //host物理内存起始地址\n"
"# Size of the whole physical memory.\n"
"phys-memory-size = 0x1800_0000    //host自身占用的物理内存大小\n"
"# Base physical address of the kernel image.\n"
"kernel-base-paddr = 0x1_a000_0000  //host内核起始物理地址\n"
"# Base virtual address of the kernel image.\n"
"kernel-base-vaddr = \"0x0000_0001_a000_0000\"   //host内核起始虚拟地址\n"
"# Linear mapping offset, for quick conversions between physical and virtual\n"
"# addresses.\n"
"phys-virt-offset = \"0x0000_0000_0000_0000\"\n"
"# Offset of bus address and phys address. some boards, the bus address is\n"
"# different from the physical address.\n"
"phys-bus-offset = 0\n"
"# Kernel address space base.\n"
"kernel-aspace-base = \"0x0000_0000_0000_0000\"\n"
"# Kernel address space size.\n"
"kernel-aspace-size = \"0x0000_ffff_ffff_f000\"\n"
"\n"
"#\n"
"# Device specifications\n"
"#\n"
"[devices]\n"
"# MMIO regions with format (`base_paddr`, `size`).\n"
"//host 使用的物理设备\n"
"mmio-regions = [\n"
"    [0x20008000, 0x1000], # uart8250 UART0\n"
"    [0x32000000, 0x8000], # arm,gic-400\n"
"    [0x32011000, 0x1000], # CPU CSR\n"
"    [0x33002000, 0x1000], # Top CRM\n"
"    [0x70035000, 0x1000], # CRM reg\n"
"    [0x70038000, 0x1000], # aon pinmux\n"
"] # [(uint, uint)]\n"
"# VirtIO MMIO regions with format (`base_paddr`, `size`).\n"
"virtio-mmio-regions = []    # [(uint, uint)]\n"
"\n"
"# Base physical address of the PCIe ECAM space.\n"
"pci-ecam-base = 0x30E0_2000\n"
"\n"
"# UART Address\n"
"uart-paddr = 0x2000_8000        # uint\n"
"# UART IRQ number\n"
"uart-irq = 0xd5                 # uint\n"
"\n"
"# GIC CPU Interface base address\n"
"gicc-paddr = 0x3200_2000        # uint\n"
"# GIC Distributor base address\n"
"gicd-paddr = 0x3200_1000        # uint\n"
"\n"
"# BST A1000B board registers\n"
"cpu-csr-base = 0x3201_1000          # uint\n"
"a1000base-topcrm = 0x3300_2000      # uint\n"
"a1000base-safetycrm = 0x7003_5000   # uint\n"
"a1000base-aoncfg = 0x7003_8000      # uint\n"
"\n"
"# PSCI\n"
"psci-method = \"smc\"     # str\n"
"\n"
"# RTC (PL031) Address (Need to read from DTB).\n"
"rtc-paddr = 0x0         # uint\n"
"\n"
"```"
msgstr ""
"```toml\n"
"# Architecture identifier.\n"
"arch = \"aarch64\"                    # str    //host 架构\n"
"# Platform identifier.\n"
"platform = \"aarch64-bsta1000b-hv\"   # str    //host 平台\n"
"\n"
"#\n"
"# Platform configs\n"
"#\n"
"[plat]\n"
"# Platform family.\n"
"family = \"aarch64-bsta1000b\"        # str\n"
"\n"
"# Base address of the whole physical memory.\n"
"phys-memory-base = 0x1_9800_0000   //host物理内存起始地址\n"
"# Size of the whole physical memory.\n"
"phys-memory-size = 0x1800_0000    //host自身占用的物理内存大小\n"
"# Base physical address of the kernel image.\n"
"kernel-base-paddr = 0x1_a000_0000  //host内核起始物理地址\n"
"# Base virtual address of the kernel image.\n"
"kernel-base-vaddr = \"0x0000_0001_a000_0000\"   //host内核起始虚拟地址\n"
"# Linear mapping offset, for quick conversions between physical and virtual\n"
"# addresses.\n"
"phys-virt-offset = \"0x0000_0000_0000_0000\"\n"
"# Offset of bus address and phys address. some boards, the bus address is\n"
"# different from the physical address.\n"
"phys-bus-offset = 0\n"
"# Kernel address space base.\n"
"kernel-aspace-base = \"0x0000_0000_0000_0000\"\n"
"# Kernel address space size.\n"
"kernel-aspace-size = \"0x0000_ffff_ffff_f000\"\n"
"\n"
"#\n"
"# Device specifications\n"
"#\n"
"[devices]\n"
"# MMIO regions with format (`base_paddr`, `size`).\n"
"//host 使用的物理设备\n"
"mmio-regions = [\n"
"    [0x20008000, 0x1000], # uart8250 UART0\n"
"    [0x32000000, 0x8000], # arm,gic-400\n"
"    [0x32011000, 0x1000], # CPU CSR\n"
"    [0x33002000, 0x1000], # Top CRM\n"
"    [0x70035000, 0x1000], # CRM reg\n"
"    [0x70038000, 0x1000], # aon pinmux\n"
"] # [(uint, uint)]\n"
"# VirtIO MMIO regions with format (`base_paddr`, `size`).\n"
"virtio-mmio-regions = []    # [(uint, uint)]\n"
"\n"
"# Base physical address of the PCIe ECAM space.\n"
"pci-ecam-base = 0x30E0_2000\n"
"\n"
"# UART Address\n"
"uart-paddr = 0x2000_8000        # uint\n"
"# UART IRQ number\n"
"uart-irq = 0xd5                 # uint\n"
"\n"
"# GIC CPU Interface base address\n"
"gicc-paddr = 0x3200_2000        # uint\n"
"# GIC Distributor base address\n"
"gicd-paddr = 0x3200_1000        # uint\n"
"\n"
"# BST A1000B board registers\n"
"cpu-csr-base = 0x3201_1000          # uint\n"
"a1000base-topcrm = 0x3300_2000      # uint\n"
"a1000base-safetycrm = 0x7003_5000   # uint\n"
"a1000base-aoncfg = 0x7003_8000      # uint\n"
"\n"
"# PSCI\n"
"psci-method = \"smc\"     # str\n"
"\n"
"# RTC (PL031) Address (Need to read from DTB).\n"
"rtc-paddr = 0x0         # uint\n"
"\n"
"```"

#: src/quickstart/aarch64_a1000.md:104
msgid "配置两个guest的相关信息"
msgstr "配置两个guest的相关信息"

#: src/quickstart/aarch64_a1000.md:106
msgid ""
"配置`arceos-umhv/arceos-vmm/configs/vms/linux-a1000-aarch64-smp1.toml`文件，"
"配置guest linux的初始信息"
msgstr ""
"配置`arceos-umhv/arceos-vmm/configs/vms/linux-a1000-aarch64-smp1.toml`文件，"
"配置guest linux的初始信息"

#: src/quickstart/aarch64_a1000.md:108
msgid ""
"```toml\n"
"id = 0                 //guest vm id\n"
"name = \"linux-a1000\"   //gueest vm name\n"
"vm_type = 1     \n"
"cpu_num = 1           //分配的vcpu数量\n"
"phys_cpu_ids = [0x00]   \n"
"phys_cpu_sets = [0x02]   // vcpu绑定在2核\n"
"entry_point = 0x8100_0000  //linux内核起始地址\n"
"kernel_load_addr = 0x8100_0000  //guest linux vm 镜像加载地址\n"
"dtb_load_addr = 0x82e0_0000     //guest linux dtb 加载地址\n"
"\n"
"image_location = \"memory\"      //加载方式为从内存加载\n"
"kernel_path = \"/mnt/cicv/xh/arceos-hypervisor/a1000_port/image/Image_6.1.54."
"bin\" //guest linux 镜像 所在路径\n"
"dtb_path = \"/mnt/cicv/xh/arceos-hypervisor/a1000_port/dts_dtb/bsta1000b-"
"fada-chery-smp1.dtb\" //guest linux dtb 所在路径\n"
"# ramdisk_path = \"\"\n"
"# ramdisk_load_addr = 0\n"
"# disk_path = \"disk.img\"\n"
"# Memory regions with format (`base_paddr`, `size`, `flags`).\n"
"//guest linux 所使用的物理内存\n"
"memory_regions = [\n"
"    [0x8000_0000, 0x7000_0000, 0x7, 1],#ram 1792MB\n"
"]\n"
"\n"
"\n"
"# Emu_devices\n"
"# Name Base-Ipa Ipa_len Alloc-Irq Emu-Type EmuConfig\n"
"emu_devices = [\n"
"]\n"
"\n"
"# Pass-through devices\n"
"//guest linux 所控制的直通设备\n"
"passthrough_devices = [\n"
"\t[\"most-devices\", 0x0000_0000, 0x0000_0000, 0x8000_0000, 0x1],\n"
"]\n"
"\n"
"```"
msgstr ""
"```toml\n"
"id = 0                 //guest vm id\n"
"name = \"linux-a1000\"   //gueest vm name\n"
"vm_type = 1     \n"
"cpu_num = 1           //分配的vcpu数量\n"
"phys_cpu_ids = [0x00]   \n"
"phys_cpu_sets = [0x02]   // vcpu绑定在2核\n"
"entry_point = 0x8100_0000  //linux内核起始地址\n"
"kernel_load_addr = 0x8100_0000  //guest linux vm 镜像加载地址\n"
"dtb_load_addr = 0x82e0_0000     //guest linux dtb 加载地址\n"
"\n"
"image_location = \"memory\"      //加载方式为从内存加载\n"
"kernel_path = \"/mnt/cicv/xh/arceos-hypervisor/a1000_port/image/Image_6.1.54."
"bin\" //guest linux 镜像 所在路径\n"
"dtb_path = \"/mnt/cicv/xh/arceos-hypervisor/a1000_port/dts_dtb/bsta1000b-"
"fada-chery-smp1.dtb\" //guest linux dtb 所在路径\n"
"# ramdisk_path = \"\"\n"
"# ramdisk_load_addr = 0\n"
"# disk_path = \"disk.img\"\n"
"# Memory regions with format (`base_paddr`, `size`, `flags`).\n"
"//guest linux 所使用的物理内存\n"
"memory_regions = [\n"
"    [0x8000_0000, 0x7000_0000, 0x7, 1],#ram 1792MB\n"
"]\n"
"\n"
"\n"
"# Emu_devices\n"
"# Name Base-Ipa Ipa_len Alloc-Irq Emu-Type EmuConfig\n"
"emu_devices = [\n"
"]\n"
"\n"
"# Pass-through devices\n"
"//guest linux 所控制的直通设备\n"
"passthrough_devices = [\n"
"\t[\"most-devices\", 0x0000_0000, 0x0000_0000, 0x8000_0000, 0x1],\n"
"]\n"
"\n"
"```"

#: src/quickstart/aarch64_a1000.md:145
msgid ""
"配置`arceos-umhv/arceos-vmm/configs/vms/arceos-aarch64-hv.toml`文件，配置"
"guest arceos 初始信息"
msgstr ""
"配置`arceos-umhv/arceos-vmm/configs/vms/arceos-aarch64-hv.toml`文件，配置"
"guest arceos 初始信息"

#: src/quickstart/aarch64_a1000.md:147
msgid ""
"```toml\n"
"id = 1          //guest vm id\n"
"name = \"arceos\"    //guest vm name\n"
"vm_type = 1          // guest vm type\n"
"cpu_num = 1          // guest vcpu num\n"
"phys_cpu_sets = [1]  //将guest vcpu与1核进行绑定\n"
"# entry_point = 0x1_b008_0000\n"
"entry_point = 0x1_b000_0000  //guest arceos 内核启动地址\n"
"\n"
"# The location of image: \"memory\" | \"fs\"\n"
"# image_location = \"fs\" \n"
"image_location = \"memory\"    //guest arceos 加载方式为从内存中加载\n"
"# kernel_path = \"/mnt/cicv/xh/arceos/examples/helloworld/helloworld_aarch64-"
"bsta1000b.bin\"\n"
"kernel_path = \"/mnt/cicv/xh/arceos/examples/helloworld/helloworld_aarch64-"
"qemu-virt.bin\"   //guest arceos kernel 镜像地址\n"
"# /mnt/cicv/xh/arceos/examples/helloworld/helloworld_aarch64-qemu-virt.bin\n"
"kernel_load_addr = 0x1_b000_0000 //guest arceos 内核加载地址\n"
"\n"
"# bios_path = \"\"\n"
"# bios_load_addr = 0\n"
"# ramdisk_path = \"\"\n"
"# ramdisk_load_addr = 0\n"
"# disk_path = \"\"\n"
"# Memory regions with format (`base_paddr`, `size`, `flags`, `map_type`).\n"
"# For `map_type`, 0 means `MAP_ALLOC`, 1 means `MAP_IDENTICAL`.\n"
"//guest arceos 使用的内存信息\n"
"memory_regions = [\n"
"    # [0x8000_0000, 0x0800_0000, 0x7, 1],   # Low RAM\t\t    16M 0b00111 R|W|"
"EXECUTE\n"
"    [0x1_b000_0000, 0x0800_0000, 0x7, 1]\n"
"]\n"
"\n"
"# Emu_devices\n"
"# Name Base-Ipa Ipa_len Alloc-Irq Emu-Type EmuConfig\n"
"emu_devices = []\n"
"\n"
"# Pass-through devices\n"
"# Name Base-Ipa Base-Pa Length Alloc-Irq\n"
"passthrough_devices = [\n"
"\n"
"\n"
"    [\"uart8250\", 0x20008000, 0x20008000, 0x1000, 0x01],   # uart8250 "
"UART0\n"
"\n"
"]\n"
"```"
msgstr ""
"```toml\n"
"id = 1          //guest vm id\n"
"name = \"arceos\"    //guest vm name\n"
"vm_type = 1          // guest vm type\n"
"cpu_num = 1          // guest vcpu num\n"
"phys_cpu_sets = [1]  //将guest vcpu与1核进行绑定\n"
"# entry_point = 0x1_b008_0000\n"
"entry_point = 0x1_b000_0000  //guest arceos 内核启动地址\n"
"\n"
"# The location of image: \"memory\" | \"fs\"\n"
"# image_location = \"fs\" \n"
"image_location = \"memory\"    //guest arceos 加载方式为从内存中加载\n"
"# kernel_path = \"/mnt/cicv/xh/arceos/examples/helloworld/helloworld_aarch64-"
"bsta1000b.bin\"\n"
"kernel_path = \"/mnt/cicv/xh/arceos/examples/helloworld/helloworld_aarch64-"
"qemu-virt.bin\"   //guest arceos kernel 镜像地址\n"
"# /mnt/cicv/xh/arceos/examples/helloworld/helloworld_aarch64-qemu-virt.bin\n"
"kernel_load_addr = 0x1_b000_0000 //guest arceos 内核加载地址\n"
"\n"
"# bios_path = \"\"\n"
"# bios_load_addr = 0\n"
"# ramdisk_path = \"\"\n"
"# ramdisk_load_addr = 0\n"
"# disk_path = \"\"\n"
"# Memory regions with format (`base_paddr`, `size`, `flags`, `map_type`).\n"
"# For `map_type`, 0 means `MAP_ALLOC`, 1 means `MAP_IDENTICAL`.\n"
"//guest arceos 使用的内存信息\n"
"memory_regions = [\n"
"    # [0x8000_0000, 0x0800_0000, 0x7, 1],   # Low RAM\t\t    16M 0b00111 R|W|"
"EXECUTE\n"
"    [0x1_b000_0000, 0x0800_0000, 0x7, 1]\n"
"]\n"
"\n"
"# Emu_devices\n"
"# Name Base-Ipa Ipa_len Alloc-Irq Emu-Type EmuConfig\n"
"emu_devices = []\n"
"\n"
"# Pass-through devices\n"
"# Name Base-Ipa Base-Pa Length Alloc-Irq\n"
"passthrough_devices = [\n"
"\n"
"\n"
"    [\"uart8250\", 0x20008000, 0x20008000, 0x1000, 0x01],   # uart8250 "
"UART0\n"
"\n"
"]\n"
"```"

#: src/quickstart/aarch64_a1000.md:193
msgid ""
"使用`make A=(pwd) ARCH=aarch64 VM_CONFIGS=configs/vms/linux-a1000-aarch64-"
"smp1.toml:configs/vms/arceos-aarch64.toml PLAT_NAME=aarch64-bsta1000b-virt-"
"hv FEATURES=page-alloc-64g,hv LOG=info SMP=2 fada` 编译出镜像"
msgstr ""
"使用`make A=(pwd) ARCH=aarch64 VM_CONFIGS=configs/vms/linux-a1000-aarch64-"
"smp1.toml:configs/vms/arceos-aarch64.toml PLAT_NAME=aarch64-bsta1000b-virt-"
"hv FEATURES=page-alloc-64g,hv LOG=info SMP=2 fada` 编译出镜像"

#: src/quickstart/aarch64_a1000.md:195
msgid "将镜像替换原有的内核，断电重启"
msgstr "将镜像替换原有的内核，断电重启"

#: src/quickstart/aarch64_a1000.md:197
msgid ""
"```shell\n"
"baudrate: 115200\n"
"\n"
"Load ATF and UBOOT from Zone A\n"
"\n"
"NOTICE:  BL31: Built : 10:13:03, Mar 30 2023\n"
"\n"
"\n"
"U-Boot 2019.04+2.1.1+g8fc26249.202303300858+ (Mar 30 2023 - 08:58:21 "
"+0800)Bst A1000B, Build: jenkins-a1000_uboot_hvte_rootfs_all-4984\n"
"\n"
"Press 'ctrl+C/c' to stop autoboot:  0\n"
"7020 bytes read in 5 ms (1.3 MiB/s)\n"
"normal mode\n"
"8204856 bytes read in 186 ms (42.1 MiB/s)\n"
"62598 bytes read in 12 ms (5 MiB/s)\n"
"## Loading kernel from FIT Image at 90000000 ...\n"
"   Trying 'kernel' kernel subimage\n"
"     Description:  ArceOS for BST A1000B\n"
"     Type:         Kernel Image\n"
"     Compression:  gzip compressed\n"
"     Data Start:   0x900000fc\n"
"     Data Size:    8143392 Bytes = 7.8 MiB\n"
"     Architecture: AArch64\n"
"     OS:           Linux\n"
"     Load Address: 0x1a0000000\n"
"     Entry Point:  0x1a0000000\n"
"     Hash algo:    md5\n"
"     Hash value:   de3de880d16c71162738fe3a09493347\n"
"     Hash algo:    sha1\n"
"     Hash value:   b1201ff1b8418e5e2f1f27cf2f3daf0275f9a605\n"
"   Verifying Hash Integrity ... md5+ sha1+ OK\n"
"## Flattened Device Tree blob at 80000000\n"
"   Booting using the fdt blob at 0x80000000\n"
"   Uncompressing Kernel Image ... load_buf:00000001a0000000,  "
"image_buf:00000000900000fc\n"
"image_len:7c4220 comp:1\n"
"OK\n"
"   Loading Device Tree to 00000001ce7ed000, end 00000001ce7ff485 ... OK\n"
"enable hyp val 30\n"
"\n"
"Starting kernel ...\n"
"\n"
"\n"
"       d8888                            .d88888b.   .d8888b.\n"
"      d88888                           d88P\" \"Y88b d88P  Y88b\n"
"     d88P888                           888     888 Y88b.\n"
"    d88P 888 888d888  .d8888b  .d88b.  888     888  \"Y888b.\n"
"   d88P  888 888P\"   d88P\"    d8P  Y8b 888     888     \"Y88b.\n"
"  d88P   888 888     888      88888888 888     888       \"888\n"
" d8888888888 888     Y88b.    Y8b.     Y88b. .d88P Y88b  d88P\n"
"d88P     888 888      \"Y8888P  \"Y8888   \"Y88888P\"   \"Y8888P\"\n"
"\n"
"arch = aarch64\n"
"platform = aarch64-bsta1000b-virt-hv\n"
"target = aarch64-unknown-none-softfloat\n"
"build_mode = release\n"
"log_level = info\n"
"smp = 2\n"
"\n"
"[  3.041875 axruntime:130] Logging is enabled.\n"
"[  3.047985 axruntime:131] Primary CPU 0 started, dtb = 0x1ce7ed000.\n"
"[  3.056196 axruntime:133] Found physcial memory regions:\n"
"[  3.063360 axruntime:135]   [PA:0x1a0000000, PA:0x1a0062000) .text (READ | "
"EXECUTE | RESERVED)\n"
"[  3.074146 axruntime:135]   [PA:0x1a0062000, PA:0x1a1901000) .rodata (READ "
"| RESERVED)\n"
"[  3.084172 axruntime:135]   [PA:0x1a1901000, PA:0x1a1909000) .data .tdata ."
"tbss .percpu (READ | WRITE | RESERVED)\n"
"[  3.096775 axruntime:135]   [PA:0x1a1909000, PA:0x1a1989000) boot stack "
"(READ | WRITE | RESERVED)\n"
"[  3.107851 axruntime:135]   [PA:0x1a1989000, PA:0x1a1baf000) .bss (READ | "
"WRITE | RESERVED)\n"
"[  3.118354 axruntime:135]   [PA:0x1a1baf000, PA:0x1b0000000) free memory "
"(READ | WRITE | FREE)\n"
"[  3.129143 axruntime:135]   [PA:0x80000000, PA:0xf0000000) reserved memory "
"(READ | WRITE | EXECUTE | RESERVED)\n"
"[  3.141460 axruntime:135]   [PA:0x1b0000000, PA:0x1f0000000) reserved "
"memory (READ | WRITE | EXECUTE | RESERVED)\n"
"[  3.153968 axruntime:135]   [PA:0x20008000, PA:0x20009000) mmio (READ | "
"WRITE | DEVICE | RESERVED)\n"
"[  3.165139 axruntime:135]   [PA:0x32000000, PA:0x32008000) mmio (READ | "
"WRITE | DEVICE | RESERVED)\n"
"[  3.176310 axruntime:135]   [PA:0x32011000, PA:0x32012000) mmio (READ | "
"WRITE | DEVICE | RESERVED)\n"
"[  3.187481 axruntime:135]   [PA:0x33002000, PA:0x33003000) mmio (READ | "
"WRITE | DEVICE | RESERVED)\n"
"[  3.198652 axruntime:135]   [PA:0x70035000, PA:0x70036000) mmio (READ | "
"WRITE | DEVICE | RESERVED)\n"
"[  3.209824 axruntime:135]   [PA:0x70038000, PA:0x70039000) mmio (READ | "
"WRITE | DEVICE | RESERVED)\n"
"[  3.220994 axruntime:208] Initialize global memory allocator...\n"
"[  3.228824 axruntime:209]   use TLSF allocator.\n"
"[  3.235195 axmm:60] Initialize virtual memory management...\n"
"[  3.263999 axruntime:150] Initialize platform devices...\n"
"[  3.271067 axhal::platform::aarch64_common::gic:67] Initialize GICv2...\n"
"[  3.279717 axtask::api:73] Initialize scheduling...\n"
"[  3.286374 axtask::api:79]   use FIFO scheduler.\n"
"[  3.292742 axhal::platform::aarch64_common::psci:115] Starting CPU 100 "
"ON ...\n"
"[  3.301975 axruntime:176] Initialize interrupt handlers...\n"
"[  3.301975 axruntime::mp:37] Secondary CPU 1 started.\n"
"[  3.309263 axruntime:186] Primary CPU 0 init OK.\n"
"[  3.316168 axruntime::mp:47] Secondary CPU 1 init OK.\n"
"[  3.329406 0:2 arceos_vmm:17] Starting virtualization...\n"
"[  3.336566 0:2 arceos_vmm:19] Hardware support: true\n"
"[  3.343360 0:6 arceos_vmm::vmm::timer:103] Initing HV Timer...\n"
"[  3.349408 1:7 arceos_vmm::vmm::timer:103] Initing HV Timer...\n"
"[  3.351081 0:6 arceos_vmm::hal:117] Hardware virtualization support enabled "
"on core 0\n"
"[  3.358813 1:7 arceos_vmm::hal:117] Hardware virtualization support enabled "
"on core 1\n"
"[  3.378942 0:2 arceos_vmm::vmm::config:34] Creating VM [0] \"linux-a1000\"\n"
"[  3.387547 0:2 axvm::vm:113] Setting up memory region: "
"[0x80000000~0xf0000000] READ | WRITE | EXECUTE\n"
"[  3.398997 0:2 arceos_vmm::hal:27] Failed to allocate memory region "
"[PA:0x80000000~PA:0xf0000000]: NoMemory\n"
"[  3.429479 0:2 axvm::vm:156] Setting up passthrough device memory region: "
"[0x0~0x80000000] -> [0x0~0x80000000]\n"
"[  3.462795 0:2 axvm::vm:191] VM created: id=0\n"
"[  3.468812 0:2 axvm::vm:206] VM setup: id=0\n"
"[  3.474734 0:2 arceos_vmm::vmm::config:41] VM[0] created success, loading "
"images...\n"
"[  3.484473 0:2 arceos_vmm::vmm::images:38] Loading VM images from memory\n"
"[  3.528456 0:2 arceos_vmm::vmm::config:34] Creating VM [1] \"arceos\"\n"
"[  3.536585 0:2 axvm::vm:113] Setting up memory region: "
"[0x1b0000000~0x1b8000000] READ | WRITE | EXECUTE\n"
"[  3.548225 0:2 arceos_vmm::hal:27] Failed to allocate memory region "
"[PA:0x1b0000000~PA:0x1b8000000]: NoMemory\n"
"[  3.561771 0:2 axvm::vm:156] Setting up passthrough device memory region: "
"[0x20008000~0x20009000] -> [0x20008000~0x20009000]\n"
"[  3.575339 0:2 axvm::vm:191] VM created: id=1\n"
"[  3.581443 0:2 axvm::vm:206] VM setup: id=1\n"
"[  3.587364 0:2 arceos_vmm::vmm::config:41] VM[1] created success, loading "
"images...\n"
"[  3.597103 0:2 arceos_vmm::vmm::images:64] Loading VM images from memory\n"
"[  3.605823 0:2 arceos_vmm::vmm:30] Setting up vcpus...\n"
"[  3.612765 0:2 arceos_vmm::vmm::vcpus:178] Initializing VM[0]'s 1 vcpus\n"
"[  3.621353 0:2 arceos_vmm::vmm::vcpus:209] Spawning task for VM[0] Vcpu[0]\n"
"[  3.630239 0:2 arceos_vmm::vmm::vcpus:221] Vcpu task Task(8, \"VM[0]-"
"VCpu[0]\") created cpumask: [1, ]\n"
"[  3.641597 0:2 arceos_vmm::vmm::vcpus:178] Initializing VM[1]'s 1 vcpus\n"
"[  3.648676 1:8 arceos_vmm::vmm::vcpus:242] VM[0] Vcpu[0] waiting for "
"running\n"
"[  3.650188 0:2 arceos_vmm::vmm::vcpus:209] Spawning task for VM[1] Vcpu[0]\n"
"[  3.668141 0:2 arceos_vmm::vmm::vcpus:221] Vcpu task Task(9, \"VM[1]-"
"VCpu[0]\") created cpumask: [0, ]\n"
"[  3.679503 0:2 arceos_vmm::vmm:37] VMM starting, booting VMs...\n"
"[  3.687330 0:2 axvm::vm:273] Booting VM[0]\n"
"[  3.693156 0:2 arceos_vmm::vmm:43] VM[0] boot success\n"
"[  3.698675 1:8 arceos_vmm::vmm::vcpus:245] VM[0] Vcpu[0] running...\n"
"[  3.700029 0:2 axvm::vm:273] Booting VM[1]\n"
"[  3.714064 0:2 arceos_vmm::vmm:43] VM[1] boot success\n"
"[  3.720942 0:9 arceos_vmm::vmm::vcpus:242] VM[1] Vcpu[0] waiting for "
"running\n"
"[  3.730010 0:9 arceos_vmm::vmm::vcpus:245] VM[1] Vcpu[0] running...\n"
"a\n"
"       d8888                            .d88888b.   .d8888b.\n"
"      d88888                           d88P\" \"Y88b d88P  Y88b\n"
"     d88P888                           888     888 Y88b.\n"
"    d88P 888 888d888  .d8888b  .d88b.  888     888  \"Y888b.\n"
"   d88P  888 888P\"   d88P\"    d8P  Y8b 888     888     \"Y88b.\n"
"  d88P   888 888     888      88888888 888     888       \"888\n"
" d8888888888 888     Y88b.    Y8b.     Y88b. .d88P Y88b  d88P\n"
"d88P     888 888      \"Y8888P  \"Y8888   \"Y88888P\"   \"Y8888P\"\n"
"\n"
"arch = aarch64\n"
"platform = aarch64-qemu-virt\n"
"target = aarch64-unknown-none-softfloat\n"
"build_mode = release\n"
"log_level = debug\n"
"smp = 1\n"
"\n"
"[  3.805794 0 axruntime:130] Logging is enabled.\n"
"[  3.812095 0 axruntime:131] Primary CPU 0 started, dtb = 0x0.\n"
"[  3.819733 0 axruntime:133] Found physcial memory regions:\n"
"[  3.827086 0 axruntime:135]   [PA:0x1b0000000, PA:0x1b0007000) .text (READ "
"| EXECUTE | RESERVED)\n"
"[  3.838065 0 axruntime:135]   [PA:0x1b0007000, PA:0x1b0009000) .rodata "
"(READ | RESERVED)\n"
"[  3.848281 0 axruntime:135]   [PA:0x1b0009000, PA:0x1b000d000) .data ."
"tdata .tbss .percpu (READ | WRITE | RESERVED)\n"
"[  3.861076 0 axruntime:135]   [PA:0x1b000d000, PA:0x1b004d000) boot stack "
"(READ | WRITE | RESERVED)\n"
"[  3.872342 0 axruntime:135]   [PA:0x1b004d000, PA:0x1b004e000) .bss (READ | "
"WRITE | RESERVED)\n"
"[  3.883036 0 axruntime:135]   [PA:0x1b004e000, PA:0x1b8000000) free memory "
"(READ | WRITE | FREE)\n"
"[  3.894017 0 axruntime:135]   [PA:0x20008000, PA:0x20009000) mmio (READ | "
"WRITE | DEVICE | RESERVED)\n"
"[  3.905379 0 axruntime:150] Initialize platform devices...\n"
"[  3.912731 0 axruntime:188] Primary CPU 0 init OK.\n"
"Hello, world!\n"
"[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x411fd050]\n"
"[    0.000000] Linux version 6.1.54-rt15-00068-g09f2347c9237 "
"(tanghanwe@ubuntu-virtual-machine) (aarch64-linux-gnu-gcc (Ubuntu 9.4.0-15\n"
"[    0.000000] Machine model: BST A1000B FAD-A\n"
"[    0.000000] earlycon: uart8250 at MMIO32 0x0000000020008000 (options '')\n"
"[    0.000000] printk: bootconsole [uart8250] enabled\n"
"[    0.000000] Invalid option string for rodata: 'n'\n"
"[    0.000000] Reserved memory: created DMA memory pool at "
"0x000000008b000000, size 32 MiB\n"
"[    0.000000] OF: reserved mem: initialized node bst_atf@8b000000, "
"compatible id shared-dma-pool\n"
"[    0.000000] Reserved memory: created DMA memory pool at "
"0x000000008fec0000, size 0 MiB\n"
"[    0.000000] OF: reserved mem: initialized node bst_tee@8fec0000, "
"compatible id shared-dma-pool\n"
"[    0.000000] Reserved memory: created DMA memory pool at "
"0x000000008ff00000, size 1 MiB\n"
"[    0.000000] OF: reserved mem: initialized node bstn_cma@8ff00000, "
"compatible id shared-dma-pool\n"
"[    0.000000] Reserved memory: created DMA memory pool at "
"0x000000009a000000, size 32 MiB\n"
"[    0.000000] OF: reserved mem: initialized node bst_cv_cma@9a000000, "
"compatible id shared-dma-pool\n"
"[    0.000000] Reserved memory: created DMA memory pool at "
"0x000000009c000000, size 16 MiB\n"
"[    0.000000] OF: reserved mem: initialized node vsp@0x9c000000, compatible "
"id shared-dma-pool\n"
"[    0.000000] Reserved memory: created DMA memory pool at "
"0x00000000a1000000, size 16 MiB\n"
"[    0.000000] OF: reserved mem: initialized node bst_isp@0xa1000000, "
"compatible id shared-dma-pool\n"
"[    0.000000] Reserved memory: created CMA memory pool at "
"0x00000000b2000000, size 864 MiB\n"
"[    0.000000] OF: reserved mem: initialized node coreip_pub_cma@0xb2000000, "
"compatible id shared-dma-pool\n"
"[    0.000000] Reserved memory: created CMA memory pool at "
"0x00000000e8000000, size 8 MiB\n"
"[    0.000000] OF: reserved mem: initialized node noc_pmu@0xe8000000, "
"compatible id shared-dma-pool\n"
"[    0.000000] Reserved memory: created CMA memory pool at "
"0x00000000e8800000, size 8 MiB\n"
"[    0.000000] OF: reserved mem: initialized node canfd@0xe8800000, "
"compatible id shared-dma-pool\n"
"[    0.000000] Zone ranges:\n"
"[    0.000000]   DMA      [mem 0x0000000080000000-0x00000000efffffff]\n"
"[    0.000000]   DMA32    empty\n"
"[    0.000000]   Normal   empty\n"
"[    0.000000] Movable zone start for each node\n"
"[    0.000000] Early memory node ranges\n"
"[    0.000000]   node   0: [mem 0x0000000080000000-0x000000008affffff]\n"
"[    0.000000]   node   0: [mem 0x000000008b000000-0x000000008cffffff]\n"
"[    0.000000]   node   0: [mem 0x000000008d000000-0x000000008fcfffff]\n"
"[    0.000000]   node   0: [mem 0x000000008fd00000-0x000000008fdfffff]\n"
"[    0.000000]   node   0: [mem 0x000000008fe00000-0x000000008febffff]\n"
"[    0.000000]   node   0: [mem 0x000000008fec0000-0x00000000b1ffffff]\n"
"[    0.000000]   node   0: [mem 0x00000000b2000000-0x00000000efffffff]\n"
"[    0.000000] Initmem setup node 0 [mem "
"0x0000000080000000-0x00000000efffffff]\n"
"[    0.000000] cma: Reserved 128 MiB at 0x0000000083000000\n"
"[    0.000000] psci: probing for conduit method from DT.\n"
"[    0.000000] psci: Using PSCI v0.1 Function IDs from DT\n"
"[    0.000000] percpu: Embedded 19 pages/cpu s40872 r8192 d28760 u77824\n"
"[    0.000000] Detected VIPT I-cache on CPU0\n"
"[    0.000000] CPU features: detected: Qualcomm erratum 1009, or ARM erratum "
"1286807, 2441009\n"
"[    0.000000] CPU features: detected: ARM errata 1165522, 1319367, or "
"1530923\n"
"[    0.000000] alternatives: applying boot alternatives\n"
"[    0.000000] Built 1 zonelists, mobility grouping on.  Total pages: "
"451584\n"
"[    0.000000] Kernel command line: earlycon=uart8250,mmio32,0x20008000 "
"console=ttyS0,115200n8 memreserve=64M@0xf8000000 rdinit=/sbin/n\n"
"[    0.000000] Unknown kernel command line parameters "
"\"memreserve=64M@0xf8000000\", will be passed to user space.\n"
"[    0.000000] Dentry cache hash table entries: 262144 (order: 9, 2097152 "
"bytes, linear)\n"
"[    0.000000] Inode-cache hash table entries: 131072 (order: 8, 1048576 "
"bytes, linear)\n"
"[    0.000000] mem auto-init: stack:off, heap alloc:off, heap free:off\n"
"[    0.000000] Memory: 148300K/1835008K available (11392K kernel code, 7766K "
"rwdata, 3884K rodata, 1856K init, 2597K bss, 654516K rese)\n"
"[    0.000000] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1\n"
"[    0.000000] rcu: Hierarchical RCU implementation.\n"
"[    0.000000] rcu:     RCU restricting CPUs from NR_CPUS=8 to "
"nr_cpu_ids=1.\n"
"[    0.000000]  Tracing variant of Tasks RCU enabled.\n"
"[    0.000000] rcu: RCU calculated value of scheduler-enlistment delay is 10 "
"jiffies.\n"
"[    0.000000] rcu: Adjusting geometry for rcu_fanout_leaf=16, nr_cpu_ids=1\n"
"[    0.000000] NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0\n"
"[    0.000000] Root IRQ handler: gic_handle_irq\n"
"[    0.000000] rcu: srcu_init: Setting srcu_struct sizes based on "
"contention.\n"
"[    0.000000] arch_timer: cp15 timer(s) running at 325.00MHz (virt).\n"
"[    0.000000] clocksource: arch_sys_counter: mask: 0x7ffffffffffffff "
"max_cycles: 0x4af477f6aa, max_idle_ns: 440795207830 ns\n"
"[    0.000000] sched_clock: 59 bits at 325MHz, resolution 3ns, wraps every "
"4398046511103ns\n"
"[    0.009203] Console: colour dummy device 80x25\n"
"[    0.014105] Calibrating delay loop (skipped), value calculated using "
"timer frequency.. 650.00 BogoMIPS (lpj=3250000)\n"
"[    0.025674] pid_max: default: 32768 minimum: 301\n"
"[    0.030832] LSM: Security Framework initializing\n"
"[    0.035944] SELinux:  Initializing.\n"
"[    0.039963] Mount-cache hash table entries: 4096 (order: 3, 32768 bytes, "
"linear)\n"
"[    0.048098] Mountpoint-cache hash table entries: 4096 (order: 3, 32768 "
"bytes, linear)\n"
"[    0.057524] cacheinfo: Unable to detect cache hierarchy for CPU 0\n"
"[    0.064574] cblist_init_generic: Setting adjustable number of callback "
"queues.\n"
"[    0.072506] cblist_init_generic: Setting shift to 0 and lim to 1.\n"
"[    0.079357] rcu: Hierarchical SRCU implementation.\n"
"[    0.079359] rcu:     Max phase no-delay instances is 1000.\n"
"[    0.079396] printk: bootconsole [uart8250] printing thread started\n"
"[    0.090833] smp: Bringing up secondary CPUs ...\n"
"[    0.090836] smp: Brought up 1 node, 1 CPU\n"
"[    0.090841] SMP: Total of 1 processors activated.\n"
"[    0.090847] CPU features: detected: 32-bit EL0 Support\n"
"[    0.090852] CPU features: detected: Data cache clean to the PoU not "
"required for I/D coherence\n"
"[    0.090856] CPU features: detected: Common not Private translations\n"
"[    0.090858] CPU features: detected: CRC32 instructions\n"
"[    0.090864] CPU features: detected: RCpc load-acquire (LDAPR)\n"
"[    0.090866] CPU features: detected: Privileged Access Never\n"
"[    0.090869] CPU features: detected: RAS Extension Support\n"
"[    0.090920] CPU: All CPU(s) started at EL1\n"
"[    0.090923] alternatives: applying system-wide alternatives\n"
"[    0.092365] devtmpfs: initialized\n"
"[    0.112929] clocksource: jiffies: mask: 0xffffffff max_cycles: "
"0xffffffff, max_idle_ns: 19112604462750000 ns\n"
"[    0.112943] futex hash table entries: 256 (order: 2, 16384 bytes, "
"linear)\n"
"[    0.143754] pinctrl core: initialized pinctrl subsystem\n"
"[    0.144394] NET: Registered PF_NETLINK/PF_ROUTE protocol family\n"
"[    0.145208] DMA: preallocated 256 KiB GFP_KERNEL pool for atomic "
"allocations\n"
"[    0.145267] DMA: preallocated 256 KiB GFP_KERNEL|GFP_DMA pool for atomic "
"allocations\n"
"[    0.145333] DMA: preallocated 256 KiB GFP_KERNEL|GFP_DMA32 pool for "
"atomic allocations\n"
"[    0.328274] printk: console [ttyS0] enabled\n"
"[    0.328278] printk: bootconsole [uart8250] disabled\n"
"[    0.328291] printk: bootconsole [uart8250] printing thread stopped\n"
"[    0.328548] dw-apb-uart 2000a000.serial: uart clock frequency (&p-"
">uartclk):25000000\n"
"[    0.328553] dw-apb-uart 2000a000.serial: uart clock frequency "
"(baudclk):25000000\n"
"[    0.328557] dw-apb-uart 2000a000.serial: uart clock frequency "
"(apb_pclk):100000000\n"
"[    0.328665] 2000a000.serial: ttyS1 at MMIO 0x2000a000 (irq = 32, "
"base_baud = 1562500) is a 16550A\n"
"[    0.328889] dw-apb-uart 20009000.serial: uart clock frequency (&p-"
">uartclk):25000000\n"
"[    0.328894] dw-apb-uart 20009000.serial: uart clock frequency "
"(baudclk):25000000\n"
"[    0.328898] dw-apb-uart 20009000.serial: uart clock frequency "
"(apb_pclk):100000000\n"
"[    0.328996] 20009000.serial: ttyS2 at MMIO 0x20009000 (irq = 33, "
"base_baud = 1562500) is a 16550A\n"
"[    0.329813] =======lt9211_probe in...\n"
"[    0.329816] =======lt9211_probe in1...\n"
"[    0.329818] nlt9211 4-002d: =======lt9211_probe in2...\n"
"[    0.329900] max96789 1-0040: *************MAX96789 RGB To MIPIDSI "
"Config*************\n"
"[    0.329935] printk: console [ttyS0] printing thread started\n"
"[    0.412081] ====update_chnl_id in ...!\n"
"[    0.649752] MAX config start\n"
"[    1.999794] End of MAX config status 0\n"
"[    1.999945] Mali<2>:\n"
"[    1.999947] Inserting Mali v900 device driver.\n"
"[    1.999950] Mali<2>:\n"
"[    1.999950] Compiled: Jan 22 2025, time: 15:53:22.\n"
"[    1.999953] Mali<2>:\n"
"[    1.999954] Driver revision: -6.1.54.REL.B231218-68-g09f2347c9237\n"
"[    1.999956] Mali<2>:\n"
"[    1.999957] mali_module_init() registering driver\n"
"[    2.000028] Mali<2>:\n"
"[    2.000029] mali_probe(): Called for platform device 33300000.gpu\n"
"[    2.000113] Mali<2>:\n"
"[    2.000114] mali-450 device tree detected.\n"
"[    2.000252] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPP2 not found\n"
"[    2.000260] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPPMMU2 not "
"found\n"
"[    2.000265] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPP3 not found\n"
"[    2.000271] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPPMMU3 not "
"found\n"
"[    2.000276] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPP4 not found\n"
"[    2.000282] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPPMMU4 not "
"found\n"
"[    2.000286] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPP5 not found\n"
"[    2.000292] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPPMMU5 not "
"found\n"
"[    2.000297] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPP6 not found\n"
"[    2.000302] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPPMMU6 not "
"found\n"
"[    2.000307] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPP7 not found\n"
"[    2.000311] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPPMMU not "
"found\n"
"[    2.000437] Mali<2>:\n"
"[    2.000439] Mali SWAP: Swap out threshold vaule is 60M\n"
"[    2.000453] Mali<2>:\n"
"[    2.000454] Mali memory settings (shared: 0xFFFFFFFF)\n"
"[    2.000458] Mali<2>:\n"
"[    2.000459] Using device defined frame buffer settings "
"(0x01000000@0xB8000000)\n"
"[    2.000463] Mali<2>:\n"
"[    2.000464] Memory Validator installed for Mali physical address "
"base=0xB8000000, size=0x01000000\n"
"[    2.000469] Mali<2>:\n"
"[    2.000471] Mali PMU: Creating Mali PMU core\n"
"[    2.000477] Mali<2>:\n"
"[    2.000478] Couldn't find pmu_switch_delay in device tree configuration.\n"
"[    2.000481] Mali<2>:\n"
"[    2.000482] Get pmu config from device tree configuration.\n"
"[    2.000484] Mali<2>:\n"
"[    2.000485] Using hw detect pmu config:\n"
"[    2.000488] Mali<2>:\n"
"[    2.000490] domain_config[0] = 0x1\n"
"[    2.000492] Mali<2>:\n"
"[    2.000493] domain_config[1] = 0x2\n"
"[    2.000495] Mali<2>:\n"
"[    2.000496] domain_config[2] = 0x4\n"
"[    2.000498] Mali<2>:\n"
"[    2.000499] domain_config[9] = 0x1\n"
"[    2.000501] Mali<2>:\n"
"[    2.000502] domain_config[10] = 0x2\n"
"[    2.000505] Mali<2>:\n"
"[    2.000506] Mali PM domain: Creating Mali PM domain (mask=0x00000001)\n"
"[    2.000508] Mali<2>:\n"
"[    2.000509] Mali PM domain: Creating Mali PM domain (mask=0x00000002)\n"
"[    2.000511] Mali<2>:\n"
"[    2.000512] Mali PM domain: Creating Mali PM domain (mask=0x00000004)\n"
"[    2.000514] Mali<2>:\n"
"[    2.000515] Mali PM domain: Creating Mali PM domain (mask=0x00001000)\n"
"[    2.000521] Mali<2>:\n"
"[    2.000522] Broadcast: Creating Mali Broadcast unit: Mali_Broadcast\n"
"[    2.000533] Mali<2>:\n"
"[    2.000534] Mali PP: Creating Mali PP core: Mali_PP0\n"
"[    2.000535] Mali<2>:\n"
"[    2.000536] Mali PP: Base address of PP core: 0x33308000\n"
"[    2.000589] Mali<2>:\n"
"[    2.000590] Found Mali GPU Mali-450 MP r0p0\n"
"[    2.000648] Mali<2>:\n"
"[    2.000650] Mali DLBU: Initializing\n"
"[    2.000666] Mali<2>:\n"
"[    2.000667] Mali L2 cache: Created Mali_L2:   8K, 4-way, 64byte cache "
"line, 128bit external bus\n"
"[    2.000675] Mali<2>:\n"
"[    2.000676] Mali L2 cache: Created Mali_L2:  64K, 4-way, 64byte cache "
"line, 128bit external bus\n"
"[    2.000686] Mali<2>:\n"
"[    2.000688] Mali MMU: Creating Mali MMU: Mali_GP_MMU\n"
"[    2.000709] Mali<2>:\n"
"[    2.000711] mali_mmu_probe_irq_acknowledge: intstat 0x3\n"
"[    2.000713] Mali<2>:\n"
"[    2.000714] Probe: Page fault detect: PASSED\n"
"[    2.000716] Mali<2>:\n"
"[    2.000717] Probe: Bus read error detect: PASSED\n"
"[    2.000726] Mali<2>:\n"
"[    2.000727] Mali GP: Creating Mali GP core: Mali_GP\n"
"[    2.000769] Mali<2>:\n"
"[    2.000770] Mali MMU: Creating Mali MMU: Mali_PP0_MMU\n"
"[    2.000789] Mali<2>:\n"
"[    2.000790] mali_mmu_probe_irq_acknowledge: intstat 0x3\n"
"[    2.000792] Mali<2>:\n"
"[    2.000793] Probe: Page fault detect: PASSED\n"
"[    2.000794] Mali<2>:\n"
"[    2.000796] Probe: Bus read error detect: PASSED\n"
"[    2.000804] Mali<2>:\n"
"[    2.000805] Mali PP: Creating Mali PP core: Mali_PP0\n"
"[    2.000806] Mali<2>:\n"
"[    2.000807] Mali PP: Base address of PP core: 0x33308000\n"
"[    2.000838] Mali<2>:\n"
"[    2.000840] Mali MMU: Creating Mali MMU: Mali_PP1_MMU\n"
"[    2.000865] Mali<2>:\n"
"[    2.000867] mali_mmu_probe_irq_acknowledge: intstat 0x3\n"
"[    2.000869] Mali<2>:\n"
"[    2.000870] Probe: Page fault detect: PASSED\n"
"[    2.000871] Mali<2>:\n"
"[    2.000872] Probe: Bus read error detect: PASSED\n"
"[    2.000881] Mali<2>:\n"
"[    2.000882] Mali PP: Creating Mali PP core: Mali_PP1\n"
"[    2.000883] Mali<2>:\n"
"[    2.000884] Mali PP: Base address of PP core: 0x3330a000\n"
"[    2.000909] Mali<2>:\n"
"[    2.000910] Starting new virtual group for MMU PP broadcast core "
"Mali_PP_MMU_Broadcast\n"
"[    2.000912] Mali<2>:\n"
"[    2.000913] Mali DLBU: Creating Mali dynamic load balancing unit: "
"Mali_DLBU\n"
"[    2.000918] Mali<2>:\n"
"[    2.000919] Broadcast: Creating Mali Broadcast unit: Mali_Broadcast\n"
"[    2.000925] Mali<2>:\n"
"[    2.000926] Mali MMU: Creating Mali MMU: Mali_PP_MMU_Broadcast\n"
"[    2.000930] Mali<2>:\n"
"[    2.000931] Mali PP: Creating Mali PP core: Mali_PP_Broadcast\n"
"[    2.000932] Mali<2>:\n"
"[    2.000933] Mali PP: Base address of PP core: 0x33316000\n"
"[    2.000971] Mali<2>:\n"
"[    2.000972] 2+0 PP cores initialized\n"
"[    2.000985] Mali<2>:\n"
"[    2.000987] Mali GPU Timer: 1000\n"
"[    2.000990] Mali<2>:\n"
"[    2.000990] Mali GPU Utilization: No platform utilization handler "
"installed\n"
"[    2.000993] Mali<2>:\n"
"[    2.000994] Mali DVFS init: platform function callback incomplete, need "
"check mali_gpu_device_data in platform .\n"
"[    2.001356] Mali<2>:\n"
"[    2.001358] mali_probe(): Successfully initialized driver for platform "
"device 33300000.gpu\n"
"[    2.001417] Mali:\n"
"[    2.001419] Mali device driver loaded\n"
"[    2.001470] cacheinfo: Unable to detect cache hierarchy for CPU 0\n"
"[    2.006214] brd: module loaded\n"
"[    2.008623] loop: module loaded\n"
"[    2.009038] null_blk: disk nullb0 created\n"
"[    2.009042] null_blk: module loaded\n"
"[    2.009046] dummy-irq: no IRQ given.  Use irq=N\n"
"[    2.010260] slave@0 enforce active low on chipselect handle\n"
"[    2.021387] qspi0-nor0@0 enforce active low on chipselect handle\n"
"[    2.179081] spi-nor spi6.0: w25q256jw (32768 Kbytes)\n"
"[    2.179172] 2 fixed-partitions partitions found on MTD device spi6.0\n"
"[    2.179176] Creating 2 MTD partitions on \"spi6.0\":\n"
"[    2.179189] 0x000000000000-0x000001e00000 : \"nor0_part0\"\n"
"[    2.179739] 0x000001e00000-0x000002000000 : \"nor0_part1\"\n"
"[    2.181991] bst_canfd 20016000.canfd: Driver registered: "
"regs=0xffffffc009f54000, irq=44, clock=200000000\n"
"[    2.182428] bst_canfd 20016800.canfd: Driver registered: "
"regs=0xffffffc009f58800, irq=45, clock=200000000\n"
"[    2.182935] bst_canfd 20017000.canfd: Driver registered: "
"regs=0xffffffc009f5c000, irq=46, clock=200000000\n"
"[    2.183054] CAN device driver interface\n"
"[    2.183100] usbcore: registered new interface driver asix\n"
"[    2.183131] usbcore: registered new interface driver ax88179_178a\n"
"[    2.183156] usbcore: registered new interface driver cdc_ether\n"
"[    2.183175] usbcore: registered new interface driver net1080\n"
"[    2.183192] usbcore: registered new interface driver cdc_subset\n"
"[    2.183208] usbcore: registered new interface driver zaurus\n"
"[    2.183239] usbcore: registered new interface driver cdc_ncm\n"
"[    2.183263] usbcore: registered new interface driver r8153_ecm\n"
"[    2.183804] dwc3,usb:dwc3_set_reqinfo_len,1082\n"
"[    2.190672] bst-dwc3 amba_apu@0:usb2: usb30 could not find power control "
"gpio.\n"
"[    2.190896] dwc3,usb:dwc3_set_reqinfo_len,1082\n"
"[    2.191939] xhci-hcd xhci-hcd.0.auto: xHCI Host Controller\n"
"[    2.191956] xhci-hcd xhci-hcd.0.auto: new USB bus registered, assigned "
"bus number 1\n"
"[    2.192359] xhci-hcd xhci-hcd.0.auto: hcc params 0x0220fe64 hci version "
"0x110 quirks 0x0000000000010010\n"
"[    2.192392] xhci-hcd xhci-hcd.0.auto: irq 47, io mem 0x30200000\n"
"[    2.192515] xhci-hcd xhci-hcd.0.auto: xHCI Host Controller\n"
"[    2.192523] xhci-hcd xhci-hcd.0.auto: new USB bus registered, assigned "
"bus number 2\n"
"[    2.192530] xhci-hcd xhci-hcd.0.auto: Host supports USB 3.0 SuperSpeed\n"
"[    2.192901] hub 1-0:1.0: USB hub found\n"
"[    2.192934] hub 1-0:1.0: 1 port detected\n"
"[    2.193097] usb usb2: We don't know the algorithms for LPM for this host, "
"disabling LPM.\n"
"[    2.193357] hub 2-0:1.0: USB hub found\n"
"[    2.193381] hub 2-0:1.0: 1 port detected\n"
"[    2.193626] usbcore: registered new interface driver uas\n"
"[    2.193670] usbcore: registered new interface driver usb-storage\n"
"[    2.193736] usbcore: registered new interface driver option\n"
"[    2.193749] usbserial: USB Serial support registered for GSM modem (1-"
"port)\n"
"[    2.193848] gadgetfs: USB Gadget filesystem, version 24 Aug 2004\n"
"[    2.193950] i2c_dev: i2c /dev entries driver\n"
"[    2.194458] bst,maxim-deser-hub 2-0029: maxim_hub_parse_dt() line:1255 "
"GMSL2\n"
"[    2.194468] bst,maxim-deser-hub 2-0029: lane-num = 2\n"
"[    2.194491] bst,maxim-deser-hub 2-0029: trigger-tx-gpio index0  = 8\n"
"[    2.194496] bst,maxim-deser-hub 2-0029: camera index is 0,ser is 42,"
"ser_alias is 60,sensor addr is 36, sensor_i2c_addr_alias is 70\n"
"[    2.194505] bst,maxim-deser-hub 2-0029: parse_input_dt:: input device1 "
"not found\n"
"[    2.194515] bst,maxim-deser-hub 2-0029: parse_input_dt:: input device2 "
"not found\n"
"[    2.194527] bst,maxim-deser-hub 2-0029: parse_input_dt:: input device3 "
"not found\n"
"[    2.246055] bst,maxim-deser-hub 2-0029: read_back REG_ENABLE : 0x14\n"
"[    2.251854] bst,maxim-deser-hub 2-0029: read_back REG_MNL : 0x10\n"
"[    2.251864] bst,maxim-deser-hub 2-0029: maxim_hub_probe: lock gpio -2 is "
"invalid\n"
"[    2.359981] maxim hub probe done\n"
"[    2.360116] bst,maxim-deser-hub 2-002a: maxim_hub_parse_dt() line:1255 "
"GMSL2\n"
"[    2.360136] bst,maxim-deser-hub 2-002a: trigger-tx-gpio index0  = 0\n"
"[    2.360141] bst,maxim-deser-hub 2-002a: camera index is 0,ser is 42,"
"ser_alias is 64,sensor addr is 36, sensor_i2c_addr_alias is 54\n"
"[    2.360156] bst,maxim-deser-hub 2-002a: trigger-tx-gpio index1  = 0\n"
"[    2.360161] bst,maxim-deser-hub 2-002a: camera index is 1,ser is 42,"
"ser_alias is 65,sensor addr is 36, sensor_i2c_addr_alias is 55\n"
"[    2.360177] bst,maxim-deser-hub 2-002a: trigger-tx-gpio index2  = 0\n"
"[    2.360182] bst,maxim-deser-hub 2-002a: camera index is 2,ser is 42,"
"ser_alias is 66,sensor addr is 36, sensor_i2c_addr_alias is 56\n"
"[    2.360198] bst,maxim-deser-hub 2-002a: trigger-tx-gpio index3  = 0\n"
"[    2.360203] bst,maxim-deser-hub 2-002a: camera index is 3,ser is 42,"
"ser_alias is 67,sensor addr is 36, sensor_i2c_addr_alias is 57\n"
"[    2.428511] bst,maxim-deser-hub 2-002a: read_back REG_ENABLE : 0x14\n"
"[    2.435440] bst,maxim-deser-hub 2-002a: read_back REG_MNL : 0x10\n"
"[    2.435449] bst,maxim-deser-hub 2-002a: maxim_hub_probe: lock gpio -2 is "
"invalid\n"
"[    2.543722] maxim hub probe done\n"
"[    2.543952] bst,maxim-deser-hub 2-002e: maxim_hub_parse_dt() line:1255 "
"GMSL2\n"
"[    2.543960] bst,maxim-deser-hub 2-002e: lane-num = 2\n"
"[    2.543975] bst,maxim-deser-hub 2-002e: trigger-tx-gpio index0  = 8\n"
"[    2.543980] bst,maxim-deser-hub 2-002e: camera index is 0,ser is 42,"
"ser_alias is 48,sensor addr is 36, sensor_i2c_addr_alias is 58\n"
"[    2.543990] bst,maxim-deser-hub 2-002e: parse_input_dt:: input device1 "
"not found\n"
"[    2.543995] bst,maxim-deser-hub 2-002e: parse_input_dt:: input port2 not "
"found\n"
"[    2.543995]\n"
"[    2.544000] bst,maxim-deser-hub 2-002e: parse_input_dt:: input port3 not "
"found\n"
"[    2.544000]\n"
"[    2.596048] i2c_transfer error, slave = 0x2e, reg = 0x17, ret = -121\n"
"[    2.617712] i2c_transfer error, slave = 0x2e, reg = 0x17, ret = -121\n"
"[    2.628477] i2c_transfer error, slave = 0x2e, reg = 0x17, ret = -121\n"
"[    2.633481] write_reg() line:177, write 2e:[17,14]failed!\n"
"[    2.633486] bst,maxim-deser-hub 2-002e: max96712_reg_write: write 0x17 "
"failed\n"
"[    2.641093] i2c_transfer error, slave = 0x2e, reg = 0x19, ret = -121\n"
"[    2.648385] i2c_transfer error, slave = 0x2e, reg = 0x19, ret = -121\n"
"[    2.656981] i2c_transfer error, slave = 0x2e, reg = 0x19, ret = -121\n"
"[    2.661984] write_reg() line:177, write 2e:[19,10]failed!\n"
"[    2.661988] bst,maxim-deser-hub 2-002e: max96712_reg_write: write 0x19 "
"failed\n"
"[    2.669782] i2c_transfer error, slave = 0x2e, reg = 0x17, ret = -121\n"
"[    2.681765] i2c_transfer error, slave = 0x2e, reg = 0x17, ret = -121\n"
"[    2.699231] i2c_transfer error, slave = 0x2e, reg = 0x17, ret = -121\n"
"[    2.704236] bst,maxim-deser-hub 2-002e: max96712_reg_read() line:256, "
"read 0x2e:[0x17,0x74]failed!\n"
"[    2.704241] bst,maxim-deser-hub 2-002e: read_back REG_ENABLE : 0x74\n"
"[    2.706534] i2c_transfer error, slave = 0x2e, reg = 0x19, ret = -121\n"
"[    2.721833] i2c_transfer error, slave = 0x2e, reg = 0x19, ret = -121\n"
"[    2.730518] i2c_transfer error, slave = 0x2e, reg = 0x19, ret = -121\n"
"[    2.735523] bst,maxim-deser-hub 2-002e: max96712_reg_read() line:256, "
"read 0x2e:[0x19,0x74]failed!\n"
"[    2.735529] bst,maxim-deser-hub 2-002e: read_back REG_MNL : 0x74\n"
"[    2.735538] bst,maxim-deser-hub 2-002e: maxim_hub_probe: lock gpio -2 is "
"invalid\n"
"[    2.741656] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    2.752880] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    2.761914] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    2.766918] bst,maxim-deser-hub 2-002e: max96712_reg_read() line:256, "
"read 0x2e:[0x0,0x0]failed!\n"
"[    2.807958] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    2.818290] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    2.832877] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    2.837882] bst,maxim-deser-hub 2-002e: max96712_reg_read() line:256, "
"read 0x2e:[0x0,0x0]failed!\n"
"[    2.878198] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    2.888876] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    2.899817] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    2.904822] bst,maxim-deser-hub 2-002e: max96712_reg_read() line:256, "
"read 0x2e:[0x0,0x0]failed!\n"
"[    2.951156] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    2.965569] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    2.989650] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    2.994655] bst,maxim-deser-hub 2-002e: max96712_reg_read() line:256, "
"read 0x2e:[0x0,0x0]failed!\n"
"[    3.035950] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    3.059508] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    3.068798] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    3.073802] bst,maxim-deser-hub 2-002e: max96712_reg_read() line:256, "
"read 0x2e:[0x0,0x0]failed!\n"
"[    3.118634] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    3.131052] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    3.142345] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    3.147350] bst,maxim-deser-hub 2-002e: max96712_reg_read() line:256, "
"read 0x2e:[0x0,0x0]failed!\n"
"[    3.189046] bst,maxim-deser-hub 2-002e: detect max96712 timeout\n"
"[    3.189049] bst,maxim-deser-hub 2-002e: maxim_hub_probe: not found "
"max96712\n"
"[    3.189058] bst,maxim-deser-hub: probe of 2-002e failed with error -22\n"
"[    3.189676] a1000-csi2 csi@0: a1000_csi_probe\n"
"[    3.189682] a1000-csi2 csi@0: a1000_csi_probe\n"
"[    3.189708] mipi chn 0 connected\n"
"[    3.189712] mipi chn 1 connected\n"
"[    3.189716] mipi chn 2 connected\n"
"[    3.189719] mipi chn 3 connected\n"
"[    3.189835] a1000-csi2 csi@1: a1000_csi_probe\n"
"[    3.189840] a1000-csi2 csi@1: a1000_csi_probe\n"
"[    3.189861] mipi chn 0 connected\n"
"[    3.189865] mipi chn 1 connected\n"
"[    3.189869] mipi chn 2 connected\n"
"[    3.189873] mipi chn 3 connected\n"
"[    3.189971] a1000-csi2 csi@3: a1000_csi_probe\n"
"[    3.189976] a1000-csi2 csi@3: a1000_csi_probe\n"
"[    3.189993] mipi chn 0 connected\n"
"[    3.189997] mipi chn 1 connected\n"
"[    3.190000] mipi chn 2 not connected\n"
"[    3.190003] mipi chn 3 not connected\n"
"[    3.190172] bst_wdt 2001b000.watchdog: wdt bst_wdt_drv_probe, 517\n"
"[    3.190935] bst_wdt 2001c000.watchdog: wdt bst_wdt_drv_probe, 517\n"
"[    3.191072] bst_wdt 2001d000.watchdog: wdt bst_wdt_drv_probe, 517\n"
"[    3.191202] bst_wdt 32009000.watchdog: wdt bst_wdt_drv_probe, 517\n"
"[    3.191405] bst_wdt 3200a000.watchdog: wdt bst_wdt_drv_probe, 517\n"
"[    3.191578] bst_wdt 3200b000.watchdog: wdt bst_wdt_drv_probe, 517\n"
"[    3.191752] bst_wdt 3200c000.watchdog: wdt bst_wdt_drv_probe, 517\n"
"[    3.191939] bst_wdt 3200d000.watchdog: wdt bst_wdt_drv_probe, 517\n"
"[    3.192109] bst_wdt 3200e000.watchdog: wdt bst_wdt_drv_probe, 517\n"
"[    3.192301] bst_wdt 3200f000.watchdog: wdt bst_wdt_drv_probe, 517\n"
"[    3.192467] bst_wdt 32010000.watchdog: wdt bst_wdt_drv_probe, 517\n"
"[    3.192774] sdhci: Secure Digital Host Controller Interface driver\n"
"[    3.192777] sdhci: Copyright(c) Pierre Ossman\n"
"[    3.192778] sdhci-pltfm: SDHCI platform and OF driver helper\n"
"[    3.192969] sdhci-dwcmshc 30400000.dwmmc0: dwcmshc_probe\n"
"[    3.257851] mmc0: SDHCI controller on 30400000.dwmmc0 [30400000.dwmmc0] "
"using ADMA\n"
"[    3.258001] sdhci-dwcmshc 30500000.dwmmc1: dwcmshc_probe\n"
"[    3.504668] mmc0: new high speed MMC card at address 0001\n"
"[    3.505324] mmcblk0: mmc0:0001 CJUD4R 59.6 GiB\n"
"[    3.577787]  mmcblk0: p1 p2 p3 p4 p5 p6 p7 p8 p9 p10\n"
"[    3.579269] mmcblk0boot0: mmc0:0001 CJUD4R 31.9 MiB\n"
"[    3.581351] mmcblk0boot1: mmc0:0001 CJUD4R 31.9 MiB\n"
"[    3.595544] mmcblk0rpmb: mmc0:0001 CJUD4R 4.00 MiB, chardev (239:0)\n"
"[    4.339768] i2c_designware 20005000.i2c: controller timed out\n"
"[    4.339788] sdhci_bst_i2c_write_bytes: i2c write failed: -110\n"
"[    5.379754] i2c_designware 20005000.i2c: controller timed out\n"
"[    5.379760] sdhci_bst_i2c_read_bytes:  i2c read 1 bytes from client@0x8 "
"starting at reg 0x8d failed, error: -110\n"
"[    5.379765] sdhci_bst_i2c_voltage_sel: i2c test failed readdata: 255 send "
"data:1\n"
"[    5.379768] sdhci_bst_voltage_switch failed\n"
"[    5.418222] mmc1: SDHCI controller on 30500000.dwmmc1 [30500000.dwmmc1] "
"using ADMA\n"
"[    5.418423] hid: raw HID events driver (C) Jiri Kosina\n"
"[    5.418636] optee: probing for conduit method.\n"
"[    5.418663] optee: revision 3.11 (28993363)\n"
"[    5.419063] optee: initialized driver\n"
"[    5.419965] netem: version 1.3\n"
"[    5.419985] u32 classifier\n"
"[    5.419986]     Performance counters on\n"
"[    5.419987]     input device check on\n"
"[    5.419988]     Actions configured\n"
"[    5.420100] ipip: IPv4 and MPLS over IPv4 tunneling driver\n"
"[    5.420443] gre: GRE over IPv4 demultiplexor driver\n"
"[    5.420810] NET: Registered PF_INET6 protocol family\n"
"[    5.434247] Segment Routing with IPv6\n"
"[    5.434270] In-situ OAM (IOAM) with IPv6\n"
"[    5.434305] sit: IPv6, IPv4 and MPLS over IPv4 tunneling driver\n"
"[    5.434904] NET: Registered PF_PACKET protocol family\n"
"[    5.434908] can: controller area network core\n"
"[    5.434948] NET: Registered PF_CAN protocol family\n"
"[    5.434953] can: raw protocol\n"
"[    5.434959] 8021q: 802.1Q VLAN Support v1.8\n"
"[    5.435003] sctp: Hash tables configured (bind 256/256)\n"
"[    5.435180] Key type dns_resolver registered\n"
"[    5.435268] ipc 4fec00000.ipc: assigned reserved memory node "
"bstn_cma@8ff00000\n"
"[    5.435621] Loading compiled-in X.509 certificates\n"
"[    5.510900] [bst_cv]: bst_cv_probe 48: BST_CV driver initializing ...\n"
"[    5.510916] [bst_cv]: bst_cv_probe 66: bst_sysfile_init OK\n"
"[    5.510923] [bst_cv]: bst_cv_mem_manager_init 307: phys_to_bus_offset: "
"0x0\n"
"[    5.510928] [bst_cv]: bst_cv_mem_manager_init 314: dma_set_coherent_mask "
"OK.\n"
"[    5.511059] bst_cv 51030000.bst_cv: assigned reserved memory node "
"bst_cv_cma@9a000000\n"
"[    5.511063] [bst_cv]: bst_cv_mem_manager_init 328: kern_sub_phys_offset: "
"0xffffffbf78000000\n"
"[    5.511068] [bst_cv]: bst_cv_probe 74: bst_cv_mem_manager_init OK\n"
"[    5.511111] [bst_cv]: bst_cv_probe 82: bst_cv_fw_manager_init OK\n"
"[    5.511184] [bst_cv]: bst_cv_probe 90: bst_cv_misc_init OK, /dev/bst_cv "
"registered\n"
"[    5.511188] [bst_cv]: bst_cv_probe 96: bst_cv probe completed!\n"
"[    5.511304] [bst_lwnn]: bst_lwnn_probe 74: bst_lwnn driver "
"initializing ...\n"
"[    5.511321] [bst_lwnn]: bst_lwnn_probe 93: bst_sysfile_init OK, /sys/"
"kernel/bst_lwnn registered\n"
"[    5.511327] [bst_lwnn]: bst_lwnn_mem_manager_init 346: "
"phys_to_bus_offset: 0x0\n"
"[    5.511331] [bst_lwnn]: bst_lwnn_mem_manager_init 353: "
"dma_set_coherent_mask OK.\n"
"[    5.511355] bst_lwnn 51030000.bst_lwnn: assigned reserved memory node "
"coreip_pub_cma@0xb2000000\n"
"[    5.511360] [bst_lwnn]: bst_lwnn_probe 101: bst_lwnn_mem_manager_init OK\n"
"[    5.511700] [bst_lwnn]: bst_lwnn_probe 109: bst_lwnn_fw_manager_init OK\n"
"[    5.511751] [bst_lwnn]: bst_lwnn_msg_manager_init 302: ipc_init OK\n"
"[    5.511871] [bst_lwnn]: bst_lwnn_msg_manager_init 334: worker creation "
"OK\n"
"[    5.511876] [bst_lwnn]: bst_lwnn_probe 117: bst_lwnn_msg_manager_init OK\n"
"[    5.511936] [bst_lwnn]: bst_lwnn_probe 125: bst_lwnn_misc_init OK, /dev/"
"bst_lwnn registered\n"
"[    5.511941] [bst_lwnn]: bst_lwnn_probe 133: bst_lwnn probe completed!\n"
"[    5.512064] [bstn]: bstn_probe 50: BSTN driver initializing ...\n"
"[    5.512068] [bstn]: bstn_probe 51: timeout_jiffies: 3200, timeout_ms "
"32000\n"
"[    5.512077] [bstn]: bstn_mem_manager_init 310: phys_to_bus_offset: 0x0\n"
"[    5.512083] [bstn]: bstn_mem_manager_init 324: reserved memory: base "
"0xb2000000 size 0x36000000\n"
"[    5.512088] [bstn]: bstn_mem_manager_init 333: dma_set_mask OK.\n"
"[    5.512091] [bstn]: bstn_mem_manager_init 340: dma_set_coherent_mask OK.\n"
"[    5.512097] bstn 50020000.bstn: assigned reserved memory node "
"coreip_pub_cma@0xb2000000\n"
"[    5.512101] [bstn]: bstn_probe 76: bstn_mem_manager_init OK\n"
"[    5.512119] [bstn]: bstn_fw_manager_init 300: firmware: bstn_dsp_rtos."
"rbf\n"
"[    5.512165] [bstn]: bstn_fw_manager_init 320: assigned mem: "
"0xffffffc00a232000, 0xb2005000, size: 4096\n"
"[    5.512172] [bstn]: bstn_probe 84: bstn_fw_manager_init OK\n"
"[    5.512180] [bstn]: bstn_msg_manager_init 238: ipc_init OK\n"
"[    5.512203] [bstn]: bstn_msg_manager_init 262: req_bufs @ "
"phys:0xb2006000\n"
"[    5.512258] [bstn]: bstn_msg_manager_init 286: bstn_msg_receiver task "
"created 0xffffff800e434380\n"
"[    5.512263] [bstn]: bstn_probe 92: bstn_msg_manager_init OK\n"
"[    5.512273] [bstn]: bstn_probe 100: bstn_sysfile_init OK\n"
"[    5.512344] [bstn]: bstn_probe 108: bstn_misc_init OK, device[bstn0] "
"registered\n"
"[    5.512348] [bstn]: bstn_probe 111: BSTN v2.5.3 probe completed\n"
"[    5.537056] bst_identify_probe\n"
"[    5.537343] vsp-ipc 9c000000.ipc_vsp: assigned reserved memory node "
"vsp@0x9c000000\n"
"[    5.537379] init start = 0x9c200000, initp_size = 0x20660, align size = "
"0x21000\n"
"[    5.537384] cmdp start = 0x9c221000, cmdp_size = 0x2098a0, align size = "
"0x20a000\n"
"[    5.537387] slab start = 0x9c500000, end = 0x9c600000, slab_size = "
"0x100000\n"
"[    5.537390] total_alloc_size = 0x600000\n"
"[    5.538507] c0.base  = (____ptrval____), c1.base  = (____ptrval____), c2."
"base  = (____ptrval____)\n"
"[    5.560295] enter recv\n"
"[    5.560318] printk: console [netcon0] enabled\n"
"[    5.560321] netconsole: network logging started\n"
"[    5.560934] bstgmaceth 30000000.ethernet: error -ENXIO: IRQ rx_chan4_irq "
"not found\n"
"[    5.561038] bstgmaceth 30000000.ethernet: error -ENXIO: IRQ tx_chan4_irq "
"not found\n"
"[    5.561208] printk: console [netcon0] printing thread started\n"
"[    5.573255] bstgmaceth 30000000.ethernet: User ID: 0x10, Synopsys ID: "
"0x51\n"
"[    5.573264] bstgmaceth 30000000.ethernet:    DWMAC4/5\n"
"[    5.573270] bstgmaceth 30000000.ethernet: DMA HW capability register "
"supported\n"
"[    5.573273] bstgmaceth 30000000.ethernet: RX Checksum Offload Engine "
"supported\n"
"[    5.573276] bstgmaceth 30000000.ethernet: TX Checksum insertion "
"supported\n"
"[    5.573289] bstgmaceth 30000000.ethernet (unnamed net_device) "
"(uninitialized): device MAC address 6a:78:6a:e9:b1:c2\n"
"[    5.573298] bstgmaceth 30000000.ethernet: Enabled Flow TC (entries=2)\n"
"[    5.574338] bstgmaceth 30100000.ethernet: error -ENXIO: IRQ rx_chan4_irq "
"not found\n"
"[    5.574444] bstgmaceth 30100000.ethernet: error -ENXIO: IRQ tx_chan4_irq "
"not found\n"
"[    5.574803] bstgmaceth 30100000.ethernet: User ID: 0x10, Synopsys ID: "
"0x51\n"
"[    5.574810] bstgmaceth 30100000.ethernet:    DWMAC4/5\n"
"[    5.574814] bstgmaceth 30100000.ethernet: DMA HW capability register "
"supported\n"
"[    5.574817] bstgmaceth 30100000.ethernet: RX Checksum Offload Engine "
"supported\n"
"[    5.574821] bstgmaceth 30100000.ethernet: TX Checksum insertion "
"supported\n"
"[    5.574830] bstgmaceth 30100000.ethernet (unnamed net_device) "
"(uninitialized): device MAC address 7e:fc:7a:ea:0f:1c\n"
"[    5.574836] bstgmaceth 30100000.ethernet: Enabled Flow TC (entries=2)\n"
"[    6.043844] mdio_bus bstgmac-1: MDIO device at address 7 is missing.\n"
"[    6.044017] bstgmaceth 30100000.ethernet: Cannot register the MDIO bus "
"err -19\n"
"[    6.044022] bstgmaceth 30100000.ethernet: bstgmac_dvr_probe: MDIO bus "
"(id: 1) registration failed\n"
"[    6.044409] a1000_isp isp: isp_probe\n"
"[    6.044415] a1000_isp isp: isp_probe\n"
"[    6.044520] a1000_isp isp: init_isp_channel_devs channel 10 not enabled, "
"skip\n"
"[    6.044525] a1000_isp isp: init_isp_channel_devs channel 11 not enabled, "
"skip\n"
"[    6.044679] deser_notify_bound(),line 1069 channel[3]\n"
"[    6.044687] deser_notify_bound(),line 1069 channel[2]\n"
"[    6.044693] deser_notify_bound(),line 1069 channel[1]\n"
"[    6.044697] deser_notify_bound(),line 1069 channel[0]\n"
"[    6.044709] deser_notify_bound(),line 1069 channel[0]\n"
"[    6.044744] a1000_isp isp: assigned reserved memory node "
"bst_isp@0xa1000000\n"
"[    6.045519] Enter dphy_config\n"
"[    6.045534] dphyTst_setCfg_lanes\n"
"[    6.279753]\n"
"[    6.279753] DPHY_SHUTDOWNZ(40) = 0\n"
"[    6.279756]\n"
"[    6.279756] DPHY lane_speed = 1600\n"
"[    6.279808]\n"
"[    6.279808] reg e5 value is 0x1\n"
"[    6.279814]\n"
"[    6.279814] reg 1ac value is 0x4b\n"
"[    6.279820] nreg e4 value is 0x11\n"
"[    6.279825]\n"
"[    6.279825] reg 8 value is 0x18\n"
"[    6.279827]\n"
"[    6.279827] DPHY_N_LANES(4) = 3(ENABLE RX)\n"
"[    6.279829]\n"
"[    6.279829] force rxmode = 0x3c0030\n"
"[    6.279831] dphyTst_release\n"
"[    6.279832]\n"
"[    6.279832] DPHY_SHUTDOWNZ(40) = 1\n"
"[    6.279834]\n"
"[    6.279834] DPHY_RSTZ(44) = 1\n"
"[    6.345208] dphyTst_release timeout\n"
"[    6.345211]\n"
"[    6.345211] dphy0 enable done.\n"
"[    6.345212] dphyTst_release_1_4lane\n"
"[    6.345214]\n"
"[    6.345214] DPHY_1_RSTZ = 3c003c\n"
"[    6.347220]\n"
"[    6.347220] dphy0 and dphy1 enter stopstate.\n"
"[    6.347222]\n"
"[    6.347222] release force rxmode = 0x3c\n"
"[    6.347224] dphyTst_release_1_4lane finish\n"
"[    6.347238] bst,maxim-deser-hub 2-002a: maxim_hub_s_power() line:986\n"
"[    6.347244] bst,maxim-deser-hub 2-002a: maxim_hub_s_power() line:1007 "
"GMSL2\n"
"[    6.407974] bst,maxim-deser-hub 2-002a: max967XX_replicate_mode() "
"line:509\n"
"[    6.408170] bst,maxim-deser-hub 2-002a: max96712_fsync_config() line:436, "
"tr0\n"
"[    6.408938] bst,maxim-deser-hub 2-002a: INTERNAL TRIGGER MODE\n"
"[    6.409702] bst,maxim-deser-hub 2-002a: trig_info.trigger_tx_gpio[0] = 0\n"
"[    6.416644] bst,maxim-deser-hub 2-002a: modify_serdes_address() 254\n"
"[    6.750420] bst,maxim-deser-hub 2-002a: is_gmsl2_video_connected() index "
"= 0d\n"
"[    6.811052] bst,maxim-deser-hub 2-002a: is_gmsl2_video_connected() index "
"= 1d\n"
"[    6.871687] bst,maxim-deser-hub 2-002a: is_gmsl2_video_connected() index "
"= 2d\n"
"[    6.932321] bst,maxim-deser-hub 2-002a: is_gmsl2_video_connected() index "
"= 3d\n"
"\n"
"CTRL-A Z for help | 115200 8N1 | NOR | Minicom 2.9 | VT102 | Offline | "
"ttyUSB0\n"
"[    7.166303] bst,maxim-deser-hub 2-002a: is_gmsl2_video_connected() index "
"= 0, not linked\n"
"[    7.226936] bst,maxim-deser-hub 2-002a: is_gmsl2_video_connected() index "
"= 1, not linked\n"
"[    7.287571] bst,maxim-deser-hub 2-002a: is_gmsl2_video_connected() index "
"= 2, not linked\n"
"[    7.348212] bst,maxim-deser-hub 2-002a: is_gmsl2_video_connected() index "
"= 3, not linked\n"
"[    7.456521] bst,maxim-deser-hub 2-002a: Failed to request irq 0\n"
"[    7.456526] bst,maxim-deser-hub 2-002a: maxim_hub_s_power(), line 1034, "
"max96712 s_power success!\n"
"[    7.456540] Enter dphy_config\n"
"[    7.456555] dphyTst_setCfg_lanes\n"
"[    7.689752]\n"
"[    7.689752] DPHY_SHUTDOWNZ(40) = 0\n"
"[    7.689755]\n"
"[    7.689755] DPHY lane_speed = 2400\n"
"[    7.689808]\n"
"[    7.689808] reg e5 value is 0x1\n"
"[    7.689813]\n"
"[    7.689813] reg 1ac value is 0x4b\n"
"[    7.689819] nreg e4 value is 0x11\n"
"[    7.689825]\n"
"[    7.689825] reg 8 value is 0x18\n"
"[    7.689827]\n"
"[    7.689827] DPHY_N_LANES(4) = 1(ENABLE RX)\n"
"[    7.689829]\n"
"[    7.689829] force rxmode = 0x3c0030\n"
"[    7.689831] dphyTst_release\n"
"[    7.689832]\n"
"[    7.689832] DPHY_SHUTDOWNZ(40) = 1\n"
"[    7.689834]\n"
"[    7.689834] DPHY_RSTZ(44) = 1\n"
"[    7.755201] dphyTst_release timeout\n"
"[    7.755203]\n"
"[    7.755203] dphy0 enable done.\n"
"[    7.755204] dphyTst_release_1_4lane\n"
"[    7.755206]\n"
"[    7.755206] DPHY_1_RSTZ = 3c003c\n"
"[    7.803760] dphyTst_release_1_4lane timeout\n"
"[    7.803762]\n"
"[    7.803762] dphy0 and dphy1 enter stopstate.\n"
"[    7.803764]\n"
"[    7.803764] release force rxmode = 0x3c\n"
"[    7.803765] dphyTst_release_1_4lane finish\n"
"[    7.803777] bst,maxim-deser-hub 2-0029: maxim_hub_s_power() line:986\n"
"[    7.803782] bst,maxim-deser-hub 2-0029: maxim_hub_s_power() line:1007 "
"GMSL2\n"
"[    7.853309] bst,maxim-deser-hub 2-0029: max967XX_replicate_mode() "
"line:509\n"
"[    7.853506] bst,maxim-deser-hub 2-0029: max96712_fsync_config() line:436, "
"trig_info->trigger_tx_gpio[0] = 8\n"
"[    7.854272] bst,maxim-deser-hub 2-0029: INTERNAL TRIGGER MODE\n"
"[    7.855036] bst,maxim-deser-hub 2-0029: trig_info.trigger_tx_gpio[0] = 8\n"
"[    7.855231] bst,maxim-deser-hub 2-0029: modify_serdes_address() 254\n"
"[    8.196057] bst,maxim-deser-hub 2-0029: is_gmsl2_video_connected() index "
"= 0, not linked\n"
"[    8.196062] modify_serdes_address() cam_dev [1] is NULL, break\n"
"[    8.196064] modify_serdes_address() cam_dev [2] is NULL, break\n"
"[    8.196066] modify_serdes_address() cam_dev [3] is NULL, break\n"
"[    8.447360] bst,maxim-deser-hub 2-0029: is_gmsl2_video_connected() index "
"= 0, not linked\n"
"[    8.507997] bst,maxim-deser-hub 2-0029: is_gmsl2_video_connected() index "
"= 1, not linked\n"
"[    8.568632] bst,maxim-deser-hub 2-0029: is_gmsl2_video_connected() index "
"= 2, not linked\n"
"[    8.629276] bst,maxim-deser-hub 2-0029: is_gmsl2_video_connected() index "
"= 3, not linked\n"
"[    8.737584] bst,maxim-deser-hub 2-0029: Failed to request irq 0\n"
"[    8.737588] bst,maxim-deser-hub 2-0029: maxim_hub_s_power(), line 1034, "
"max96712 s_power success!\n"
"[    8.737593] ox08b camera_s_power(), line 246\n"
"[    8.737600] cfg_num 0, alg_num 0\n"
"[    8.737607] a1000_isp isp: assigned reserved memory node "
"coreip_pub_cma@0xb2000000\n"
"[    8.738184] vsp vsp@1: assigned reserved memory node "
"coreip_pub_cma@0xb2000000\n"
"[    8.738345] [drm] plane:31 created\n"
"[    8.738352] [drm] plane:33 created\n"
"[    8.738718] [drm] Initialized bst-vsp 1.0.0 20200416 for vsp@1 on minor "
"0\n"
"[    8.738732] bst_drm_platform_probe exit!\n"
"[    8.738844] bst-gmwarp gmwarp@0: assigned reserved memory node "
"coreip_pub_cma@0xb2000000\n"
"[    8.738932] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-0 as /dev/"
"video30\n"
"[    8.739001] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-1 as /dev/"
"video31\n"
"[    8.739059] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-2 as /dev/"
"video32\n"
"[    8.739130] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-3 as /dev/"
"video33\n"
"[    8.739189] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-4 as /dev/"
"video34\n"
"[    8.739245] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-5 as /dev/"
"video35\n"
"[    8.739316] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-6 as /dev/"
"video36\n"
"[    8.739384] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-7 as /dev/"
"video37\n"
"[    8.739448] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-8 as /dev/"
"video38\n"
"[    8.739512] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-9 as /dev/"
"video39\n"
"[    8.739568] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-10 as /dev/"
"video40\n"
"[    8.739633] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-11 as /dev/"
"video41\n"
"[    8.739637] bst-gmwarp gmwarp@0: gmwarp probe ok!\n"
"[    8.754621] bst-encode encoder@0: assigned reserved memory node "
"coreip_pub_cma@0xb2000000\n"
"[    8.754701] bst-encode encoder@0: Registerd bst_encoder-0 as /dev/"
"video50\n"
"[    8.754761] bst-encode encoder@0: Registerd bst_encoder-1 as /dev/"
"video51\n"
"[    8.754817] bst-encode encoder@0: Registerd bst_encoder-2 as /dev/"
"video52\n"
"[    8.754882] bst-encode encoder@0: Registerd bst_encoder-3 as /dev/"
"video53\n"
"[    8.754946] bst-encode encoder@0: Registerd bst_encoder-4 as /dev/"
"video54\n"
"[    8.755003] bst-encode encoder@0: Registerd bst_encoder-5 as /dev/"
"video55\n"
"[    8.755065] bst-encode encoder@0: Registerd bst_encoder-6 as /dev/"
"video56\n"
"[    8.755141] bst-encode encoder@0: Registerd bst_encoder-7 as /dev/"
"video57\n"
"[    8.755190] ALSA device list:\n"
"[    8.755195]   No soundcards found.\n"
"[    8.972528] EXT4-fs (mmcblk0p7): recovery complete\n"
"[    8.972949] EXT4-fs (mmcblk0p7): mounted filesystem with ordered data "
"mode. Quota mode: none.\n"
"[    8.972988] VFS: Mounted root (ext4 filesystem) on device 179:7.\n"
"[    8.973612] devtmpfs: mounted\n"
"[    8.974012] Freeing unused kernel memory: 1856K\n"
"[    8.974282] Run /sbin/init as init process\n"
"[    9.158743] audit: type=1404 audit(9.129:2): enforcing=1 old_enforcing=0 "
"auid=4294967295 ses=4294967295 enabled=1 old-enabled=1 lsm=selinux res=1\n"
"[    9.218475] SELinux:  Permission watch in class filesystem not defined in "
"policy.\n"
"[    9.218507] SELinux:  Permission watch in class file not defined in "
"policy.\n"
"[    9.218509] SELinux:  Permission watch_mount in class file not defined in "
"policy.\n"
"[    9.218512] SELinux:  Permission watch_sb in class file not defined in "
"policy.\n"
"[    9.218515] SELinux:  Permission watch_with_perm in class file not "
"defined in policy.\n"
"[    9.218517] SELinux:  Permission watch_reads in class file not defined in "
"policy.\n"
"[    9.218525] SELinux:  Permission watch in class dir not defined in "
"policy.\n"
"[    9.218528] SELinux:  Permission watch_mount in class dir not defined in "
"policy.\n"
"[    9.218530] SELinux:  Permission watch_sb in class dir not defined in "
"policy.\n"
"[    9.218532] SELinux:  Permission watch_with_perm in class dir not defined "
"in policy.\n"
"[    9.218534] SELinux:  Permission watch_reads in class dir not defined in "
"policy.\n"
"[    9.218545] SELinux:  Permission watch in class lnk_file not defined in "
"policy.\n"
"[    9.218548] SELinux:  Permission watch_mount in class lnk_file not "
"defined in policy.\n"
"[    9.218550] SELinux:  Permission watch_sb in class lnk_file not defined "
"in policy.\n"
"[    9.218553] SELinux:  Permission watch_with_perm in class lnk_file not "
"defined in policy.\n"
"[    9.218555] SELinux:  Permission watch_reads in class lnk_file not "
"defined in policy.\n"
"[    9.218562] SELinux:  Permission watch in class chr_file not defined in "
"policy.\n"
"[    9.218564] SELinux:  Permission watch_mount in class chr_file not "
"defined in policy.\n"
"[    9.218566] SELinux:  Permission watch_sb in class chr_file not defined "
"in policy.\n"
"[    9.218569] SELinux:  Permission watch_with_perm in class chr_file not "
"defined in policy.\n"
"[    9.218571] SELinux:  Permission watch_reads in class chr_file not "
"defined in policy.\n"
"[    9.218578] SELinux:  Permission watch in class blk_file not defined in "
"policy.\n"
"[    9.218580] SELinux:  Permission watch_mount in class blk_file not "
"defined in policy.\n"
"[    9.218582] SELinux:  Permission watch_sb in class blk_file not defined "
"in policy.\n"
"[    9.218584] SELinux:  Permission watch_with_perm in class blk_file not "
"defined in policy.\n"
"[    9.218587] SELinux:  Permission watch_reads in class blk_file not "
"defined in policy.\n"
"[    9.218593] SELinux:  Permission watch in class sock_file not defined in "
"policy.\n"
"[    9.218595] SELinux:  Permission watch_mount in class sock_file not "
"defined in policy.\n"
"[    9.218597] SELinux:  Permission watch_sb in class sock_file not defined "
"in policy.\n"
"[    9.218600] SELinux:  Permission watch_with_perm in class sock_file not "
"defined in policy.\n"
"[    9.218602] SELinux:  Permission watch_reads in class sock_file not "
"defined in policy.\n"
"[    9.218608] SELinux:  Permission watch in class fifo_file not defined in "
"policy.\n"
"[    9.218610] SELinux:  Permission watch_mount in class fifo_file not "
"defined in policy.\n"
"[    9.218613] SELinux:  Permission watch_sb in class fifo_file not defined "
"in policy.\n"
"[    9.218615] SELinux:  Permission watch_with_perm in class fifo_file not "
"defined in policy.\n"
"[    9.218618] SELinux:  Permission watch_reads in class fifo_file not "
"defined in policy.\n"
"[    9.218753] SELinux:  Permission perfmon in class capability2 not defined "
"in policy.\n"
"[    9.218756] SELinux:  Permission bpf in class capability2 not defined in "
"policy.\n"
"[    9.218758] SELinux:  Permission checkpoint_restore in class capability2 "
"not defined in policy.\n"
"[    9.218775] SELinux:  Permission perfmon in class cap2_userns not defined "
"in policy.\n"
"[    9.218778] SELinux:  Permission bpf in class cap2_userns not defined in "
"policy.\n"
"[    9.218780] SELinux:  Permission checkpoint_restore in class cap2_userns "
"not defined in policy.\n"
"[    9.218872] SELinux:  Class mctp_socket not defined in policy.\n"
"[    9.218874] SELinux:  Class perf_event not defined in policy.\n"
"[    9.218875] SELinux:  Class anon_inode not defined in policy.\n"
"[    9.218877] SELinux:  Class io_uring not defined in policy.\n"
"[    9.218879] SELinux:  Class user_namespace not defined in policy.\n"
"[    9.218881] SELinux: the above unknown classes and permissions will be "
"allowed\n"
"[    9.241537] SELinux:  policy capability network_peer_controls=1\n"
"[    9.241551] SELinux:  policy capability open_perms=1\n"
"[    9.241553] SELinux:  policy capability extended_socket_class=1\n"
"[    9.241555] SELinux:  policy capability always_check_network=0\n"
"[    9.241558] SELinux:  policy capability cgroup_seclabel=1\n"
"[    9.241560] SELinux:  policy capability nnp_nosuid_transition=1\n"
"[    9.241562] SELinux:  policy capability genfs_seclabel_symlinks=0\n"
"[    9.241564] SELinux:  policy capability ioctl_skip_cloexec=0\n"
"[    9.337566] audit: type=1403 audit(9.309:3): auid=4294967295 "
"ses=4294967295 lsm=selinux res=1\n"
"[    9.347876] systemd[1]: Successfully loaded SELinux policy in 189.944ms.\n"
"[    9.445456] systemd[1]: System time before build time, advancing clock.\n"
"[    9.642816] systemd[1]: Relabelled /dev, /dev/shm, /run, /sys/fs/cgroup "
"in 48.506ms.\n"
"[    9.692606] systemd[1]: systemd 241-9-gc1f8ff8+ running in system mode. "
"(+PAM +AUDIT +SELINUX -IMA -APPARMOR -SMACK +SYSVINIT -UTMP -LIBCRYPTSETUP -"
"GCRYPT -GNUTLS -ACL -XZ -LZ4 -SECC)\n"
"[    9.692902] systemd[1]: Detected architecture arm64.\n"
"[    9.761188] systemd[1]: Set hostname to <a1000>.\n"
"[    9.765722] systemd[1]: Failed to bump fs.file-max, ignoring: Invalid "
"argument\n"
"[    9.865774] systemd-fstab-generator[142]: Mount point  is not a valid "
"path, ignoring.\n"
"[    9.881793] systemd-fstab-generator[142]: Mount point  is not a valid "
"path, ignoring.\n"
"[    9.882075] systemd-fstab-generator[142]: Mount point  is not a valid "
"path, ignoring.\n"
"[    9.945688] systemd[1]: File /lib/systemd/system/systemd-journald."
"service:12 configures an IP firewall (IPAddressDeny=any), but the local "
"system does not support BPF/cgroup based fir.\n"
"[    9.945702] systemd[1]: Proceeding WITHOUT firewalling in effect! (This "
"warning is only shown for the first loaded unit using IP firewalling.)\n"
"[    9.993988] systemd[1]: Configuration file /lib/systemd/system/user-"
"startup.service is marked executable. Please remove executable permission "
"bits. Proceeding anyway.\n"
"[   10.015829] systemd[1]: /lib/systemd/system/usb-gadget@.service:14: "
"Unknown lvalue 'After' in section 'Service', ignoring\n"
"[   10.019272] systemd[1]: Configuration file /lib/systemd/system/safety-"
"service.service is marked executable. Please remove executable permission "
"bits. Proceeding anyway.\n"
"[   10.019582] systemd[1]: /lib/systemd/system/safety-service.service:8: "
"Unknown lvalue 'StartLimitIntervalSec' in section 'Service', ignoring\n"
"[   12.379759] random: crng init done\n"
"[   12.475848] early application starting...\n"
"[   12.730278] audit: type=1130 audit(1675679554.279:4): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=selinux-labeldev comm=\"systemd\" exe=\"/lib/'\n"
"[   12.730364] audit: type=1131 audit(1675679554.279:5): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=selinux-labeldev comm=\"systemd\" exe=\"/lib/'\n"
"[   12.731973] audit: type=1130 audit(1675679554.279:6): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=kmod-static-nodes comm=\"systemd\" exe=\"/lib'\n"
"[   12.761921] audit: type=1130 audit(1675679554.309:7): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=systemd-sysctl comm=\"systemd\" exe=\"/lib/sy'\n"
"[   12.860995] EXT4-fs (mmcblk0p7): re-mounted. Quota mode: none.\n"
"[   12.865560] audit: type=1130 audit(1675679554.409:8): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=systemd-remount-fs comm=\"systemd\" exe=\"/li'\n"
"[   12.956353] audit: type=1130 audit(1675679554.499:9): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=systemd-tmpfiles-setup-dev comm=\"systemd\" '\n"
"[   13.098380] audit: type=1130 audit(1675679554.639:10): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=systemd-journald comm=\"systemd\" exe=\"/lib'\n"
"[   13.180022] systemd-journald[173]: Received request to flush runtime "
"journal from PID 1\n"
"[   13.187569] systemd-journald[173]: File /var/log/journal/"
"c9eb360cf45a4d3ca7df8dc9a4b9d632/system.journal corrupted or uncleanly shut "
"down, renaming and replacing.\n"
"[   13.209076] audit: type=1130 audit(1675679554.749:11): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=systemd-udevd comm=\"systemd\" exe=\"/lib/sy'\n"
"[   13.904594] bst_noc_pmu_probe, 296\n"
"[   13.904685] bst_nocpmu 32702000.noc_pmu: assigned reserved memory node "
"noc_pmu@0xe8000000\n"
"[   13.936242] bst-thermal 70039000.thermal: cooling_dev, name=pwm\n"
"[   14.912819] EXT4-fs (mmcblk0p9): recovery complete\n"
"[   14.912842] EXT4-fs (mmcblk0p9): mounted filesystem with ordered data "
"mode. Quota mode: none.\n"
"[   14.916892] ext4 filesystem being mounted at /secdata supports timestamps "
"until 2038 (0x7fffffff)\n"
"[   14.965123] EXT4-fs (mmcblk0p6): recovery complete\n"
"[   14.965622] EXT4-fs (mmcblk0p6): mounted filesystem with ordered data "
"mode. Quota mode: none.\n"
"[   15.471416] EXT4-fs (mmcblk0p10): recovery complete\n"
"[   15.471609] EXT4-fs (mmcblk0p10): mounted filesystem with ordered data "
"mode. Quota mode: none.\n"
"[   15.583524] kauditd_printk_skb: 2 callbacks suppressed\n"
"[   15.583538] audit: type=1130 audit(1675679557.129:14): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=selinux-autorelabel comm=\"systemd\" exe=\"/'\n"
"[   15.583841] audit: type=1131 audit(1675679557.129:15): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=selinux-autorelabel comm=\"systemd\" exe=\"/'\n"
"[   15.640743] audit: type=1130 audit(1675679557.189:16): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=selinux-init comm=\"systemd\" exe=\"/lib/sys'\n"
"[   15.641029] audit: type=1131 audit(1675679557.189:17): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=selinux-init comm=\"systemd\" exe=\"/lib/sys'\n"
"[   15.745845] audit: type=1130 audit(1675679557.289:18): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=systemd-tmpfiles-setup comm=\"systemd\" exe'\n"
"[   18.103131] audit: type=1130 audit(1675679559.649:19): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=bstosuser comm=\"systemd\" exe=\"/lib/system'\n"
"[   18.103678] audit: type=1131 audit(1675679559.649:20): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=bstosuser comm=\"systemd\" exe=\"/lib/system'\n"
"[   18.193782] audit: type=1130 audit(1675679559.739:21): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=safety-service comm=\"systemd\" exe=\"/lib/s'\n"
"[   18.197052] audit: type=1130 audit(1675679559.739:22): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=user-startup comm=\"systemd\" exe=\"/lib/sys'\n"
"[   18.237303] audit: type=1130 audit(1675679559.779:23): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=busybox-syslog comm=\"systemd\" exe=\"/lib/s'\n"
"[   18.831535] picp: picp init start...\n"
"[   18.831663] picp: pci not init..\n"
"[   18.893208] picp: picp init start...\n"
"[   18.893340] picp: pci not init..\n"
"[   18.934665] picp: picp init start...\n"
"[   18.934806] picp: pci not init..\n"
"[   20.667877] file system registered\n"
"[   20.741400] dwmac4: Master AXI performs fixed burst length\n"
"[   20.741447] bstgmaceth 30000000.ethernet eth0: Safety Features Fix to 0."
"Hw feature 3\n"
"[   20.741459] bstgmaceth 30000000.ethernet eth0: No Safety Features support "
"found\n"
"[   20.741492] bstgmaceth 30000000.ethernet eth0: IEEE 1588-2008 Advanced "
"Timestamp supported\n"
"[   20.746066] pps pps0: new PPS source ptp0\n"
"[   20.746880] bstgmaceth 30000000.ethernet eth0: registered PTP clock\n"
"[   20.746902] bstgmaceth 30000000.ethernet eth0: configuring for fixed/"
"rgmii link mode\n"
"[   20.756958] bstgmaceth 30000000.ethernet eth0: Link is Up - 1Gbps/Full - "
"flow control off\n"
"[   20.768570] bstgmaceth 30000000.ethernet eth0: Request Tx chan:0 irq:67.\n"
"[   20.768589] bstgmaceth 30000000.ethernet eth0: Request Tx chan:1 irq:68.\n"
"[   20.770788] bstgmaceth 30000000.ethernet eth0: Request Tx chan:2 irq:69.\n"
"[   20.770818] bstgmaceth 30000000.ethernet eth0: Request Tx chan:3 irq:70.\n"
"[   20.776672] bstgmaceth 30000000.ethernet eth0: Request Rx chan:0 irq:63.\n"
"[   20.782635] bstgmaceth 30000000.ethernet eth0: Request Rx chan:1 irq:64.\n"
"[   20.795483] bstgmaceth 30000000.ethernet eth0: Request Rx chan:2 irq:65.\n"
"[   20.801242] bstgmaceth 30000000.ethernet eth0: Request Rx chan:3 irq:66.\n"
"[   20.816356] 8021q: adding VLAN 0 to HW filter on device eth0\n"
"[   20.880677] kauditd_printk_skb: 19 callbacks suppressed\n"
"[   20.880692] audit: type=1130 audit(1675679562.429:43): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=NetworkManager-dispatcher comm=\"systemd\" '\n"
"[   20.913516] EXT4-fs (mmcblk0p5): recovery complete\n"
"[   20.913543] EXT4-fs (mmcblk0p5): mounted filesystem with ordered data "
"mode. Quota mode: none.\n"
"[   21.166231] read descriptors\n"
"[   21.166250] read descriptors\n"
"[   21.166255] read strings\n"
"[   21.303268] bstgmac_ethtool_get_link_ksettings: eth0: PHY is not "
"registered\n"
"[   21.498934] audit: type=1404 audit(1675679563.039:44): enforcing=0 "
"old_enforcing=1 auid=4294967295 ses=4294967295 enabled=1 old-enabled=1 "
"lsm=selinux res=1\n"
"[   21.504209] audit: type=1300 audit(1675679563.039:44): arch=c00000b7 "
"syscall=64 success=yes exit=1 a0=3 a1=7fe032a6d8 a2=1 a3=7fbb55ea78 items=0 "
"ppid=371 pid=633 auid=4294967295 uid=)\n"
"[   21.504921] audit: type=1327 audit(1675679563.039:44): "
"proctitle=736574656E666F7263650030\n"
"[   21.520737] audit: type=1130 audit(1675679563.069:45): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 msg='unit=rc-"
"local comm=\"systemd\" exe=\"/lib/systemd'\n"
"[   21.574655] audit: type=1130 audit(1675679563.119:46): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=getty@tty1 comm=\"systemd\" exe=\"/lib/syste'\n"
"[   21.636310] audit: type=1130 audit(1675679563.179:47): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=serial-getty@ttyS0 comm=\"systemd\" exe=\"/l'\n"
"[   22.202000] audit: type=1130 audit(1675679563.749:48): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=usb-gadget@g1 comm=\"systemd\" exe=\"/lib/sy'\n"
"[   22.310234] bash (697): /proc/173/oom_adj is deprecated, please use /"
"proc/173/oom_score_adj instead.\n"
"\n"
"BSTOS (Operation System by Black Sesame Technologies) 2.3.0.4 a1000 ttyS0\n"
"\n"
"a1000 login: [   23.484629] audit: type=1130 audit(1675679565.029:49): pid=1 "
"uid=0 auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=udsservice_autostart comm=\"s'\n"
"[   23.637773] audit: type=1701 audit(1675679565.179:50): auid=4294967295 "
"uid=0 gid=0 ses=4294967295 subj=system_u:system_r:initrc_t:s0 pid=701 "
"comm=\"uds_service\" exe=\"/usr/bin/uds_serv1\n"
"```"
msgstr ""
"```shell\n"
"baudrate: 115200\n"
"\n"
"Load ATF and UBOOT from Zone A\n"
"\n"
"NOTICE:  BL31: Built : 10:13:03, Mar 30 2023\n"
"\n"
"\n"
"U-Boot 2019.04+2.1.1+g8fc26249.202303300858+ (Mar 30 2023 - 08:58:21 "
"+0800)Bst A1000B, Build: jenkins-a1000_uboot_hvte_rootfs_all-4984\n"
"\n"
"Press 'ctrl+C/c' to stop autoboot:  0\n"
"7020 bytes read in 5 ms (1.3 MiB/s)\n"
"normal mode\n"
"8204856 bytes read in 186 ms (42.1 MiB/s)\n"
"62598 bytes read in 12 ms (5 MiB/s)\n"
"## Loading kernel from FIT Image at 90000000 ...\n"
"   Trying 'kernel' kernel subimage\n"
"     Description:  ArceOS for BST A1000B\n"
"     Type:         Kernel Image\n"
"     Compression:  gzip compressed\n"
"     Data Start:   0x900000fc\n"
"     Data Size:    8143392 Bytes = 7.8 MiB\n"
"     Architecture: AArch64\n"
"     OS:           Linux\n"
"     Load Address: 0x1a0000000\n"
"     Entry Point:  0x1a0000000\n"
"     Hash algo:    md5\n"
"     Hash value:   de3de880d16c71162738fe3a09493347\n"
"     Hash algo:    sha1\n"
"     Hash value:   b1201ff1b8418e5e2f1f27cf2f3daf0275f9a605\n"
"   Verifying Hash Integrity ... md5+ sha1+ OK\n"
"## Flattened Device Tree blob at 80000000\n"
"   Booting using the fdt blob at 0x80000000\n"
"   Uncompressing Kernel Image ... load_buf:00000001a0000000,  "
"image_buf:00000000900000fc\n"
"image_len:7c4220 comp:1\n"
"OK\n"
"   Loading Device Tree to 00000001ce7ed000, end 00000001ce7ff485 ... OK\n"
"enable hyp val 30\n"
"\n"
"Starting kernel ...\n"
"\n"
"\n"
"       d8888                            .d88888b.   .d8888b.\n"
"      d88888                           d88P\" \"Y88b d88P  Y88b\n"
"     d88P888                           888     888 Y88b.\n"
"    d88P 888 888d888  .d8888b  .d88b.  888     888  \"Y888b.\n"
"   d88P  888 888P\"   d88P\"    d8P  Y8b 888     888     \"Y88b.\n"
"  d88P   888 888     888      88888888 888     888       \"888\n"
" d8888888888 888     Y88b.    Y8b.     Y88b. .d88P Y88b  d88P\n"
"d88P     888 888      \"Y8888P  \"Y8888   \"Y88888P\"   \"Y8888P\"\n"
"\n"
"arch = aarch64\n"
"platform = aarch64-bsta1000b-virt-hv\n"
"target = aarch64-unknown-none-softfloat\n"
"build_mode = release\n"
"log_level = info\n"
"smp = 2\n"
"\n"
"[  3.041875 axruntime:130] Logging is enabled.\n"
"[  3.047985 axruntime:131] Primary CPU 0 started, dtb = 0x1ce7ed000.\n"
"[  3.056196 axruntime:133] Found physcial memory regions:\n"
"[  3.063360 axruntime:135]   [PA:0x1a0000000, PA:0x1a0062000) .text (READ | "
"EXECUTE | RESERVED)\n"
"[  3.074146 axruntime:135]   [PA:0x1a0062000, PA:0x1a1901000) .rodata (READ "
"| RESERVED)\n"
"[  3.084172 axruntime:135]   [PA:0x1a1901000, PA:0x1a1909000) .data .tdata ."
"tbss .percpu (READ | WRITE | RESERVED)\n"
"[  3.096775 axruntime:135]   [PA:0x1a1909000, PA:0x1a1989000) boot stack "
"(READ | WRITE | RESERVED)\n"
"[  3.107851 axruntime:135]   [PA:0x1a1989000, PA:0x1a1baf000) .bss (READ | "
"WRITE | RESERVED)\n"
"[  3.118354 axruntime:135]   [PA:0x1a1baf000, PA:0x1b0000000) free memory "
"(READ | WRITE | FREE)\n"
"[  3.129143 axruntime:135]   [PA:0x80000000, PA:0xf0000000) reserved memory "
"(READ | WRITE | EXECUTE | RESERVED)\n"
"[  3.141460 axruntime:135]   [PA:0x1b0000000, PA:0x1f0000000) reserved "
"memory (READ | WRITE | EXECUTE | RESERVED)\n"
"[  3.153968 axruntime:135]   [PA:0x20008000, PA:0x20009000) mmio (READ | "
"WRITE | DEVICE | RESERVED)\n"
"[  3.165139 axruntime:135]   [PA:0x32000000, PA:0x32008000) mmio (READ | "
"WRITE | DEVICE | RESERVED)\n"
"[  3.176310 axruntime:135]   [PA:0x32011000, PA:0x32012000) mmio (READ | "
"WRITE | DEVICE | RESERVED)\n"
"[  3.187481 axruntime:135]   [PA:0x33002000, PA:0x33003000) mmio (READ | "
"WRITE | DEVICE | RESERVED)\n"
"[  3.198652 axruntime:135]   [PA:0x70035000, PA:0x70036000) mmio (READ | "
"WRITE | DEVICE | RESERVED)\n"
"[  3.209824 axruntime:135]   [PA:0x70038000, PA:0x70039000) mmio (READ | "
"WRITE | DEVICE | RESERVED)\n"
"[  3.220994 axruntime:208] Initialize global memory allocator...\n"
"[  3.228824 axruntime:209]   use TLSF allocator.\n"
"[  3.235195 axmm:60] Initialize virtual memory management...\n"
"[  3.263999 axruntime:150] Initialize platform devices...\n"
"[  3.271067 axhal::platform::aarch64_common::gic:67] Initialize GICv2...\n"
"[  3.279717 axtask::api:73] Initialize scheduling...\n"
"[  3.286374 axtask::api:79]   use FIFO scheduler.\n"
"[  3.292742 axhal::platform::aarch64_common::psci:115] Starting CPU 100 "
"ON ...\n"
"[  3.301975 axruntime:176] Initialize interrupt handlers...\n"
"[  3.301975 axruntime::mp:37] Secondary CPU 1 started.\n"
"[  3.309263 axruntime:186] Primary CPU 0 init OK.\n"
"[  3.316168 axruntime::mp:47] Secondary CPU 1 init OK.\n"
"[  3.329406 0:2 arceos_vmm:17] Starting virtualization...\n"
"[  3.336566 0:2 arceos_vmm:19] Hardware support: true\n"
"[  3.343360 0:6 arceos_vmm::vmm::timer:103] Initing HV Timer...\n"
"[  3.349408 1:7 arceos_vmm::vmm::timer:103] Initing HV Timer...\n"
"[  3.351081 0:6 arceos_vmm::hal:117] Hardware virtualization support enabled "
"on core 0\n"
"[  3.358813 1:7 arceos_vmm::hal:117] Hardware virtualization support enabled "
"on core 1\n"
"[  3.378942 0:2 arceos_vmm::vmm::config:34] Creating VM [0] \"linux-a1000\"\n"
"[  3.387547 0:2 axvm::vm:113] Setting up memory region: "
"[0x80000000~0xf0000000] READ | WRITE | EXECUTE\n"
"[  3.398997 0:2 arceos_vmm::hal:27] Failed to allocate memory region "
"[PA:0x80000000~PA:0xf0000000]: NoMemory\n"
"[  3.429479 0:2 axvm::vm:156] Setting up passthrough device memory region: "
"[0x0~0x80000000] -> [0x0~0x80000000]\n"
"[  3.462795 0:2 axvm::vm:191] VM created: id=0\n"
"[  3.468812 0:2 axvm::vm:206] VM setup: id=0\n"
"[  3.474734 0:2 arceos_vmm::vmm::config:41] VM[0] created success, loading "
"images...\n"
"[  3.484473 0:2 arceos_vmm::vmm::images:38] Loading VM images from memory\n"
"[  3.528456 0:2 arceos_vmm::vmm::config:34] Creating VM [1] \"arceos\"\n"
"[  3.536585 0:2 axvm::vm:113] Setting up memory region: "
"[0x1b0000000~0x1b8000000] READ | WRITE | EXECUTE\n"
"[  3.548225 0:2 arceos_vmm::hal:27] Failed to allocate memory region "
"[PA:0x1b0000000~PA:0x1b8000000]: NoMemory\n"
"[  3.561771 0:2 axvm::vm:156] Setting up passthrough device memory region: "
"[0x20008000~0x20009000] -> [0x20008000~0x20009000]\n"
"[  3.575339 0:2 axvm::vm:191] VM created: id=1\n"
"[  3.581443 0:2 axvm::vm:206] VM setup: id=1\n"
"[  3.587364 0:2 arceos_vmm::vmm::config:41] VM[1] created success, loading "
"images...\n"
"[  3.597103 0:2 arceos_vmm::vmm::images:64] Loading VM images from memory\n"
"[  3.605823 0:2 arceos_vmm::vmm:30] Setting up vcpus...\n"
"[  3.612765 0:2 arceos_vmm::vmm::vcpus:178] Initializing VM[0]'s 1 vcpus\n"
"[  3.621353 0:2 arceos_vmm::vmm::vcpus:209] Spawning task for VM[0] Vcpu[0]\n"
"[  3.630239 0:2 arceos_vmm::vmm::vcpus:221] Vcpu task Task(8, \"VM[0]-"
"VCpu[0]\") created cpumask: [1, ]\n"
"[  3.641597 0:2 arceos_vmm::vmm::vcpus:178] Initializing VM[1]'s 1 vcpus\n"
"[  3.648676 1:8 arceos_vmm::vmm::vcpus:242] VM[0] Vcpu[0] waiting for "
"running\n"
"[  3.650188 0:2 arceos_vmm::vmm::vcpus:209] Spawning task for VM[1] Vcpu[0]\n"
"[  3.668141 0:2 arceos_vmm::vmm::vcpus:221] Vcpu task Task(9, \"VM[1]-"
"VCpu[0]\") created cpumask: [0, ]\n"
"[  3.679503 0:2 arceos_vmm::vmm:37] VMM starting, booting VMs...\n"
"[  3.687330 0:2 axvm::vm:273] Booting VM[0]\n"
"[  3.693156 0:2 arceos_vmm::vmm:43] VM[0] boot success\n"
"[  3.698675 1:8 arceos_vmm::vmm::vcpus:245] VM[0] Vcpu[0] running...\n"
"[  3.700029 0:2 axvm::vm:273] Booting VM[1]\n"
"[  3.714064 0:2 arceos_vmm::vmm:43] VM[1] boot success\n"
"[  3.720942 0:9 arceos_vmm::vmm::vcpus:242] VM[1] Vcpu[0] waiting for "
"running\n"
"[  3.730010 0:9 arceos_vmm::vmm::vcpus:245] VM[1] Vcpu[0] running...\n"
"a\n"
"       d8888                            .d88888b.   .d8888b.\n"
"      d88888                           d88P\" \"Y88b d88P  Y88b\n"
"     d88P888                           888     888 Y88b.\n"
"    d88P 888 888d888  .d8888b  .d88b.  888     888  \"Y888b.\n"
"   d88P  888 888P\"   d88P\"    d8P  Y8b 888     888     \"Y88b.\n"
"  d88P   888 888     888      88888888 888     888       \"888\n"
" d8888888888 888     Y88b.    Y8b.     Y88b. .d88P Y88b  d88P\n"
"d88P     888 888      \"Y8888P  \"Y8888   \"Y88888P\"   \"Y8888P\"\n"
"\n"
"arch = aarch64\n"
"platform = aarch64-qemu-virt\n"
"target = aarch64-unknown-none-softfloat\n"
"build_mode = release\n"
"log_level = debug\n"
"smp = 1\n"
"\n"
"[  3.805794 0 axruntime:130] Logging is enabled.\n"
"[  3.812095 0 axruntime:131] Primary CPU 0 started, dtb = 0x0.\n"
"[  3.819733 0 axruntime:133] Found physcial memory regions:\n"
"[  3.827086 0 axruntime:135]   [PA:0x1b0000000, PA:0x1b0007000) .text (READ "
"| EXECUTE | RESERVED)\n"
"[  3.838065 0 axruntime:135]   [PA:0x1b0007000, PA:0x1b0009000) .rodata "
"(READ | RESERVED)\n"
"[  3.848281 0 axruntime:135]   [PA:0x1b0009000, PA:0x1b000d000) .data ."
"tdata .tbss .percpu (READ | WRITE | RESERVED)\n"
"[  3.861076 0 axruntime:135]   [PA:0x1b000d000, PA:0x1b004d000) boot stack "
"(READ | WRITE | RESERVED)\n"
"[  3.872342 0 axruntime:135]   [PA:0x1b004d000, PA:0x1b004e000) .bss (READ | "
"WRITE | RESERVED)\n"
"[  3.883036 0 axruntime:135]   [PA:0x1b004e000, PA:0x1b8000000) free memory "
"(READ | WRITE | FREE)\n"
"[  3.894017 0 axruntime:135]   [PA:0x20008000, PA:0x20009000) mmio (READ | "
"WRITE | DEVICE | RESERVED)\n"
"[  3.905379 0 axruntime:150] Initialize platform devices...\n"
"[  3.912731 0 axruntime:188] Primary CPU 0 init OK.\n"
"Hello, world!\n"
"[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x411fd050]\n"
"[    0.000000] Linux version 6.1.54-rt15-00068-g09f2347c9237 "
"(tanghanwe@ubuntu-virtual-machine) (aarch64-linux-gnu-gcc (Ubuntu 9.4.0-15\n"
"[    0.000000] Machine model: BST A1000B FAD-A\n"
"[    0.000000] earlycon: uart8250 at MMIO32 0x0000000020008000 (options '')\n"
"[    0.000000] printk: bootconsole [uart8250] enabled\n"
"[    0.000000] Invalid option string for rodata: 'n'\n"
"[    0.000000] Reserved memory: created DMA memory pool at "
"0x000000008b000000, size 32 MiB\n"
"[    0.000000] OF: reserved mem: initialized node bst_atf@8b000000, "
"compatible id shared-dma-pool\n"
"[    0.000000] Reserved memory: created DMA memory pool at "
"0x000000008fec0000, size 0 MiB\n"
"[    0.000000] OF: reserved mem: initialized node bst_tee@8fec0000, "
"compatible id shared-dma-pool\n"
"[    0.000000] Reserved memory: created DMA memory pool at "
"0x000000008ff00000, size 1 MiB\n"
"[    0.000000] OF: reserved mem: initialized node bstn_cma@8ff00000, "
"compatible id shared-dma-pool\n"
"[    0.000000] Reserved memory: created DMA memory pool at "
"0x000000009a000000, size 32 MiB\n"
"[    0.000000] OF: reserved mem: initialized node bst_cv_cma@9a000000, "
"compatible id shared-dma-pool\n"
"[    0.000000] Reserved memory: created DMA memory pool at "
"0x000000009c000000, size 16 MiB\n"
"[    0.000000] OF: reserved mem: initialized node vsp@0x9c000000, compatible "
"id shared-dma-pool\n"
"[    0.000000] Reserved memory: created DMA memory pool at "
"0x00000000a1000000, size 16 MiB\n"
"[    0.000000] OF: reserved mem: initialized node bst_isp@0xa1000000, "
"compatible id shared-dma-pool\n"
"[    0.000000] Reserved memory: created CMA memory pool at "
"0x00000000b2000000, size 864 MiB\n"
"[    0.000000] OF: reserved mem: initialized node coreip_pub_cma@0xb2000000, "
"compatible id shared-dma-pool\n"
"[    0.000000] Reserved memory: created CMA memory pool at "
"0x00000000e8000000, size 8 MiB\n"
"[    0.000000] OF: reserved mem: initialized node noc_pmu@0xe8000000, "
"compatible id shared-dma-pool\n"
"[    0.000000] Reserved memory: created CMA memory pool at "
"0x00000000e8800000, size 8 MiB\n"
"[    0.000000] OF: reserved mem: initialized node canfd@0xe8800000, "
"compatible id shared-dma-pool\n"
"[    0.000000] Zone ranges:\n"
"[    0.000000]   DMA      [mem 0x0000000080000000-0x00000000efffffff]\n"
"[    0.000000]   DMA32    empty\n"
"[    0.000000]   Normal   empty\n"
"[    0.000000] Movable zone start for each node\n"
"[    0.000000] Early memory node ranges\n"
"[    0.000000]   node   0: [mem 0x0000000080000000-0x000000008affffff]\n"
"[    0.000000]   node   0: [mem 0x000000008b000000-0x000000008cffffff]\n"
"[    0.000000]   node   0: [mem 0x000000008d000000-0x000000008fcfffff]\n"
"[    0.000000]   node   0: [mem 0x000000008fd00000-0x000000008fdfffff]\n"
"[    0.000000]   node   0: [mem 0x000000008fe00000-0x000000008febffff]\n"
"[    0.000000]   node   0: [mem 0x000000008fec0000-0x00000000b1ffffff]\n"
"[    0.000000]   node   0: [mem 0x00000000b2000000-0x00000000efffffff]\n"
"[    0.000000] Initmem setup node 0 [mem "
"0x0000000080000000-0x00000000efffffff]\n"
"[    0.000000] cma: Reserved 128 MiB at 0x0000000083000000\n"
"[    0.000000] psci: probing for conduit method from DT.\n"
"[    0.000000] psci: Using PSCI v0.1 Function IDs from DT\n"
"[    0.000000] percpu: Embedded 19 pages/cpu s40872 r8192 d28760 u77824\n"
"[    0.000000] Detected VIPT I-cache on CPU0\n"
"[    0.000000] CPU features: detected: Qualcomm erratum 1009, or ARM erratum "
"1286807, 2441009\n"
"[    0.000000] CPU features: detected: ARM errata 1165522, 1319367, or "
"1530923\n"
"[    0.000000] alternatives: applying boot alternatives\n"
"[    0.000000] Built 1 zonelists, mobility grouping on.  Total pages: "
"451584\n"
"[    0.000000] Kernel command line: earlycon=uart8250,mmio32,0x20008000 "
"console=ttyS0,115200n8 memreserve=64M@0xf8000000 rdinit=/sbin/n\n"
"[    0.000000] Unknown kernel command line parameters "
"\"memreserve=64M@0xf8000000\", will be passed to user space.\n"
"[    0.000000] Dentry cache hash table entries: 262144 (order: 9, 2097152 "
"bytes, linear)\n"
"[    0.000000] Inode-cache hash table entries: 131072 (order: 8, 1048576 "
"bytes, linear)\n"
"[    0.000000] mem auto-init: stack:off, heap alloc:off, heap free:off\n"
"[    0.000000] Memory: 148300K/1835008K available (11392K kernel code, 7766K "
"rwdata, 3884K rodata, 1856K init, 2597K bss, 654516K rese)\n"
"[    0.000000] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1\n"
"[    0.000000] rcu: Hierarchical RCU implementation.\n"
"[    0.000000] rcu:     RCU restricting CPUs from NR_CPUS=8 to "
"nr_cpu_ids=1.\n"
"[    0.000000]  Tracing variant of Tasks RCU enabled.\n"
"[    0.000000] rcu: RCU calculated value of scheduler-enlistment delay is 10 "
"jiffies.\n"
"[    0.000000] rcu: Adjusting geometry for rcu_fanout_leaf=16, nr_cpu_ids=1\n"
"[    0.000000] NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0\n"
"[    0.000000] Root IRQ handler: gic_handle_irq\n"
"[    0.000000] rcu: srcu_init: Setting srcu_struct sizes based on "
"contention.\n"
"[    0.000000] arch_timer: cp15 timer(s) running at 325.00MHz (virt).\n"
"[    0.000000] clocksource: arch_sys_counter: mask: 0x7ffffffffffffff "
"max_cycles: 0x4af477f6aa, max_idle_ns: 440795207830 ns\n"
"[    0.000000] sched_clock: 59 bits at 325MHz, resolution 3ns, wraps every "
"4398046511103ns\n"
"[    0.009203] Console: colour dummy device 80x25\n"
"[    0.014105] Calibrating delay loop (skipped), value calculated using "
"timer frequency.. 650.00 BogoMIPS (lpj=3250000)\n"
"[    0.025674] pid_max: default: 32768 minimum: 301\n"
"[    0.030832] LSM: Security Framework initializing\n"
"[    0.035944] SELinux:  Initializing.\n"
"[    0.039963] Mount-cache hash table entries: 4096 (order: 3, 32768 bytes, "
"linear)\n"
"[    0.048098] Mountpoint-cache hash table entries: 4096 (order: 3, 32768 "
"bytes, linear)\n"
"[    0.057524] cacheinfo: Unable to detect cache hierarchy for CPU 0\n"
"[    0.064574] cblist_init_generic: Setting adjustable number of callback "
"queues.\n"
"[    0.072506] cblist_init_generic: Setting shift to 0 and lim to 1.\n"
"[    0.079357] rcu: Hierarchical SRCU implementation.\n"
"[    0.079359] rcu:     Max phase no-delay instances is 1000.\n"
"[    0.079396] printk: bootconsole [uart8250] printing thread started\n"
"[    0.090833] smp: Bringing up secondary CPUs ...\n"
"[    0.090836] smp: Brought up 1 node, 1 CPU\n"
"[    0.090841] SMP: Total of 1 processors activated.\n"
"[    0.090847] CPU features: detected: 32-bit EL0 Support\n"
"[    0.090852] CPU features: detected: Data cache clean to the PoU not "
"required for I/D coherence\n"
"[    0.090856] CPU features: detected: Common not Private translations\n"
"[    0.090858] CPU features: detected: CRC32 instructions\n"
"[    0.090864] CPU features: detected: RCpc load-acquire (LDAPR)\n"
"[    0.090866] CPU features: detected: Privileged Access Never\n"
"[    0.090869] CPU features: detected: RAS Extension Support\n"
"[    0.090920] CPU: All CPU(s) started at EL1\n"
"[    0.090923] alternatives: applying system-wide alternatives\n"
"[    0.092365] devtmpfs: initialized\n"
"[    0.112929] clocksource: jiffies: mask: 0xffffffff max_cycles: "
"0xffffffff, max_idle_ns: 19112604462750000 ns\n"
"[    0.112943] futex hash table entries: 256 (order: 2, 16384 bytes, "
"linear)\n"
"[    0.143754] pinctrl core: initialized pinctrl subsystem\n"
"[    0.144394] NET: Registered PF_NETLINK/PF_ROUTE protocol family\n"
"[    0.145208] DMA: preallocated 256 KiB GFP_KERNEL pool for atomic "
"allocations\n"
"[    0.145267] DMA: preallocated 256 KiB GFP_KERNEL|GFP_DMA pool for atomic "
"allocations\n"
"[    0.145333] DMA: preallocated 256 KiB GFP_KERNEL|GFP_DMA32 pool for "
"atomic allocations\n"
"[    0.328274] printk: console [ttyS0] enabled\n"
"[    0.328278] printk: bootconsole [uart8250] disabled\n"
"[    0.328291] printk: bootconsole [uart8250] printing thread stopped\n"
"[    0.328548] dw-apb-uart 2000a000.serial: uart clock frequency (&p-"
">uartclk):25000000\n"
"[    0.328553] dw-apb-uart 2000a000.serial: uart clock frequency "
"(baudclk):25000000\n"
"[    0.328557] dw-apb-uart 2000a000.serial: uart clock frequency "
"(apb_pclk):100000000\n"
"[    0.328665] 2000a000.serial: ttyS1 at MMIO 0x2000a000 (irq = 32, "
"base_baud = 1562500) is a 16550A\n"
"[    0.328889] dw-apb-uart 20009000.serial: uart clock frequency (&p-"
">uartclk):25000000\n"
"[    0.328894] dw-apb-uart 20009000.serial: uart clock frequency "
"(baudclk):25000000\n"
"[    0.328898] dw-apb-uart 20009000.serial: uart clock frequency "
"(apb_pclk):100000000\n"
"[    0.328996] 20009000.serial: ttyS2 at MMIO 0x20009000 (irq = 33, "
"base_baud = 1562500) is a 16550A\n"
"[    0.329813] =======lt9211_probe in...\n"
"[    0.329816] =======lt9211_probe in1...\n"
"[    0.329818] nlt9211 4-002d: =======lt9211_probe in2...\n"
"[    0.329900] max96789 1-0040: *************MAX96789 RGB To MIPIDSI "
"Config*************\n"
"[    0.329935] printk: console [ttyS0] printing thread started\n"
"[    0.412081] ====update_chnl_id in ...!\n"
"[    0.649752] MAX config start\n"
"[    1.999794] End of MAX config status 0\n"
"[    1.999945] Mali<2>:\n"
"[    1.999947] Inserting Mali v900 device driver.\n"
"[    1.999950] Mali<2>:\n"
"[    1.999950] Compiled: Jan 22 2025, time: 15:53:22.\n"
"[    1.999953] Mali<2>:\n"
"[    1.999954] Driver revision: -6.1.54.REL.B231218-68-g09f2347c9237\n"
"[    1.999956] Mali<2>:\n"
"[    1.999957] mali_module_init() registering driver\n"
"[    2.000028] Mali<2>:\n"
"[    2.000029] mali_probe(): Called for platform device 33300000.gpu\n"
"[    2.000113] Mali<2>:\n"
"[    2.000114] mali-450 device tree detected.\n"
"[    2.000252] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPP2 not found\n"
"[    2.000260] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPPMMU2 not "
"found\n"
"[    2.000265] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPP3 not found\n"
"[    2.000271] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPPMMU3 not "
"found\n"
"[    2.000276] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPP4 not found\n"
"[    2.000282] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPPMMU4 not "
"found\n"
"[    2.000286] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPP5 not found\n"
"[    2.000292] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPPMMU5 not "
"found\n"
"[    2.000297] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPP6 not found\n"
"[    2.000302] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPPMMU6 not "
"found\n"
"[    2.000307] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPP7 not found\n"
"[    2.000311] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPPMMU not "
"found\n"
"[    2.000437] Mali<2>:\n"
"[    2.000439] Mali SWAP: Swap out threshold vaule is 60M\n"
"[    2.000453] Mali<2>:\n"
"[    2.000454] Mali memory settings (shared: 0xFFFFFFFF)\n"
"[    2.000458] Mali<2>:\n"
"[    2.000459] Using device defined frame buffer settings "
"(0x01000000@0xB8000000)\n"
"[    2.000463] Mali<2>:\n"
"[    2.000464] Memory Validator installed for Mali physical address "
"base=0xB8000000, size=0x01000000\n"
"[    2.000469] Mali<2>:\n"
"[    2.000471] Mali PMU: Creating Mali PMU core\n"
"[    2.000477] Mali<2>:\n"
"[    2.000478] Couldn't find pmu_switch_delay in device tree configuration.\n"
"[    2.000481] Mali<2>:\n"
"[    2.000482] Get pmu config from device tree configuration.\n"
"[    2.000484] Mali<2>:\n"
"[    2.000485] Using hw detect pmu config:\n"
"[    2.000488] Mali<2>:\n"
"[    2.000490] domain_config[0] = 0x1\n"
"[    2.000492] Mali<2>:\n"
"[    2.000493] domain_config[1] = 0x2\n"
"[    2.000495] Mali<2>:\n"
"[    2.000496] domain_config[2] = 0x4\n"
"[    2.000498] Mali<2>:\n"
"[    2.000499] domain_config[9] = 0x1\n"
"[    2.000501] Mali<2>:\n"
"[    2.000502] domain_config[10] = 0x2\n"
"[    2.000505] Mali<2>:\n"
"[    2.000506] Mali PM domain: Creating Mali PM domain (mask=0x00000001)\n"
"[    2.000508] Mali<2>:\n"
"[    2.000509] Mali PM domain: Creating Mali PM domain (mask=0x00000002)\n"
"[    2.000511] Mali<2>:\n"
"[    2.000512] Mali PM domain: Creating Mali PM domain (mask=0x00000004)\n"
"[    2.000514] Mali<2>:\n"
"[    2.000515] Mali PM domain: Creating Mali PM domain (mask=0x00001000)\n"
"[    2.000521] Mali<2>:\n"
"[    2.000522] Broadcast: Creating Mali Broadcast unit: Mali_Broadcast\n"
"[    2.000533] Mali<2>:\n"
"[    2.000534] Mali PP: Creating Mali PP core: Mali_PP0\n"
"[    2.000535] Mali<2>:\n"
"[    2.000536] Mali PP: Base address of PP core: 0x33308000\n"
"[    2.000589] Mali<2>:\n"
"[    2.000590] Found Mali GPU Mali-450 MP r0p0\n"
"[    2.000648] Mali<2>:\n"
"[    2.000650] Mali DLBU: Initializing\n"
"[    2.000666] Mali<2>:\n"
"[    2.000667] Mali L2 cache: Created Mali_L2:   8K, 4-way, 64byte cache "
"line, 128bit external bus\n"
"[    2.000675] Mali<2>:\n"
"[    2.000676] Mali L2 cache: Created Mali_L2:  64K, 4-way, 64byte cache "
"line, 128bit external bus\n"
"[    2.000686] Mali<2>:\n"
"[    2.000688] Mali MMU: Creating Mali MMU: Mali_GP_MMU\n"
"[    2.000709] Mali<2>:\n"
"[    2.000711] mali_mmu_probe_irq_acknowledge: intstat 0x3\n"
"[    2.000713] Mali<2>:\n"
"[    2.000714] Probe: Page fault detect: PASSED\n"
"[    2.000716] Mali<2>:\n"
"[    2.000717] Probe: Bus read error detect: PASSED\n"
"[    2.000726] Mali<2>:\n"
"[    2.000727] Mali GP: Creating Mali GP core: Mali_GP\n"
"[    2.000769] Mali<2>:\n"
"[    2.000770] Mali MMU: Creating Mali MMU: Mali_PP0_MMU\n"
"[    2.000789] Mali<2>:\n"
"[    2.000790] mali_mmu_probe_irq_acknowledge: intstat 0x3\n"
"[    2.000792] Mali<2>:\n"
"[    2.000793] Probe: Page fault detect: PASSED\n"
"[    2.000794] Mali<2>:\n"
"[    2.000796] Probe: Bus read error detect: PASSED\n"
"[    2.000804] Mali<2>:\n"
"[    2.000805] Mali PP: Creating Mali PP core: Mali_PP0\n"
"[    2.000806] Mali<2>:\n"
"[    2.000807] Mali PP: Base address of PP core: 0x33308000\n"
"[    2.000838] Mali<2>:\n"
"[    2.000840] Mali MMU: Creating Mali MMU: Mali_PP1_MMU\n"
"[    2.000865] Mali<2>:\n"
"[    2.000867] mali_mmu_probe_irq_acknowledge: intstat 0x3\n"
"[    2.000869] Mali<2>:\n"
"[    2.000870] Probe: Page fault detect: PASSED\n"
"[    2.000871] Mali<2>:\n"
"[    2.000872] Probe: Bus read error detect: PASSED\n"
"[    2.000881] Mali<2>:\n"
"[    2.000882] Mali PP: Creating Mali PP core: Mali_PP1\n"
"[    2.000883] Mali<2>:\n"
"[    2.000884] Mali PP: Base address of PP core: 0x3330a000\n"
"[    2.000909] Mali<2>:\n"
"[    2.000910] Starting new virtual group for MMU PP broadcast core "
"Mali_PP_MMU_Broadcast\n"
"[    2.000912] Mali<2>:\n"
"[    2.000913] Mali DLBU: Creating Mali dynamic load balancing unit: "
"Mali_DLBU\n"
"[    2.000918] Mali<2>:\n"
"[    2.000919] Broadcast: Creating Mali Broadcast unit: Mali_Broadcast\n"
"[    2.000925] Mali<2>:\n"
"[    2.000926] Mali MMU: Creating Mali MMU: Mali_PP_MMU_Broadcast\n"
"[    2.000930] Mali<2>:\n"
"[    2.000931] Mali PP: Creating Mali PP core: Mali_PP_Broadcast\n"
"[    2.000932] Mali<2>:\n"
"[    2.000933] Mali PP: Base address of PP core: 0x33316000\n"
"[    2.000971] Mali<2>:\n"
"[    2.000972] 2+0 PP cores initialized\n"
"[    2.000985] Mali<2>:\n"
"[    2.000987] Mali GPU Timer: 1000\n"
"[    2.000990] Mali<2>:\n"
"[    2.000990] Mali GPU Utilization: No platform utilization handler "
"installed\n"
"[    2.000993] Mali<2>:\n"
"[    2.000994] Mali DVFS init: platform function callback incomplete, need "
"check mali_gpu_device_data in platform .\n"
"[    2.001356] Mali<2>:\n"
"[    2.001358] mali_probe(): Successfully initialized driver for platform "
"device 33300000.gpu\n"
"[    2.001417] Mali:\n"
"[    2.001419] Mali device driver loaded\n"
"[    2.001470] cacheinfo: Unable to detect cache hierarchy for CPU 0\n"
"[    2.006214] brd: module loaded\n"
"[    2.008623] loop: module loaded\n"
"[    2.009038] null_blk: disk nullb0 created\n"
"[    2.009042] null_blk: module loaded\n"
"[    2.009046] dummy-irq: no IRQ given.  Use irq=N\n"
"[    2.010260] slave@0 enforce active low on chipselect handle\n"
"[    2.021387] qspi0-nor0@0 enforce active low on chipselect handle\n"
"[    2.179081] spi-nor spi6.0: w25q256jw (32768 Kbytes)\n"
"[    2.179172] 2 fixed-partitions partitions found on MTD device spi6.0\n"
"[    2.179176] Creating 2 MTD partitions on \"spi6.0\":\n"
"[    2.179189] 0x000000000000-0x000001e00000 : \"nor0_part0\"\n"
"[    2.179739] 0x000001e00000-0x000002000000 : \"nor0_part1\"\n"
"[    2.181991] bst_canfd 20016000.canfd: Driver registered: "
"regs=0xffffffc009f54000, irq=44, clock=200000000\n"
"[    2.182428] bst_canfd 20016800.canfd: Driver registered: "
"regs=0xffffffc009f58800, irq=45, clock=200000000\n"
"[    2.182935] bst_canfd 20017000.canfd: Driver registered: "
"regs=0xffffffc009f5c000, irq=46, clock=200000000\n"
"[    2.183054] CAN device driver interface\n"
"[    2.183100] usbcore: registered new interface driver asix\n"
"[    2.183131] usbcore: registered new interface driver ax88179_178a\n"
"[    2.183156] usbcore: registered new interface driver cdc_ether\n"
"[    2.183175] usbcore: registered new interface driver net1080\n"
"[    2.183192] usbcore: registered new interface driver cdc_subset\n"
"[    2.183208] usbcore: registered new interface driver zaurus\n"
"[    2.183239] usbcore: registered new interface driver cdc_ncm\n"
"[    2.183263] usbcore: registered new interface driver r8153_ecm\n"
"[    2.183804] dwc3,usb:dwc3_set_reqinfo_len,1082\n"
"[    2.190672] bst-dwc3 amba_apu@0:usb2: usb30 could not find power control "
"gpio.\n"
"[    2.190896] dwc3,usb:dwc3_set_reqinfo_len,1082\n"
"[    2.191939] xhci-hcd xhci-hcd.0.auto: xHCI Host Controller\n"
"[    2.191956] xhci-hcd xhci-hcd.0.auto: new USB bus registered, assigned "
"bus number 1\n"
"[    2.192359] xhci-hcd xhci-hcd.0.auto: hcc params 0x0220fe64 hci version "
"0x110 quirks 0x0000000000010010\n"
"[    2.192392] xhci-hcd xhci-hcd.0.auto: irq 47, io mem 0x30200000\n"
"[    2.192515] xhci-hcd xhci-hcd.0.auto: xHCI Host Controller\n"
"[    2.192523] xhci-hcd xhci-hcd.0.auto: new USB bus registered, assigned "
"bus number 2\n"
"[    2.192530] xhci-hcd xhci-hcd.0.auto: Host supports USB 3.0 SuperSpeed\n"
"[    2.192901] hub 1-0:1.0: USB hub found\n"
"[    2.192934] hub 1-0:1.0: 1 port detected\n"
"[    2.193097] usb usb2: We don't know the algorithms for LPM for this host, "
"disabling LPM.\n"
"[    2.193357] hub 2-0:1.0: USB hub found\n"
"[    2.193381] hub 2-0:1.0: 1 port detected\n"
"[    2.193626] usbcore: registered new interface driver uas\n"
"[    2.193670] usbcore: registered new interface driver usb-storage\n"
"[    2.193736] usbcore: registered new interface driver option\n"
"[    2.193749] usbserial: USB Serial support registered for GSM modem (1-"
"port)\n"
"[    2.193848] gadgetfs: USB Gadget filesystem, version 24 Aug 2004\n"
"[    2.193950] i2c_dev: i2c /dev entries driver\n"
"[    2.194458] bst,maxim-deser-hub 2-0029: maxim_hub_parse_dt() line:1255 "
"GMSL2\n"
"[    2.194468] bst,maxim-deser-hub 2-0029: lane-num = 2\n"
"[    2.194491] bst,maxim-deser-hub 2-0029: trigger-tx-gpio index0  = 8\n"
"[    2.194496] bst,maxim-deser-hub 2-0029: camera index is 0,ser is 42,"
"ser_alias is 60,sensor addr is 36, sensor_i2c_addr_alias is 70\n"
"[    2.194505] bst,maxim-deser-hub 2-0029: parse_input_dt:: input device1 "
"not found\n"
"[    2.194515] bst,maxim-deser-hub 2-0029: parse_input_dt:: input device2 "
"not found\n"
"[    2.194527] bst,maxim-deser-hub 2-0029: parse_input_dt:: input device3 "
"not found\n"
"[    2.246055] bst,maxim-deser-hub 2-0029: read_back REG_ENABLE : 0x14\n"
"[    2.251854] bst,maxim-deser-hub 2-0029: read_back REG_MNL : 0x10\n"
"[    2.251864] bst,maxim-deser-hub 2-0029: maxim_hub_probe: lock gpio -2 is "
"invalid\n"
"[    2.359981] maxim hub probe done\n"
"[    2.360116] bst,maxim-deser-hub 2-002a: maxim_hub_parse_dt() line:1255 "
"GMSL2\n"
"[    2.360136] bst,maxim-deser-hub 2-002a: trigger-tx-gpio index0  = 0\n"
"[    2.360141] bst,maxim-deser-hub 2-002a: camera index is 0,ser is 42,"
"ser_alias is 64,sensor addr is 36, sensor_i2c_addr_alias is 54\n"
"[    2.360156] bst,maxim-deser-hub 2-002a: trigger-tx-gpio index1  = 0\n"
"[    2.360161] bst,maxim-deser-hub 2-002a: camera index is 1,ser is 42,"
"ser_alias is 65,sensor addr is 36, sensor_i2c_addr_alias is 55\n"
"[    2.360177] bst,maxim-deser-hub 2-002a: trigger-tx-gpio index2  = 0\n"
"[    2.360182] bst,maxim-deser-hub 2-002a: camera index is 2,ser is 42,"
"ser_alias is 66,sensor addr is 36, sensor_i2c_addr_alias is 56\n"
"[    2.360198] bst,maxim-deser-hub 2-002a: trigger-tx-gpio index3  = 0\n"
"[    2.360203] bst,maxim-deser-hub 2-002a: camera index is 3,ser is 42,"
"ser_alias is 67,sensor addr is 36, sensor_i2c_addr_alias is 57\n"
"[    2.428511] bst,maxim-deser-hub 2-002a: read_back REG_ENABLE : 0x14\n"
"[    2.435440] bst,maxim-deser-hub 2-002a: read_back REG_MNL : 0x10\n"
"[    2.435449] bst,maxim-deser-hub 2-002a: maxim_hub_probe: lock gpio -2 is "
"invalid\n"
"[    2.543722] maxim hub probe done\n"
"[    2.543952] bst,maxim-deser-hub 2-002e: maxim_hub_parse_dt() line:1255 "
"GMSL2\n"
"[    2.543960] bst,maxim-deser-hub 2-002e: lane-num = 2\n"
"[    2.543975] bst,maxim-deser-hub 2-002e: trigger-tx-gpio index0  = 8\n"
"[    2.543980] bst,maxim-deser-hub 2-002e: camera index is 0,ser is 42,"
"ser_alias is 48,sensor addr is 36, sensor_i2c_addr_alias is 58\n"
"[    2.543990] bst,maxim-deser-hub 2-002e: parse_input_dt:: input device1 "
"not found\n"
"[    2.543995] bst,maxim-deser-hub 2-002e: parse_input_dt:: input port2 not "
"found\n"
"[    2.543995]\n"
"[    2.544000] bst,maxim-deser-hub 2-002e: parse_input_dt:: input port3 not "
"found\n"
"[    2.544000]\n"
"[    2.596048] i2c_transfer error, slave = 0x2e, reg = 0x17, ret = -121\n"
"[    2.617712] i2c_transfer error, slave = 0x2e, reg = 0x17, ret = -121\n"
"[    2.628477] i2c_transfer error, slave = 0x2e, reg = 0x17, ret = -121\n"
"[    2.633481] write_reg() line:177, write 2e:[17,14]failed!\n"
"[    2.633486] bst,maxim-deser-hub 2-002e: max96712_reg_write: write 0x17 "
"failed\n"
"[    2.641093] i2c_transfer error, slave = 0x2e, reg = 0x19, ret = -121\n"
"[    2.648385] i2c_transfer error, slave = 0x2e, reg = 0x19, ret = -121\n"
"[    2.656981] i2c_transfer error, slave = 0x2e, reg = 0x19, ret = -121\n"
"[    2.661984] write_reg() line:177, write 2e:[19,10]failed!\n"
"[    2.661988] bst,maxim-deser-hub 2-002e: max96712_reg_write: write 0x19 "
"failed\n"
"[    2.669782] i2c_transfer error, slave = 0x2e, reg = 0x17, ret = -121\n"
"[    2.681765] i2c_transfer error, slave = 0x2e, reg = 0x17, ret = -121\n"
"[    2.699231] i2c_transfer error, slave = 0x2e, reg = 0x17, ret = -121\n"
"[    2.704236] bst,maxim-deser-hub 2-002e: max96712_reg_read() line:256, "
"read 0x2e:[0x17,0x74]failed!\n"
"[    2.704241] bst,maxim-deser-hub 2-002e: read_back REG_ENABLE : 0x74\n"
"[    2.706534] i2c_transfer error, slave = 0x2e, reg = 0x19, ret = -121\n"
"[    2.721833] i2c_transfer error, slave = 0x2e, reg = 0x19, ret = -121\n"
"[    2.730518] i2c_transfer error, slave = 0x2e, reg = 0x19, ret = -121\n"
"[    2.735523] bst,maxim-deser-hub 2-002e: max96712_reg_read() line:256, "
"read 0x2e:[0x19,0x74]failed!\n"
"[    2.735529] bst,maxim-deser-hub 2-002e: read_back REG_MNL : 0x74\n"
"[    2.735538] bst,maxim-deser-hub 2-002e: maxim_hub_probe: lock gpio -2 is "
"invalid\n"
"[    2.741656] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    2.752880] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    2.761914] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    2.766918] bst,maxim-deser-hub 2-002e: max96712_reg_read() line:256, "
"read 0x2e:[0x0,0x0]failed!\n"
"[    2.807958] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    2.818290] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    2.832877] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    2.837882] bst,maxim-deser-hub 2-002e: max96712_reg_read() line:256, "
"read 0x2e:[0x0,0x0]failed!\n"
"[    2.878198] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    2.888876] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    2.899817] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    2.904822] bst,maxim-deser-hub 2-002e: max96712_reg_read() line:256, "
"read 0x2e:[0x0,0x0]failed!\n"
"[    2.951156] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    2.965569] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    2.989650] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    2.994655] bst,maxim-deser-hub 2-002e: max96712_reg_read() line:256, "
"read 0x2e:[0x0,0x0]failed!\n"
"[    3.035950] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    3.059508] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    3.068798] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    3.073802] bst,maxim-deser-hub 2-002e: max96712_reg_read() line:256, "
"read 0x2e:[0x0,0x0]failed!\n"
"[    3.118634] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    3.131052] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    3.142345] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121\n"
"[    3.147350] bst,maxim-deser-hub 2-002e: max96712_reg_read() line:256, "
"read 0x2e:[0x0,0x0]failed!\n"
"[    3.189046] bst,maxim-deser-hub 2-002e: detect max96712 timeout\n"
"[    3.189049] bst,maxim-deser-hub 2-002e: maxim_hub_probe: not found "
"max96712\n"
"[    3.189058] bst,maxim-deser-hub: probe of 2-002e failed with error -22\n"
"[    3.189676] a1000-csi2 csi@0: a1000_csi_probe\n"
"[    3.189682] a1000-csi2 csi@0: a1000_csi_probe\n"
"[    3.189708] mipi chn 0 connected\n"
"[    3.189712] mipi chn 1 connected\n"
"[    3.189716] mipi chn 2 connected\n"
"[    3.189719] mipi chn 3 connected\n"
"[    3.189835] a1000-csi2 csi@1: a1000_csi_probe\n"
"[    3.189840] a1000-csi2 csi@1: a1000_csi_probe\n"
"[    3.189861] mipi chn 0 connected\n"
"[    3.189865] mipi chn 1 connected\n"
"[    3.189869] mipi chn 2 connected\n"
"[    3.189873] mipi chn 3 connected\n"
"[    3.189971] a1000-csi2 csi@3: a1000_csi_probe\n"
"[    3.189976] a1000-csi2 csi@3: a1000_csi_probe\n"
"[    3.189993] mipi chn 0 connected\n"
"[    3.189997] mipi chn 1 connected\n"
"[    3.190000] mipi chn 2 not connected\n"
"[    3.190003] mipi chn 3 not connected\n"
"[    3.190172] bst_wdt 2001b000.watchdog: wdt bst_wdt_drv_probe, 517\n"
"[    3.190935] bst_wdt 2001c000.watchdog: wdt bst_wdt_drv_probe, 517\n"
"[    3.191072] bst_wdt 2001d000.watchdog: wdt bst_wdt_drv_probe, 517\n"
"[    3.191202] bst_wdt 32009000.watchdog: wdt bst_wdt_drv_probe, 517\n"
"[    3.191405] bst_wdt 3200a000.watchdog: wdt bst_wdt_drv_probe, 517\n"
"[    3.191578] bst_wdt 3200b000.watchdog: wdt bst_wdt_drv_probe, 517\n"
"[    3.191752] bst_wdt 3200c000.watchdog: wdt bst_wdt_drv_probe, 517\n"
"[    3.191939] bst_wdt 3200d000.watchdog: wdt bst_wdt_drv_probe, 517\n"
"[    3.192109] bst_wdt 3200e000.watchdog: wdt bst_wdt_drv_probe, 517\n"
"[    3.192301] bst_wdt 3200f000.watchdog: wdt bst_wdt_drv_probe, 517\n"
"[    3.192467] bst_wdt 32010000.watchdog: wdt bst_wdt_drv_probe, 517\n"
"[    3.192774] sdhci: Secure Digital Host Controller Interface driver\n"
"[    3.192777] sdhci: Copyright(c) Pierre Ossman\n"
"[    3.192778] sdhci-pltfm: SDHCI platform and OF driver helper\n"
"[    3.192969] sdhci-dwcmshc 30400000.dwmmc0: dwcmshc_probe\n"
"[    3.257851] mmc0: SDHCI controller on 30400000.dwmmc0 [30400000.dwmmc0] "
"using ADMA\n"
"[    3.258001] sdhci-dwcmshc 30500000.dwmmc1: dwcmshc_probe\n"
"[    3.504668] mmc0: new high speed MMC card at address 0001\n"
"[    3.505324] mmcblk0: mmc0:0001 CJUD4R 59.6 GiB\n"
"[    3.577787]  mmcblk0: p1 p2 p3 p4 p5 p6 p7 p8 p9 p10\n"
"[    3.579269] mmcblk0boot0: mmc0:0001 CJUD4R 31.9 MiB\n"
"[    3.581351] mmcblk0boot1: mmc0:0001 CJUD4R 31.9 MiB\n"
"[    3.595544] mmcblk0rpmb: mmc0:0001 CJUD4R 4.00 MiB, chardev (239:0)\n"
"[    4.339768] i2c_designware 20005000.i2c: controller timed out\n"
"[    4.339788] sdhci_bst_i2c_write_bytes: i2c write failed: -110\n"
"[    5.379754] i2c_designware 20005000.i2c: controller timed out\n"
"[    5.379760] sdhci_bst_i2c_read_bytes:  i2c read 1 bytes from client@0x8 "
"starting at reg 0x8d failed, error: -110\n"
"[    5.379765] sdhci_bst_i2c_voltage_sel: i2c test failed readdata: 255 send "
"data:1\n"
"[    5.379768] sdhci_bst_voltage_switch failed\n"
"[    5.418222] mmc1: SDHCI controller on 30500000.dwmmc1 [30500000.dwmmc1] "
"using ADMA\n"
"[    5.418423] hid: raw HID events driver (C) Jiri Kosina\n"
"[    5.418636] optee: probing for conduit method.\n"
"[    5.418663] optee: revision 3.11 (28993363)\n"
"[    5.419063] optee: initialized driver\n"
"[    5.419965] netem: version 1.3\n"
"[    5.419985] u32 classifier\n"
"[    5.419986]     Performance counters on\n"
"[    5.419987]     input device check on\n"
"[    5.419988]     Actions configured\n"
"[    5.420100] ipip: IPv4 and MPLS over IPv4 tunneling driver\n"
"[    5.420443] gre: GRE over IPv4 demultiplexor driver\n"
"[    5.420810] NET: Registered PF_INET6 protocol family\n"
"[    5.434247] Segment Routing with IPv6\n"
"[    5.434270] In-situ OAM (IOAM) with IPv6\n"
"[    5.434305] sit: IPv6, IPv4 and MPLS over IPv4 tunneling driver\n"
"[    5.434904] NET: Registered PF_PACKET protocol family\n"
"[    5.434908] can: controller area network core\n"
"[    5.434948] NET: Registered PF_CAN protocol family\n"
"[    5.434953] can: raw protocol\n"
"[    5.434959] 8021q: 802.1Q VLAN Support v1.8\n"
"[    5.435003] sctp: Hash tables configured (bind 256/256)\n"
"[    5.435180] Key type dns_resolver registered\n"
"[    5.435268] ipc 4fec00000.ipc: assigned reserved memory node "
"bstn_cma@8ff00000\n"
"[    5.435621] Loading compiled-in X.509 certificates\n"
"[    5.510900] [bst_cv]: bst_cv_probe 48: BST_CV driver initializing ...\n"
"[    5.510916] [bst_cv]: bst_cv_probe 66: bst_sysfile_init OK\n"
"[    5.510923] [bst_cv]: bst_cv_mem_manager_init 307: phys_to_bus_offset: "
"0x0\n"
"[    5.510928] [bst_cv]: bst_cv_mem_manager_init 314: dma_set_coherent_mask "
"OK.\n"
"[    5.511059] bst_cv 51030000.bst_cv: assigned reserved memory node "
"bst_cv_cma@9a000000\n"
"[    5.511063] [bst_cv]: bst_cv_mem_manager_init 328: kern_sub_phys_offset: "
"0xffffffbf78000000\n"
"[    5.511068] [bst_cv]: bst_cv_probe 74: bst_cv_mem_manager_init OK\n"
"[    5.511111] [bst_cv]: bst_cv_probe 82: bst_cv_fw_manager_init OK\n"
"[    5.511184] [bst_cv]: bst_cv_probe 90: bst_cv_misc_init OK, /dev/bst_cv "
"registered\n"
"[    5.511188] [bst_cv]: bst_cv_probe 96: bst_cv probe completed!\n"
"[    5.511304] [bst_lwnn]: bst_lwnn_probe 74: bst_lwnn driver "
"initializing ...\n"
"[    5.511321] [bst_lwnn]: bst_lwnn_probe 93: bst_sysfile_init OK, /sys/"
"kernel/bst_lwnn registered\n"
"[    5.511327] [bst_lwnn]: bst_lwnn_mem_manager_init 346: "
"phys_to_bus_offset: 0x0\n"
"[    5.511331] [bst_lwnn]: bst_lwnn_mem_manager_init 353: "
"dma_set_coherent_mask OK.\n"
"[    5.511355] bst_lwnn 51030000.bst_lwnn: assigned reserved memory node "
"coreip_pub_cma@0xb2000000\n"
"[    5.511360] [bst_lwnn]: bst_lwnn_probe 101: bst_lwnn_mem_manager_init OK\n"
"[    5.511700] [bst_lwnn]: bst_lwnn_probe 109: bst_lwnn_fw_manager_init OK\n"
"[    5.511751] [bst_lwnn]: bst_lwnn_msg_manager_init 302: ipc_init OK\n"
"[    5.511871] [bst_lwnn]: bst_lwnn_msg_manager_init 334: worker creation "
"OK\n"
"[    5.511876] [bst_lwnn]: bst_lwnn_probe 117: bst_lwnn_msg_manager_init OK\n"
"[    5.511936] [bst_lwnn]: bst_lwnn_probe 125: bst_lwnn_misc_init OK, /dev/"
"bst_lwnn registered\n"
"[    5.511941] [bst_lwnn]: bst_lwnn_probe 133: bst_lwnn probe completed!\n"
"[    5.512064] [bstn]: bstn_probe 50: BSTN driver initializing ...\n"
"[    5.512068] [bstn]: bstn_probe 51: timeout_jiffies: 3200, timeout_ms "
"32000\n"
"[    5.512077] [bstn]: bstn_mem_manager_init 310: phys_to_bus_offset: 0x0\n"
"[    5.512083] [bstn]: bstn_mem_manager_init 324: reserved memory: base "
"0xb2000000 size 0x36000000\n"
"[    5.512088] [bstn]: bstn_mem_manager_init 333: dma_set_mask OK.\n"
"[    5.512091] [bstn]: bstn_mem_manager_init 340: dma_set_coherent_mask OK.\n"
"[    5.512097] bstn 50020000.bstn: assigned reserved memory node "
"coreip_pub_cma@0xb2000000\n"
"[    5.512101] [bstn]: bstn_probe 76: bstn_mem_manager_init OK\n"
"[    5.512119] [bstn]: bstn_fw_manager_init 300: firmware: bstn_dsp_rtos."
"rbf\n"
"[    5.512165] [bstn]: bstn_fw_manager_init 320: assigned mem: "
"0xffffffc00a232000, 0xb2005000, size: 4096\n"
"[    5.512172] [bstn]: bstn_probe 84: bstn_fw_manager_init OK\n"
"[    5.512180] [bstn]: bstn_msg_manager_init 238: ipc_init OK\n"
"[    5.512203] [bstn]: bstn_msg_manager_init 262: req_bufs @ "
"phys:0xb2006000\n"
"[    5.512258] [bstn]: bstn_msg_manager_init 286: bstn_msg_receiver task "
"created 0xffffff800e434380\n"
"[    5.512263] [bstn]: bstn_probe 92: bstn_msg_manager_init OK\n"
"[    5.512273] [bstn]: bstn_probe 100: bstn_sysfile_init OK\n"
"[    5.512344] [bstn]: bstn_probe 108: bstn_misc_init OK, device[bstn0] "
"registered\n"
"[    5.512348] [bstn]: bstn_probe 111: BSTN v2.5.3 probe completed\n"
"[    5.537056] bst_identify_probe\n"
"[    5.537343] vsp-ipc 9c000000.ipc_vsp: assigned reserved memory node "
"vsp@0x9c000000\n"
"[    5.537379] init start = 0x9c200000, initp_size = 0x20660, align size = "
"0x21000\n"
"[    5.537384] cmdp start = 0x9c221000, cmdp_size = 0x2098a0, align size = "
"0x20a000\n"
"[    5.537387] slab start = 0x9c500000, end = 0x9c600000, slab_size = "
"0x100000\n"
"[    5.537390] total_alloc_size = 0x600000\n"
"[    5.538507] c0.base  = (____ptrval____), c1.base  = (____ptrval____), c2."
"base  = (____ptrval____)\n"
"[    5.560295] enter recv\n"
"[    5.560318] printk: console [netcon0] enabled\n"
"[    5.560321] netconsole: network logging started\n"
"[    5.560934] bstgmaceth 30000000.ethernet: error -ENXIO: IRQ rx_chan4_irq "
"not found\n"
"[    5.561038] bstgmaceth 30000000.ethernet: error -ENXIO: IRQ tx_chan4_irq "
"not found\n"
"[    5.561208] printk: console [netcon0] printing thread started\n"
"[    5.573255] bstgmaceth 30000000.ethernet: User ID: 0x10, Synopsys ID: "
"0x51\n"
"[    5.573264] bstgmaceth 30000000.ethernet:    DWMAC4/5\n"
"[    5.573270] bstgmaceth 30000000.ethernet: DMA HW capability register "
"supported\n"
"[    5.573273] bstgmaceth 30000000.ethernet: RX Checksum Offload Engine "
"supported\n"
"[    5.573276] bstgmaceth 30000000.ethernet: TX Checksum insertion "
"supported\n"
"[    5.573289] bstgmaceth 30000000.ethernet (unnamed net_device) "
"(uninitialized): device MAC address 6a:78:6a:e9:b1:c2\n"
"[    5.573298] bstgmaceth 30000000.ethernet: Enabled Flow TC (entries=2)\n"
"[    5.574338] bstgmaceth 30100000.ethernet: error -ENXIO: IRQ rx_chan4_irq "
"not found\n"
"[    5.574444] bstgmaceth 30100000.ethernet: error -ENXIO: IRQ tx_chan4_irq "
"not found\n"
"[    5.574803] bstgmaceth 30100000.ethernet: User ID: 0x10, Synopsys ID: "
"0x51\n"
"[    5.574810] bstgmaceth 30100000.ethernet:    DWMAC4/5\n"
"[    5.574814] bstgmaceth 30100000.ethernet: DMA HW capability register "
"supported\n"
"[    5.574817] bstgmaceth 30100000.ethernet: RX Checksum Offload Engine "
"supported\n"
"[    5.574821] bstgmaceth 30100000.ethernet: TX Checksum insertion "
"supported\n"
"[    5.574830] bstgmaceth 30100000.ethernet (unnamed net_device) "
"(uninitialized): device MAC address 7e:fc:7a:ea:0f:1c\n"
"[    5.574836] bstgmaceth 30100000.ethernet: Enabled Flow TC (entries=2)\n"
"[    6.043844] mdio_bus bstgmac-1: MDIO device at address 7 is missing.\n"
"[    6.044017] bstgmaceth 30100000.ethernet: Cannot register the MDIO bus "
"err -19\n"
"[    6.044022] bstgmaceth 30100000.ethernet: bstgmac_dvr_probe: MDIO bus "
"(id: 1) registration failed\n"
"[    6.044409] a1000_isp isp: isp_probe\n"
"[    6.044415] a1000_isp isp: isp_probe\n"
"[    6.044520] a1000_isp isp: init_isp_channel_devs channel 10 not enabled, "
"skip\n"
"[    6.044525] a1000_isp isp: init_isp_channel_devs channel 11 not enabled, "
"skip\n"
"[    6.044679] deser_notify_bound(),line 1069 channel[3]\n"
"[    6.044687] deser_notify_bound(),line 1069 channel[2]\n"
"[    6.044693] deser_notify_bound(),line 1069 channel[1]\n"
"[    6.044697] deser_notify_bound(),line 1069 channel[0]\n"
"[    6.044709] deser_notify_bound(),line 1069 channel[0]\n"
"[    6.044744] a1000_isp isp: assigned reserved memory node "
"bst_isp@0xa1000000\n"
"[    6.045519] Enter dphy_config\n"
"[    6.045534] dphyTst_setCfg_lanes\n"
"[    6.279753]\n"
"[    6.279753] DPHY_SHUTDOWNZ(40) = 0\n"
"[    6.279756]\n"
"[    6.279756] DPHY lane_speed = 1600\n"
"[    6.279808]\n"
"[    6.279808] reg e5 value is 0x1\n"
"[    6.279814]\n"
"[    6.279814] reg 1ac value is 0x4b\n"
"[    6.279820] nreg e4 value is 0x11\n"
"[    6.279825]\n"
"[    6.279825] reg 8 value is 0x18\n"
"[    6.279827]\n"
"[    6.279827] DPHY_N_LANES(4) = 3(ENABLE RX)\n"
"[    6.279829]\n"
"[    6.279829] force rxmode = 0x3c0030\n"
"[    6.279831] dphyTst_release\n"
"[    6.279832]\n"
"[    6.279832] DPHY_SHUTDOWNZ(40) = 1\n"
"[    6.279834]\n"
"[    6.279834] DPHY_RSTZ(44) = 1\n"
"[    6.345208] dphyTst_release timeout\n"
"[    6.345211]\n"
"[    6.345211] dphy0 enable done.\n"
"[    6.345212] dphyTst_release_1_4lane\n"
"[    6.345214]\n"
"[    6.345214] DPHY_1_RSTZ = 3c003c\n"
"[    6.347220]\n"
"[    6.347220] dphy0 and dphy1 enter stopstate.\n"
"[    6.347222]\n"
"[    6.347222] release force rxmode = 0x3c\n"
"[    6.347224] dphyTst_release_1_4lane finish\n"
"[    6.347238] bst,maxim-deser-hub 2-002a: maxim_hub_s_power() line:986\n"
"[    6.347244] bst,maxim-deser-hub 2-002a: maxim_hub_s_power() line:1007 "
"GMSL2\n"
"[    6.407974] bst,maxim-deser-hub 2-002a: max967XX_replicate_mode() "
"line:509\n"
"[    6.408170] bst,maxim-deser-hub 2-002a: max96712_fsync_config() line:436, "
"tr0\n"
"[    6.408938] bst,maxim-deser-hub 2-002a: INTERNAL TRIGGER MODE\n"
"[    6.409702] bst,maxim-deser-hub 2-002a: trig_info.trigger_tx_gpio[0] = 0\n"
"[    6.416644] bst,maxim-deser-hub 2-002a: modify_serdes_address() 254\n"
"[    6.750420] bst,maxim-deser-hub 2-002a: is_gmsl2_video_connected() index "
"= 0d\n"
"[    6.811052] bst,maxim-deser-hub 2-002a: is_gmsl2_video_connected() index "
"= 1d\n"
"[    6.871687] bst,maxim-deser-hub 2-002a: is_gmsl2_video_connected() index "
"= 2d\n"
"[    6.932321] bst,maxim-deser-hub 2-002a: is_gmsl2_video_connected() index "
"= 3d\n"
"\n"
"CTRL-A Z for help | 115200 8N1 | NOR | Minicom 2.9 | VT102 | Offline | "
"ttyUSB0\n"
"[    7.166303] bst,maxim-deser-hub 2-002a: is_gmsl2_video_connected() index "
"= 0, not linked\n"
"[    7.226936] bst,maxim-deser-hub 2-002a: is_gmsl2_video_connected() index "
"= 1, not linked\n"
"[    7.287571] bst,maxim-deser-hub 2-002a: is_gmsl2_video_connected() index "
"= 2, not linked\n"
"[    7.348212] bst,maxim-deser-hub 2-002a: is_gmsl2_video_connected() index "
"= 3, not linked\n"
"[    7.456521] bst,maxim-deser-hub 2-002a: Failed to request irq 0\n"
"[    7.456526] bst,maxim-deser-hub 2-002a: maxim_hub_s_power(), line 1034, "
"max96712 s_power success!\n"
"[    7.456540] Enter dphy_config\n"
"[    7.456555] dphyTst_setCfg_lanes\n"
"[    7.689752]\n"
"[    7.689752] DPHY_SHUTDOWNZ(40) = 0\n"
"[    7.689755]\n"
"[    7.689755] DPHY lane_speed = 2400\n"
"[    7.689808]\n"
"[    7.689808] reg e5 value is 0x1\n"
"[    7.689813]\n"
"[    7.689813] reg 1ac value is 0x4b\n"
"[    7.689819] nreg e4 value is 0x11\n"
"[    7.689825]\n"
"[    7.689825] reg 8 value is 0x18\n"
"[    7.689827]\n"
"[    7.689827] DPHY_N_LANES(4) = 1(ENABLE RX)\n"
"[    7.689829]\n"
"[    7.689829] force rxmode = 0x3c0030\n"
"[    7.689831] dphyTst_release\n"
"[    7.689832]\n"
"[    7.689832] DPHY_SHUTDOWNZ(40) = 1\n"
"[    7.689834]\n"
"[    7.689834] DPHY_RSTZ(44) = 1\n"
"[    7.755201] dphyTst_release timeout\n"
"[    7.755203]\n"
"[    7.755203] dphy0 enable done.\n"
"[    7.755204] dphyTst_release_1_4lane\n"
"[    7.755206]\n"
"[    7.755206] DPHY_1_RSTZ = 3c003c\n"
"[    7.803760] dphyTst_release_1_4lane timeout\n"
"[    7.803762]\n"
"[    7.803762] dphy0 and dphy1 enter stopstate.\n"
"[    7.803764]\n"
"[    7.803764] release force rxmode = 0x3c\n"
"[    7.803765] dphyTst_release_1_4lane finish\n"
"[    7.803777] bst,maxim-deser-hub 2-0029: maxim_hub_s_power() line:986\n"
"[    7.803782] bst,maxim-deser-hub 2-0029: maxim_hub_s_power() line:1007 "
"GMSL2\n"
"[    7.853309] bst,maxim-deser-hub 2-0029: max967XX_replicate_mode() "
"line:509\n"
"[    7.853506] bst,maxim-deser-hub 2-0029: max96712_fsync_config() line:436, "
"trig_info->trigger_tx_gpio[0] = 8\n"
"[    7.854272] bst,maxim-deser-hub 2-0029: INTERNAL TRIGGER MODE\n"
"[    7.855036] bst,maxim-deser-hub 2-0029: trig_info.trigger_tx_gpio[0] = 8\n"
"[    7.855231] bst,maxim-deser-hub 2-0029: modify_serdes_address() 254\n"
"[    8.196057] bst,maxim-deser-hub 2-0029: is_gmsl2_video_connected() index "
"= 0, not linked\n"
"[    8.196062] modify_serdes_address() cam_dev [1] is NULL, break\n"
"[    8.196064] modify_serdes_address() cam_dev [2] is NULL, break\n"
"[    8.196066] modify_serdes_address() cam_dev [3] is NULL, break\n"
"[    8.447360] bst,maxim-deser-hub 2-0029: is_gmsl2_video_connected() index "
"= 0, not linked\n"
"[    8.507997] bst,maxim-deser-hub 2-0029: is_gmsl2_video_connected() index "
"= 1, not linked\n"
"[    8.568632] bst,maxim-deser-hub 2-0029: is_gmsl2_video_connected() index "
"= 2, not linked\n"
"[    8.629276] bst,maxim-deser-hub 2-0029: is_gmsl2_video_connected() index "
"= 3, not linked\n"
"[    8.737584] bst,maxim-deser-hub 2-0029: Failed to request irq 0\n"
"[    8.737588] bst,maxim-deser-hub 2-0029: maxim_hub_s_power(), line 1034, "
"max96712 s_power success!\n"
"[    8.737593] ox08b camera_s_power(), line 246\n"
"[    8.737600] cfg_num 0, alg_num 0\n"
"[    8.737607] a1000_isp isp: assigned reserved memory node "
"coreip_pub_cma@0xb2000000\n"
"[    8.738184] vsp vsp@1: assigned reserved memory node "
"coreip_pub_cma@0xb2000000\n"
"[    8.738345] [drm] plane:31 created\n"
"[    8.738352] [drm] plane:33 created\n"
"[    8.738718] [drm] Initialized bst-vsp 1.0.0 20200416 for vsp@1 on minor "
"0\n"
"[    8.738732] bst_drm_platform_probe exit!\n"
"[    8.738844] bst-gmwarp gmwarp@0: assigned reserved memory node "
"coreip_pub_cma@0xb2000000\n"
"[    8.738932] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-0 as /dev/"
"video30\n"
"[    8.739001] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-1 as /dev/"
"video31\n"
"[    8.739059] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-2 as /dev/"
"video32\n"
"[    8.739130] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-3 as /dev/"
"video33\n"
"[    8.739189] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-4 as /dev/"
"video34\n"
"[    8.739245] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-5 as /dev/"
"video35\n"
"[    8.739316] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-6 as /dev/"
"video36\n"
"[    8.739384] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-7 as /dev/"
"video37\n"
"[    8.739448] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-8 as /dev/"
"video38\n"
"[    8.739512] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-9 as /dev/"
"video39\n"
"[    8.739568] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-10 as /dev/"
"video40\n"
"[    8.739633] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-11 as /dev/"
"video41\n"
"[    8.739637] bst-gmwarp gmwarp@0: gmwarp probe ok!\n"
"[    8.754621] bst-encode encoder@0: assigned reserved memory node "
"coreip_pub_cma@0xb2000000\n"
"[    8.754701] bst-encode encoder@0: Registerd bst_encoder-0 as /dev/"
"video50\n"
"[    8.754761] bst-encode encoder@0: Registerd bst_encoder-1 as /dev/"
"video51\n"
"[    8.754817] bst-encode encoder@0: Registerd bst_encoder-2 as /dev/"
"video52\n"
"[    8.754882] bst-encode encoder@0: Registerd bst_encoder-3 as /dev/"
"video53\n"
"[    8.754946] bst-encode encoder@0: Registerd bst_encoder-4 as /dev/"
"video54\n"
"[    8.755003] bst-encode encoder@0: Registerd bst_encoder-5 as /dev/"
"video55\n"
"[    8.755065] bst-encode encoder@0: Registerd bst_encoder-6 as /dev/"
"video56\n"
"[    8.755141] bst-encode encoder@0: Registerd bst_encoder-7 as /dev/"
"video57\n"
"[    8.755190] ALSA device list:\n"
"[    8.755195]   No soundcards found.\n"
"[    8.972528] EXT4-fs (mmcblk0p7): recovery complete\n"
"[    8.972949] EXT4-fs (mmcblk0p7): mounted filesystem with ordered data "
"mode. Quota mode: none.\n"
"[    8.972988] VFS: Mounted root (ext4 filesystem) on device 179:7.\n"
"[    8.973612] devtmpfs: mounted\n"
"[    8.974012] Freeing unused kernel memory: 1856K\n"
"[    8.974282] Run /sbin/init as init process\n"
"[    9.158743] audit: type=1404 audit(9.129:2): enforcing=1 old_enforcing=0 "
"auid=4294967295 ses=4294967295 enabled=1 old-enabled=1 lsm=selinux res=1\n"
"[    9.218475] SELinux:  Permission watch in class filesystem not defined in "
"policy.\n"
"[    9.218507] SELinux:  Permission watch in class file not defined in "
"policy.\n"
"[    9.218509] SELinux:  Permission watch_mount in class file not defined in "
"policy.\n"
"[    9.218512] SELinux:  Permission watch_sb in class file not defined in "
"policy.\n"
"[    9.218515] SELinux:  Permission watch_with_perm in class file not "
"defined in policy.\n"
"[    9.218517] SELinux:  Permission watch_reads in class file not defined in "
"policy.\n"
"[    9.218525] SELinux:  Permission watch in class dir not defined in "
"policy.\n"
"[    9.218528] SELinux:  Permission watch_mount in class dir not defined in "
"policy.\n"
"[    9.218530] SELinux:  Permission watch_sb in class dir not defined in "
"policy.\n"
"[    9.218532] SELinux:  Permission watch_with_perm in class dir not defined "
"in policy.\n"
"[    9.218534] SELinux:  Permission watch_reads in class dir not defined in "
"policy.\n"
"[    9.218545] SELinux:  Permission watch in class lnk_file not defined in "
"policy.\n"
"[    9.218548] SELinux:  Permission watch_mount in class lnk_file not "
"defined in policy.\n"
"[    9.218550] SELinux:  Permission watch_sb in class lnk_file not defined "
"in policy.\n"
"[    9.218553] SELinux:  Permission watch_with_perm in class lnk_file not "
"defined in policy.\n"
"[    9.218555] SELinux:  Permission watch_reads in class lnk_file not "
"defined in policy.\n"
"[    9.218562] SELinux:  Permission watch in class chr_file not defined in "
"policy.\n"
"[    9.218564] SELinux:  Permission watch_mount in class chr_file not "
"defined in policy.\n"
"[    9.218566] SELinux:  Permission watch_sb in class chr_file not defined "
"in policy.\n"
"[    9.218569] SELinux:  Permission watch_with_perm in class chr_file not "
"defined in policy.\n"
"[    9.218571] SELinux:  Permission watch_reads in class chr_file not "
"defined in policy.\n"
"[    9.218578] SELinux:  Permission watch in class blk_file not defined in "
"policy.\n"
"[    9.218580] SELinux:  Permission watch_mount in class blk_file not "
"defined in policy.\n"
"[    9.218582] SELinux:  Permission watch_sb in class blk_file not defined "
"in policy.\n"
"[    9.218584] SELinux:  Permission watch_with_perm in class blk_file not "
"defined in policy.\n"
"[    9.218587] SELinux:  Permission watch_reads in class blk_file not "
"defined in policy.\n"
"[    9.218593] SELinux:  Permission watch in class sock_file not defined in "
"policy.\n"
"[    9.218595] SELinux:  Permission watch_mount in class sock_file not "
"defined in policy.\n"
"[    9.218597] SELinux:  Permission watch_sb in class sock_file not defined "
"in policy.\n"
"[    9.218600] SELinux:  Permission watch_with_perm in class sock_file not "
"defined in policy.\n"
"[    9.218602] SELinux:  Permission watch_reads in class sock_file not "
"defined in policy.\n"
"[    9.218608] SELinux:  Permission watch in class fifo_file not defined in "
"policy.\n"
"[    9.218610] SELinux:  Permission watch_mount in class fifo_file not "
"defined in policy.\n"
"[    9.218613] SELinux:  Permission watch_sb in class fifo_file not defined "
"in policy.\n"
"[    9.218615] SELinux:  Permission watch_with_perm in class fifo_file not "
"defined in policy.\n"
"[    9.218618] SELinux:  Permission watch_reads in class fifo_file not "
"defined in policy.\n"
"[    9.218753] SELinux:  Permission perfmon in class capability2 not defined "
"in policy.\n"
"[    9.218756] SELinux:  Permission bpf in class capability2 not defined in "
"policy.\n"
"[    9.218758] SELinux:  Permission checkpoint_restore in class capability2 "
"not defined in policy.\n"
"[    9.218775] SELinux:  Permission perfmon in class cap2_userns not defined "
"in policy.\n"
"[    9.218778] SELinux:  Permission bpf in class cap2_userns not defined in "
"policy.\n"
"[    9.218780] SELinux:  Permission checkpoint_restore in class cap2_userns "
"not defined in policy.\n"
"[    9.218872] SELinux:  Class mctp_socket not defined in policy.\n"
"[    9.218874] SELinux:  Class perf_event not defined in policy.\n"
"[    9.218875] SELinux:  Class anon_inode not defined in policy.\n"
"[    9.218877] SELinux:  Class io_uring not defined in policy.\n"
"[    9.218879] SELinux:  Class user_namespace not defined in policy.\n"
"[    9.218881] SELinux: the above unknown classes and permissions will be "
"allowed\n"
"[    9.241537] SELinux:  policy capability network_peer_controls=1\n"
"[    9.241551] SELinux:  policy capability open_perms=1\n"
"[    9.241553] SELinux:  policy capability extended_socket_class=1\n"
"[    9.241555] SELinux:  policy capability always_check_network=0\n"
"[    9.241558] SELinux:  policy capability cgroup_seclabel=1\n"
"[    9.241560] SELinux:  policy capability nnp_nosuid_transition=1\n"
"[    9.241562] SELinux:  policy capability genfs_seclabel_symlinks=0\n"
"[    9.241564] SELinux:  policy capability ioctl_skip_cloexec=0\n"
"[    9.337566] audit: type=1403 audit(9.309:3): auid=4294967295 "
"ses=4294967295 lsm=selinux res=1\n"
"[    9.347876] systemd[1]: Successfully loaded SELinux policy in 189.944ms.\n"
"[    9.445456] systemd[1]: System time before build time, advancing clock.\n"
"[    9.642816] systemd[1]: Relabelled /dev, /dev/shm, /run, /sys/fs/cgroup "
"in 48.506ms.\n"
"[    9.692606] systemd[1]: systemd 241-9-gc1f8ff8+ running in system mode. "
"(+PAM +AUDIT +SELINUX -IMA -APPARMOR -SMACK +SYSVINIT -UTMP -LIBCRYPTSETUP -"
"GCRYPT -GNUTLS -ACL -XZ -LZ4 -SECC)\n"
"[    9.692902] systemd[1]: Detected architecture arm64.\n"
"[    9.761188] systemd[1]: Set hostname to <a1000>.\n"
"[    9.765722] systemd[1]: Failed to bump fs.file-max, ignoring: Invalid "
"argument\n"
"[    9.865774] systemd-fstab-generator[142]: Mount point  is not a valid "
"path, ignoring.\n"
"[    9.881793] systemd-fstab-generator[142]: Mount point  is not a valid "
"path, ignoring.\n"
"[    9.882075] systemd-fstab-generator[142]: Mount point  is not a valid "
"path, ignoring.\n"
"[    9.945688] systemd[1]: File /lib/systemd/system/systemd-journald."
"service:12 configures an IP firewall (IPAddressDeny=any), but the local "
"system does not support BPF/cgroup based fir.\n"
"[    9.945702] systemd[1]: Proceeding WITHOUT firewalling in effect! (This "
"warning is only shown for the first loaded unit using IP firewalling.)\n"
"[    9.993988] systemd[1]: Configuration file /lib/systemd/system/user-"
"startup.service is marked executable. Please remove executable permission "
"bits. Proceeding anyway.\n"
"[   10.015829] systemd[1]: /lib/systemd/system/usb-gadget@.service:14: "
"Unknown lvalue 'After' in section 'Service', ignoring\n"
"[   10.019272] systemd[1]: Configuration file /lib/systemd/system/safety-"
"service.service is marked executable. Please remove executable permission "
"bits. Proceeding anyway.\n"
"[   10.019582] systemd[1]: /lib/systemd/system/safety-service.service:8: "
"Unknown lvalue 'StartLimitIntervalSec' in section 'Service', ignoring\n"
"[   12.379759] random: crng init done\n"
"[   12.475848] early application starting...\n"
"[   12.730278] audit: type=1130 audit(1675679554.279:4): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=selinux-labeldev comm=\"systemd\" exe=\"/lib/'\n"
"[   12.730364] audit: type=1131 audit(1675679554.279:5): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=selinux-labeldev comm=\"systemd\" exe=\"/lib/'\n"
"[   12.731973] audit: type=1130 audit(1675679554.279:6): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=kmod-static-nodes comm=\"systemd\" exe=\"/lib'\n"
"[   12.761921] audit: type=1130 audit(1675679554.309:7): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=systemd-sysctl comm=\"systemd\" exe=\"/lib/sy'\n"
"[   12.860995] EXT4-fs (mmcblk0p7): re-mounted. Quota mode: none.\n"
"[   12.865560] audit: type=1130 audit(1675679554.409:8): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=systemd-remount-fs comm=\"systemd\" exe=\"/li'\n"
"[   12.956353] audit: type=1130 audit(1675679554.499:9): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=systemd-tmpfiles-setup-dev comm=\"systemd\" '\n"
"[   13.098380] audit: type=1130 audit(1675679554.639:10): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=systemd-journald comm=\"systemd\" exe=\"/lib'\n"
"[   13.180022] systemd-journald[173]: Received request to flush runtime "
"journal from PID 1\n"
"[   13.187569] systemd-journald[173]: File /var/log/journal/"
"c9eb360cf45a4d3ca7df8dc9a4b9d632/system.journal corrupted or uncleanly shut "
"down, renaming and replacing.\n"
"[   13.209076] audit: type=1130 audit(1675679554.749:11): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=systemd-udevd comm=\"systemd\" exe=\"/lib/sy'\n"
"[   13.904594] bst_noc_pmu_probe, 296\n"
"[   13.904685] bst_nocpmu 32702000.noc_pmu: assigned reserved memory node "
"noc_pmu@0xe8000000\n"
"[   13.936242] bst-thermal 70039000.thermal: cooling_dev, name=pwm\n"
"[   14.912819] EXT4-fs (mmcblk0p9): recovery complete\n"
"[   14.912842] EXT4-fs (mmcblk0p9): mounted filesystem with ordered data "
"mode. Quota mode: none.\n"
"[   14.916892] ext4 filesystem being mounted at /secdata supports timestamps "
"until 2038 (0x7fffffff)\n"
"[   14.965123] EXT4-fs (mmcblk0p6): recovery complete\n"
"[   14.965622] EXT4-fs (mmcblk0p6): mounted filesystem with ordered data "
"mode. Quota mode: none.\n"
"[   15.471416] EXT4-fs (mmcblk0p10): recovery complete\n"
"[   15.471609] EXT4-fs (mmcblk0p10): mounted filesystem with ordered data "
"mode. Quota mode: none.\n"
"[   15.583524] kauditd_printk_skb: 2 callbacks suppressed\n"
"[   15.583538] audit: type=1130 audit(1675679557.129:14): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=selinux-autorelabel comm=\"systemd\" exe=\"/'\n"
"[   15.583841] audit: type=1131 audit(1675679557.129:15): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=selinux-autorelabel comm=\"systemd\" exe=\"/'\n"
"[   15.640743] audit: type=1130 audit(1675679557.189:16): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=selinux-init comm=\"systemd\" exe=\"/lib/sys'\n"
"[   15.641029] audit: type=1131 audit(1675679557.189:17): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=selinux-init comm=\"systemd\" exe=\"/lib/sys'\n"
"[   15.745845] audit: type=1130 audit(1675679557.289:18): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=systemd-tmpfiles-setup comm=\"systemd\" exe'\n"
"[   18.103131] audit: type=1130 audit(1675679559.649:19): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=bstosuser comm=\"systemd\" exe=\"/lib/system'\n"
"[   18.103678] audit: type=1131 audit(1675679559.649:20): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=bstosuser comm=\"systemd\" exe=\"/lib/system'\n"
"[   18.193782] audit: type=1130 audit(1675679559.739:21): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=safety-service comm=\"systemd\" exe=\"/lib/s'\n"
"[   18.197052] audit: type=1130 audit(1675679559.739:22): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=user-startup comm=\"systemd\" exe=\"/lib/sys'\n"
"[   18.237303] audit: type=1130 audit(1675679559.779:23): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=busybox-syslog comm=\"systemd\" exe=\"/lib/s'\n"
"[   18.831535] picp: picp init start...\n"
"[   18.831663] picp: pci not init..\n"
"[   18.893208] picp: picp init start...\n"
"[   18.893340] picp: pci not init..\n"
"[   18.934665] picp: picp init start...\n"
"[   18.934806] picp: pci not init..\n"
"[   20.667877] file system registered\n"
"[   20.741400] dwmac4: Master AXI performs fixed burst length\n"
"[   20.741447] bstgmaceth 30000000.ethernet eth0: Safety Features Fix to 0."
"Hw feature 3\n"
"[   20.741459] bstgmaceth 30000000.ethernet eth0: No Safety Features support "
"found\n"
"[   20.741492] bstgmaceth 30000000.ethernet eth0: IEEE 1588-2008 Advanced "
"Timestamp supported\n"
"[   20.746066] pps pps0: new PPS source ptp0\n"
"[   20.746880] bstgmaceth 30000000.ethernet eth0: registered PTP clock\n"
"[   20.746902] bstgmaceth 30000000.ethernet eth0: configuring for fixed/"
"rgmii link mode\n"
"[   20.756958] bstgmaceth 30000000.ethernet eth0: Link is Up - 1Gbps/Full - "
"flow control off\n"
"[   20.768570] bstgmaceth 30000000.ethernet eth0: Request Tx chan:0 irq:67.\n"
"[   20.768589] bstgmaceth 30000000.ethernet eth0: Request Tx chan:1 irq:68.\n"
"[   20.770788] bstgmaceth 30000000.ethernet eth0: Request Tx chan:2 irq:69.\n"
"[   20.770818] bstgmaceth 30000000.ethernet eth0: Request Tx chan:3 irq:70.\n"
"[   20.776672] bstgmaceth 30000000.ethernet eth0: Request Rx chan:0 irq:63.\n"
"[   20.782635] bstgmaceth 30000000.ethernet eth0: Request Rx chan:1 irq:64.\n"
"[   20.795483] bstgmaceth 30000000.ethernet eth0: Request Rx chan:2 irq:65.\n"
"[   20.801242] bstgmaceth 30000000.ethernet eth0: Request Rx chan:3 irq:66.\n"
"[   20.816356] 8021q: adding VLAN 0 to HW filter on device eth0\n"
"[   20.880677] kauditd_printk_skb: 19 callbacks suppressed\n"
"[   20.880692] audit: type=1130 audit(1675679562.429:43): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=NetworkManager-dispatcher comm=\"systemd\" '\n"
"[   20.913516] EXT4-fs (mmcblk0p5): recovery complete\n"
"[   20.913543] EXT4-fs (mmcblk0p5): mounted filesystem with ordered data "
"mode. Quota mode: none.\n"
"[   21.166231] read descriptors\n"
"[   21.166250] read descriptors\n"
"[   21.166255] read strings\n"
"[   21.303268] bstgmac_ethtool_get_link_ksettings: eth0: PHY is not "
"registered\n"
"[   21.498934] audit: type=1404 audit(1675679563.039:44): enforcing=0 "
"old_enforcing=1 auid=4294967295 ses=4294967295 enabled=1 old-enabled=1 "
"lsm=selinux res=1\n"
"[   21.504209] audit: type=1300 audit(1675679563.039:44): arch=c00000b7 "
"syscall=64 success=yes exit=1 a0=3 a1=7fe032a6d8 a2=1 a3=7fbb55ea78 items=0 "
"ppid=371 pid=633 auid=4294967295 uid=)\n"
"[   21.504921] audit: type=1327 audit(1675679563.039:44): "
"proctitle=736574656E666F7263650030\n"
"[   21.520737] audit: type=1130 audit(1675679563.069:45): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 msg='unit=rc-"
"local comm=\"systemd\" exe=\"/lib/systemd'\n"
"[   21.574655] audit: type=1130 audit(1675679563.119:46): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=getty@tty1 comm=\"systemd\" exe=\"/lib/syste'\n"
"[   21.636310] audit: type=1130 audit(1675679563.179:47): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=serial-getty@ttyS0 comm=\"systemd\" exe=\"/l'\n"
"[   22.202000] audit: type=1130 audit(1675679563.749:48): pid=1 uid=0 "
"auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=usb-gadget@g1 comm=\"systemd\" exe=\"/lib/sy'\n"
"[   22.310234] bash (697): /proc/173/oom_adj is deprecated, please use /"
"proc/173/oom_score_adj instead.\n"
"\n"
"BSTOS (Operation System by Black Sesame Technologies) 2.3.0.4 a1000 ttyS0\n"
"\n"
"a1000 login: [   23.484629] audit: type=1130 audit(1675679565.029:49): pid=1 "
"uid=0 auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 "
"msg='unit=udsservice_autostart comm=\"s'\n"
"[   23.637773] audit: type=1701 audit(1675679565.179:50): auid=4294967295 "
"uid=0 gid=0 ses=4294967295 subj=system_u:system_r:initrc_t:s0 pid=701 "
"comm=\"uds_service\" exe=\"/usr/bin/uds_serv1\n"
"```"

#: src/quickstart/aarch64_a1000.md:1177
msgid "适配问题总结"
msgstr "适配问题总结"

#: src/quickstart/aarch64_a1000.md:1179
msgid "目前加载guest的方式尚不健全，需要改进"
msgstr "目前加载guest的方式尚不健全，需要改进"

#: src/quickstart/aarch64_a1000.md:1181
msgid ""
"遇到的主要问题就是跑飞的问题，在qemu环境下实现时没有遇到，在上板子的时候则出"
"现问题，在胡博的帮助下成功定位"
msgstr ""
"遇到的主要问题就是跑飞的问题，在qemu环境下实现时没有遇到，在上板子的时候则出"
"现问题，在胡博的帮助下成功定位"

#: src/quickstart/aarch64_a1000.md:1183
msgid ""
"由于在进入guest时没有无效化guest内核镜像加载区域的数据缓存，在进入guest进行一"
"些数据读写相关的指令时访问的不是正确的数据内容，导致跑飞"
msgstr ""
"由于在进入guest时没有无效化guest内核镜像加载区域的数据缓存，在进入guest进行一"
"些数据读写相关的指令时访问的不是正确的数据内容，导致跑飞"

#: src/quickstart/aarch64_a1000.md:1185
msgid ""
"通过在进入前对对应的区域进行缓存无效化后成功解决<style> .scroll-to-top "
"{ font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-"
"items: center; justify-content: center; position: fixed; padding: 0.75rem; "
"bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: "
"999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); "
"border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-"
"top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-"
"to-top { display: flex; } } </style> <button type=\"button\" aria-"
"label=\"scroll-to-top\" class=\"scroll-to-top hidden\" "
"onclick=\"scrollToTop()\"> <i class=\"fa fa-angle-up\"></i> </button>"
msgstr ""
"通过在进入前对对应的区域进行缓存无效化后成功解决<style> .scroll-to-top "
"{ font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-"
"items: center; justify-content: center; position: fixed; padding: 0.75rem; "
"bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: "
"999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); "
"border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-"
"top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-"
"to-top { display: flex; } } </style> <button type=\"button\" aria-"
"label=\"scroll-to-top\" class=\"scroll-to-top hidden\" "
"onclick=\"scrollToTop()\"> <i class=\"fa fa-angle-up\"></i> </button>"

#: src/quickstart/aarch64_rk3588.md:3
msgid "目前，在黑芝麻 A1000 平台上已经对仅运行 Linux 的情况进行了验证。"
msgstr "目前，在黑芝麻 A1000 平台上已经对仅运行 Linux 的情况进行了验证。"

#: src/quickstart/aarch64_rk3588.md:11
msgid "从内核源码编译一个合适的linux镜像文件和dtb文件"
msgstr "从内核源码编译一个合适的linux镜像文件和dtb文件"

#: src/quickstart/aarch64_rk3588.md:13
msgid ""
"设置 `arceos-vmm/configs/vms/linux-rk3588-aarch64.toml`文件下的相关信息，此文"
"件为guest相关配置"
msgstr ""
"设置 `arceos-vmm/configs/vms/linux-rk3588-aarch64.toml`文件下的相关信息，此文"
"件为guest相关配置"

#: src/quickstart/aarch64_rk3588.md:15
msgid ""
"```toml\n"
"id = 1                    //vm id\n"
"name = \"linux\"\t\t\t  //vm 命名\n"
"vm_type = 1\t\t\t\t  //vm类型\n"
"phy_cpu_sets = [0x1]      //设定每一个vcpu的亲和性\n"
"cpu_num = 1             //cpu 数量\n"
"entry_point = 0x1008_0000  //guest内核入口地址，约定内核从这个地址开始运行\n"
"kernel_load_addr = 0x1008_0000   //guest内核加载地址，约定将内核加载到这个地"
"址\n"
"dtb_load_addr = 0x1000_0000      //guest dtb加载地址，约定将dtb加载到这个地"
"址\n"
"\n"
"# The location of image: \"memory\" | \"fs\"\n"
"# load from memory\n"
"image_location = \"memory\"       //内核加载方式，rk3588目前为从内存中加载"
"guest镜像\n"
"kernel_path = \"linux-rk3588-aarch64.bin\" //guest 内核镜像所在的本地路径，推"
"荐使用绝对地址\n"
"dtb_path = \"linux-rk3588.dtb\"\t\t\t //guest dtb文件所在的本地路径，推荐使用"
"绝对地址\n"
"\n"
"# ramdisk_path = \"\"\n"
"# ramdisk_load_addr = 0\n"
"# disk_path = \"disk.img\"\n"
"# Memory regions with format (`base_paddr`, `size`, `flags`, `map_type`).\n"
"# For `map_type`, 0 means `MAP_ALLOC`, 1 means `MAP_IDENTICAL`.\n"
"memory_regions = [\n"
"    [0x0, 0x10_f000, 0x37, 1],        # rk3588使用到的一段uncached内存，需要"
"一一映射\n"
"    [0x940_0000, 0x76c00000, 0x7, 1], # 一一映射给guest的物理内存，根据实际的"
"物理内存按需分配即可\n"
"]\n"
"\n"
"# Emu_devices\n"
"# Name Base-Ipa Ipa_len Alloc-Irq Emu-Type EmuConfig\n"
"emu_devices = []\n"
"\n"
"# Pass-through devices\n"
"# Name Base-Ipa Base-Pa Length Alloc-Irq\n"
"//此处的设备地址目前主要是根据设备树来的，需要给guest linux什么设备，就同时修"
"改此处的配置和相关的dtb，使二者一致即可\n"
"passthrough_devices = [\n"
"    [\n"
"        \"ramoops\",\n"
"        0x11_0000,\n"
"        0x11_0000,\t\t\t\t\t\n"
"        0xf_0000,\n"
"        0x1,\n"
"    ],\n"
"    [\n"
"        \"sram\",\n"
"        0x10_f000,\n"
"        0x10_f000,\n"
"        0x1000,\n"
"        0x1,\n"
"    ],\n"
"    [\n"
"        \"gpu\",\n"
"        0xfb00_0000,\n"
"        0xfb00_0000,\n"
"        0x200000,\n"
"        0x1,\n"
"    ],\n"
"    [\n"
"        \"uart8250 UART\",\n"
"        0xfd00_0000,\n"
"        0xfd00_0000,\n"
"        0x2000000,\n"
"        0x1,\n"
"    ],\n"
"    [\n"
"        \"usb\",\n"
"        0xfc00_0000,\n"
"        0xfc00_0000,\n"
"        0x1000000,\n"
"        0x1,\n"
"    ],\n"
"]\n"
"```"
msgstr ""
"```toml\n"
"id = 1                    //vm id\n"
"name = \"linux\"\t\t\t  //vm 命名\n"
"vm_type = 1\t\t\t\t  //vm类型\n"
"phy_cpu_sets = [0x1]      //设定每一个vcpu的亲和性\n"
"cpu_num = 1             //cpu 数量\n"
"entry_point = 0x1008_0000  //guest内核入口地址，约定内核从这个地址开始运行\n"
"kernel_load_addr = 0x1008_0000   //guest内核加载地址，约定将内核加载到这个地"
"址\n"
"dtb_load_addr = 0x1000_0000      //guest dtb加载地址，约定将dtb加载到这个地"
"址\n"
"\n"
"# The location of image: \"memory\" | \"fs\"\n"
"# load from memory\n"
"image_location = \"memory\"       //内核加载方式，rk3588目前为从内存中加载"
"guest镜像\n"
"kernel_path = \"linux-rk3588-aarch64.bin\" //guest 内核镜像所在的本地路径，推"
"荐使用绝对地址\n"
"dtb_path = \"linux-rk3588.dtb\"\t\t\t //guest dtb文件所在的本地路径，推荐使用"
"绝对地址\n"
"\n"
"# ramdisk_path = \"\"\n"
"# ramdisk_load_addr = 0\n"
"# disk_path = \"disk.img\"\n"
"# Memory regions with format (`base_paddr`, `size`, `flags`, `map_type`).\n"
"# For `map_type`, 0 means `MAP_ALLOC`, 1 means `MAP_IDENTICAL`.\n"
"memory_regions = [\n"
"    [0x0, 0x10_f000, 0x37, 1],        # rk3588使用到的一段uncached内存，需要"
"一一映射\n"
"    [0x940_0000, 0x76c00000, 0x7, 1], # 一一映射给guest的物理内存，根据实际的"
"物理内存按需分配即可\n"
"]\n"
"\n"
"# Emu_devices\n"
"# Name Base-Ipa Ipa_len Alloc-Irq Emu-Type EmuConfig\n"
"emu_devices = []\n"
"\n"
"# Pass-through devices\n"
"# Name Base-Ipa Base-Pa Length Alloc-Irq\n"
"//此处的设备地址目前主要是根据设备树来的，需要给guest linux什么设备，就同时修"
"改此处的配置和相关的dtb，使二者一致即可\n"
"passthrough_devices = [\n"
"    [\n"
"        \"ramoops\",\n"
"        0x11_0000,\n"
"        0x11_0000,\t\t\t\t\t\n"
"        0xf_0000,\n"
"        0x1,\n"
"    ],\n"
"    [\n"
"        \"sram\",\n"
"        0x10_f000,\n"
"        0x10_f000,\n"
"        0x1000,\n"
"        0x1,\n"
"    ],\n"
"    [\n"
"        \"gpu\",\n"
"        0xfb00_0000,\n"
"        0xfb00_0000,\n"
"        0x200000,\n"
"        0x1,\n"
"    ],\n"
"    [\n"
"        \"uart8250 UART\",\n"
"        0xfd00_0000,\n"
"        0xfd00_0000,\n"
"        0x2000000,\n"
"        0x1,\n"
"    ],\n"
"    [\n"
"        \"usb\",\n"
"        0xfc00_0000,\n"
"        0xfc00_0000,\n"
"        0x1000000,\n"
"        0x1,\n"
"    ],\n"
"]\n"
"```"

#: src/quickstart/aarch64_rk3588.md:87
msgid ""
"设置`arceos-vmm/configs/platforms/aarch64-rk3588j-hv.toml`文件下的相关信息，"
"此文件为host相关配置"
msgstr ""
"设置`arceos-vmm/configs/platforms/aarch64-rk3588j-hv.toml`文件下的相关信息，"
"此文件为host相关配置"

#: src/quickstart/aarch64_rk3588.md:89
msgid ""
"```toml\n"
"# Architecture identifier.\n"
"arch = \"aarch64\" # str                //host 架构\n"
"# Platform identifier.\n"
"platform = \"aarch64-rk3588j\" # str     //host 平台\n"
"\n"
"#\n"
"# Platform configs\n"
"#\n"
"[plat]\n"
"# Platform family.\n"
"family = \"aarch64-rk3588j\"\n"
"\n"
"# Base address of the whole physical memory.\n"
"phys-memory-base = 0x20_0000 # uint         //host 物理内存起始地址\n"
"# Size of the whole physical memory.\n"
"phys-memory-size = 0x800_0000    # uint     //host自身管理使用的内存大小，由"
"于目前对非连续物理内存的支持不够完善，此处物理内存的大小可以小于host使用的内"
"存，在guest vm使用一一映射的内存可以不在此段内存中\n"
"# Base physical address of the kernel image.\n"
"kernel-base-paddr = 0x48_0000 # uint         //host内核起始物理地址\n"
"# Base virtual address of the kernel image.\n"
"kernel-base-vaddr = \"0x0000_0000_0048_0000\"   //host内核起始虚拟地址\n"
"# Linear mapping offset, for quick conversions between physical and virtual\n"
"# addresses.\n"
"phys-virt-offset = \"0x0000_0000_0000_0000\"\n"
"# Kernel address space base.\n"
"kernel-aspace-base = \"0x0000_0000_0000_0000\"\n"
"# Kernel address space size.\n"
"kernel-aspace-size = \"0x0000_ffff_ffff_f000\"\n"
"\n"
"#\n"
"# Device specifications\n"
"#\n"
"[devices]\n"
"# MMIO regions with format (`base_paddr`, `size`).\n"
"//host物理设备的地址\n"
"mmio-regions = [\n"
"    [0xfeb50000, 0x1000], # uart8250 UART0\n"
"    [0xfe600000, 0x10000], # gic-v3 gicd\n"
"    [0xfe680000, 0x100000], # gic-v3 gicr\n"
"    [0xa41000000, 0x400000],\n"
"    [0xa40c00000, 0x400000],\n"
"    [0xf4000000,0x1000000],\n"
"    [0xf3000000,0x1000000],\n"
"] # [(uint, uint)]\n"
"# VirtIO MMIO regions with format (`base_paddr`, `size`).\n"
"virtio-mmio-regions = []  # [(uint, uint)]\n"
"\n"
"# Base physical address of the PCIe ECAM space.\n"
"pci-ecam-base = 0xf4000000  # uint\n"
"# End PCI bus number (`bus-range` property in device tree).\n"
"pci-bus-end = 0xff # uint\n"
"# PCI device memory ranges (`ranges` property in device tree).\n"
"pci-ranges = [] # [(uint, uint)]\n"
"# UART Address\n"
"uart-paddr = 0xfeb5_0000 # uint\n"
"uart-irq = 0x14d # uint\n"
"\n"
"# GICC Address\n"
"gicd-paddr = 0xfe600000 # uint\n"
"# GICR Address\n"
"gicc-paddr = 0xfe680000 # uint\n"
"gicr-paddr = 0xfe680000 # uint\n"
"\n"
"# PSCI\n"
"psci-method = \"smc\" # str\n"
"\n"
"# pl031@9010000 {\n"
"#     clock-names = \"apb_pclk\";\n"
"#     clocks = <0x8000>;\n"
"#     interrupts = <0x00 0x02 0x04>;\n"
"#     reg = <0x00 0x9010000 0x00 0x1000>;\n"
"#     compatible = \"arm,pl031\\0arm,primecell\";\n"
"# };\n"
"# RTC (PL031) Address\n"
"rtc-paddr = 0x901_0000          # uint\n"
"```"
msgstr ""
"```toml\n"
"# Architecture identifier.\n"
"arch = \"aarch64\" # str                //host 架构\n"
"# Platform identifier.\n"
"platform = \"aarch64-rk3588j\" # str     //host 平台\n"
"\n"
"#\n"
"# Platform configs\n"
"#\n"
"[plat]\n"
"# Platform family.\n"
"family = \"aarch64-rk3588j\"\n"
"\n"
"# Base address of the whole physical memory.\n"
"phys-memory-base = 0x20_0000 # uint         //host 物理内存起始地址\n"
"# Size of the whole physical memory.\n"
"phys-memory-size = 0x800_0000    # uint     //host自身管理使用的内存大小，由"
"于目前对非连续物理内存的支持不够完善，此处物理内存的大小可以小于host使用的内"
"存，在guest vm使用一一映射的内存可以不在此段内存中\n"
"# Base physical address of the kernel image.\n"
"kernel-base-paddr = 0x48_0000 # uint         //host内核起始物理地址\n"
"# Base virtual address of the kernel image.\n"
"kernel-base-vaddr = \"0x0000_0000_0048_0000\"   //host内核起始虚拟地址\n"
"# Linear mapping offset, for quick conversions between physical and virtual\n"
"# addresses.\n"
"phys-virt-offset = \"0x0000_0000_0000_0000\"\n"
"# Kernel address space base.\n"
"kernel-aspace-base = \"0x0000_0000_0000_0000\"\n"
"# Kernel address space size.\n"
"kernel-aspace-size = \"0x0000_ffff_ffff_f000\"\n"
"\n"
"#\n"
"# Device specifications\n"
"#\n"
"[devices]\n"
"# MMIO regions with format (`base_paddr`, `size`).\n"
"//host物理设备的地址\n"
"mmio-regions = [\n"
"    [0xfeb50000, 0x1000], # uart8250 UART0\n"
"    [0xfe600000, 0x10000], # gic-v3 gicd\n"
"    [0xfe680000, 0x100000], # gic-v3 gicr\n"
"    [0xa41000000, 0x400000],\n"
"    [0xa40c00000, 0x400000],\n"
"    [0xf4000000,0x1000000],\n"
"    [0xf3000000,0x1000000],\n"
"] # [(uint, uint)]\n"
"# VirtIO MMIO regions with format (`base_paddr`, `size`).\n"
"virtio-mmio-regions = []  # [(uint, uint)]\n"
"\n"
"# Base physical address of the PCIe ECAM space.\n"
"pci-ecam-base = 0xf4000000  # uint\n"
"# End PCI bus number (`bus-range` property in device tree).\n"
"pci-bus-end = 0xff # uint\n"
"# PCI device memory ranges (`ranges` property in device tree).\n"
"pci-ranges = [] # [(uint, uint)]\n"
"# UART Address\n"
"uart-paddr = 0xfeb5_0000 # uint\n"
"uart-irq = 0x14d # uint\n"
"\n"
"# GICC Address\n"
"gicd-paddr = 0xfe600000 # uint\n"
"# GICR Address\n"
"gicc-paddr = 0xfe680000 # uint\n"
"gicr-paddr = 0xfe680000 # uint\n"
"\n"
"# PSCI\n"
"psci-method = \"smc\" # str\n"
"\n"
"# pl031@9010000 {\n"
"#     clock-names = \"apb_pclk\";\n"
"#     clocks = <0x8000>;\n"
"#     interrupts = <0x00 0x02 0x04>;\n"
"#     reg = <0x00 0x9010000 0x00 0x1000>;\n"
"#     compatible = \"arm,pl031\\0arm,primecell\";\n"
"# };\n"
"# RTC (PL031) Address\n"
"rtc-paddr = 0x901_0000          # uint\n"
"```"

#: src/quickstart/aarch64_rk3588.md:166
msgid ""
"使用`make A=(pwd) ARCH=aarch64 VM_CONFIGS=configs/vms/linux-rk3588-aarch64."
"toml PLAT_NAME=aarch64-rk3588j-hv FEATURES=page-alloc-64g,hv LOG=info "
"kernel` 编译出一个可烧写的arceos-umhv内核镜像`boot.img`文件"
msgstr ""
"使用`make A=(pwd) ARCH=aarch64 VM_CONFIGS=configs/vms/linux-rk3588-aarch64."
"toml PLAT_NAME=aarch64-rk3588j-hv FEATURES=page-alloc-64g,hv LOG=info "
"kernel` 编译出一个可烧写的arceos-umhv内核镜像`boot.img`文件"

#: src/quickstart/aarch64_rk3588.md:168
msgid ""
"使用rk3588官方提供的工具等方式将开发板原先的内核镜像文件替换为`step 4`编译出"
"的文件"
msgstr ""
"使用rk3588官方提供的工具等方式将开发板原先的内核镜像文件替换为`step 4`编译出"
"的文件"

#: src/quickstart/aarch64_rk3588.md:170
msgid "断电重启"
msgstr "断电重启"

#: src/quickstart/aarch64_rk3588.md:174
msgid ""
"TODO<style> .scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: "
"3.2rem; display: none; align-items: center; justify-content: center; "
"position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px "
"+ var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: "
"var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top."
"hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } "
"@media (min-width: 1080px) { .scroll-to-top { display: flex; } } </style> "
"<button type=\"button\" aria-label=\"scroll-to-top\" class=\"scroll-to-top "
"hidden\" onclick=\"scrollToTop()\"> <i class=\"fa fa-angle-up\"></i> </"
"button>"
msgstr ""
"TODO<style> .scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: "
"3.2rem; display: none; align-items: center; justify-content: center; "
"position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px "
"+ var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: "
"var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top."
"hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } "
"@media (min-width: 1080px) { .scroll-to-top { display: flex; } } </style> "
"<button type=\"button\" aria-label=\"scroll-to-top\" class=\"scroll-to-top "
"hidden\" onclick=\"scrollToTop()\"> <i class=\"fa fa-angle-up\"></i> </"
"button>"

#: src/quickstart/aarch64_roc-rk3568-pc.md:1
msgid "正在适配中。。。"
msgstr "正在适配中。。。"

#: src/architecture/arch.md:3
msgid "1. 设计目标"
msgstr "1. 设计目标"

#: src/architecture/arch.md:5
msgid ""
"ArceOS-Hypervisor 是基于 ArceOS unikernel 框架实现的 Hypervisor。其目标是利"
"用 ArceOS 提供的基础操作系统功能作为基础，实现一个统一的模块化 Hypervisor。统"
"一指使用同一套代码同时支持 x86_64、arm(aarch64) 和 RISC-V 三种架构，以最大化"
"复用架构无关代码，简化代码开发和维护成本。模块化指 Hypervisor 的功能被分解为"
"多个模块，每个模块实现一个特定的功能，模块之间通过标准接口进行通信，以实现功"
"能的解耦和复用。"
msgstr ""
"ArceOS-Hypervisor 是基于 ArceOS unikernel 框架实现的 Hypervisor。其目标是利"
"用 ArceOS 提供的基础操作系统功能作为基础，实现一个统一的模块化 Hypervisor。统"
"一指使用同一套代码同时支持 x86_64、arm(aarch64) 和 RISC-V 三种架构，以最大化"
"复用架构无关代码，简化代码开发和维护成本。模块化指 Hypervisor 的功能被分解为"
"多个模块，每个模块实现一个特定的功能，模块之间通过标准接口进行通信，以实现功"
"能的解耦和复用。"

#: src/architecture/arch.md:7
msgid ""
"ArceOS 是一个基于 Rust 语言的 unikernel 框架，其设计目标是提供一个高性能、模"
"块化、最小化的操作系统基座。通过在 ArceOS 的基础上添加不同的模块，就可以对应"
"不同的应用场景生成不同的操作系统：在 ArceOS 上直接添加应用程序，就可以生成一"
"个独立的应用程序 unikernel 镜像；在 ArceOS 上添加宏内核模块，就可以生成一个完"
"整的宏内核操作系统；ArceOS-Hypervisor 则在 ArceOS 的基础上添加虚拟化相关模"
"块，从而以最小成本实现一个 Type-1 Hypervisor。"
msgstr ""
"ArceOS 是一个基于 Rust 语言的 unikernel 框架，其设计目标是提供一个高性能、模"
"块化、最小化的操作系统基座。通过在 ArceOS 的基础上添加不同的模块，就可以对应"
"不同的应用场景生成不同的操作系统：在 ArceOS 上直接添加应用程序，就可以生成一"
"个独立的应用程序 unikernel 镜像；在 ArceOS 上添加宏内核模块，就可以生成一个完"
"整的宏内核操作系统；ArceOS-Hypervisor 则在 ArceOS 的基础上添加虚拟化相关模"
"块，从而以最小成本实现一个 Type-1 Hypervisor。"

#: src/architecture/arch.md:9
msgid "![arceos-architecture](../assets/arceos-backbone.png)"
msgstr "![arceos-architecture](../assets/arceos-backbone.png)"

#: src/architecture/arch.md:11
msgid "2. 软件架构"
msgstr "2. 软件架构"

#: src/architecture/arch.md:13
msgid ""
"ArceOS-Hypervisor 的软件架构如下图所示，图中每一个框都是一个独立的模块，模块"
"之间通过标准接口进行通信。包括作为基础的 ArceOS 在内，ArceOS-Hypervisor 的软"
"件架构分为五层："
msgstr ""
"ArceOS-Hypervisor 的软件架构如下图所示，图中每一个框都是一个独立的模块，模块"
"之间通过标准接口进行通信。包括作为基础的 ArceOS 在内，ArceOS-Hypervisor 的软"
"件架构分为五层："

#: src/architecture/arch.md:15
msgid ""
"![arceos-hypervisor-architecture](../assets/arceos-hypervisor-architecture."
"png)"
msgstr ""
"![arceos-hypervisor-architecture](../assets/arceos-hypervisor-architecture."
"png)"

#: src/architecture/arch.md:17
msgid "AxVisor 整体架构"
msgstr "AxVisor 整体架构"

#: src/architecture/arch.md:23
msgid "2.1. ArceOS"
msgstr "2.1. ArceOS"

#: src/architecture/arch.md:25
msgid ""
"在 ArceOS-Hypervisor 中，ArceOS 作为最底层的基础存在，提供内存管理、任务调"
"度、设备驱动、同步原语等多种基础功能。ArceOS 的模块化设计允许 ArceOS-"
"Hypervisor 灵活选择需要的模块，这不仅缩减了编译的开销和二进制体积，也提高了系"
"统的安全性和可靠性。"
msgstr ""
"在 ArceOS-Hypervisor 中，ArceOS 作为最底层的基础存在，提供内存管理、任务调"
"度、设备驱动、同步原语等多种基础功能。ArceOS 的模块化设计允许 ArceOS-"
"Hypervisor 灵活选择需要的模块，这不仅缩减了编译的开销和二进制体积，也提高了系"
"统的安全性和可靠性。"

#: src/architecture/arch.md:27
msgid "2.2. ArceOS-VMM 应用程序（App）"
msgstr "2.2. ArceOS-VMM 应用程序（App）"

#: src/architecture/arch.md:29
msgid ""
"ArceOS-VMM 应用程序是整个 ArceOS-Hypervisor 的核心，它作为 ArceOS 上的一个 "
"unikernel 应用程序运行。ArceOS-VMM 应用程序负责管理虚拟机的生命周期，进行创"
"建、销毁、启动、停止等操作，维护虚拟机的配置、状态、资源等信息，同时也负责处"
"理虚拟机之间的隔离与通信，以及虚拟机对硬件资源的申请和访问。"
msgstr ""
"ArceOS-VMM 应用程序是整个 ArceOS-Hypervisor 的核心，它作为 ArceOS 上的一个 "
"unikernel 应用程序运行。ArceOS-VMM 应用程序负责管理虚拟机的生命周期，进行创"
"建、销毁、启动、停止等操作，维护虚拟机的配置、状态、资源等信息，同时也负责处"
"理虚拟机之间的隔离与通信，以及虚拟机对硬件资源的申请和访问。"

#: src/architecture/arch.md:31
msgid "2.3. `axvm` 模块"
msgstr "2.3. `axvm` 模块"

#: src/architecture/arch.md:33
msgid ""
"`axvm` 模块位于 ArceOS-Hypervisor 的中间层，它定义了虚拟机的数据结构和操作接"
"口，具体实现了虚拟机的创建、销毁、启动、停止等功能。同时，`axvm` 模块还负责虚"
"拟机内部虚拟 CPU 的创建、销毁、启动、停止等功能，并负责管理虚拟内存、虚拟设备"
"等资源，实现虚拟环境内操作系统和应用程序对各种虚拟资源的访问。"
msgstr ""
"`axvm` 模块位于 ArceOS-Hypervisor 的中间层，它定义了虚拟机的数据结构和操作接"
"口，具体实现了虚拟机的创建、销毁、启动、停止等功能。同时，`axvm` 模块还负责虚"
"拟机内部虚拟 CPU 的创建、销毁、启动、停止等功能，并负责管理虚拟内存、虚拟设备"
"等资源，实现虚拟环境内操作系统和应用程序对各种虚拟资源的访问。"

#: src/architecture/arch.md:35
msgid "2.4. `axvcpu`、`axaddrspace` 和 `axdevice` 模块"
msgstr "2.4. `axvcpu`、`axaddrspace` 和 `axdevice` 模块"

#: src/architecture/arch.md:37
msgid ""
"在 `axvm` 模块的下层是 `axvcpu`、`axaddrspace` 和 `axdevice` 三个具体实现的模"
"块，`axvcpu` 模块负责架构无关虚拟 CPU 的具体实现，`axaddrspace` 模块负责虚拟"
"内存的具体实现，`axdevice` 模块负责虚拟设备的具体实现。这三个模块共同构成了虚"
"拟机的基础设施，为虚拟机提供了 CPU、内存、设备等基本资源。"
msgstr ""
"在 `axvm` 模块的下层是 `axvcpu`、`axaddrspace` 和 `axdevice` 三个具体实现的模"
"块，`axvcpu` 模块负责架构无关虚拟 CPU 的具体实现，`axaddrspace` 模块负责虚拟"
"内存的具体实现，`axdevice` 模块负责虚拟设备的具体实现。这三个模块共同构成了虚"
"拟机的基础设施，为虚拟机提供了 CPU、内存、设备等基本资源。"

#: src/architecture/arch.md:39
msgid ""
"`axvcpu` 模块定义了虚拟 CPU 的数据结构和统一操作接口。尽管各个架构下的虚拟化"
"技术千差万别，但是通过统一的接口，架构之间的差异在 `axvcpu` 模块中得到了屏"
"蔽，从而允许 `axvm` 及以上层的模块不受架构的限制，实现架构无关的虚拟机管理，"
"提高了代码的复用性和可移植性。"
msgstr ""
"`axvcpu` 模块定义了虚拟 CPU 的数据结构和统一操作接口。尽管各个架构下的虚拟化"
"技术千差万别，但是通过统一的接口，架构之间的差异在 `axvcpu` 模块中得到了屏"
"蔽，从而允许 `axvm` 及以上层的模块不受架构的限制，实现架构无关的虚拟机管理，"
"提高了代码的复用性和可移植性。"

#: src/architecture/arch.md:41
msgid ""
"`axaddrspace` 模块定义了虚拟内存特别是嵌套页表的数据结构。通过复用 ArceOS 的"
"页表等数据结构，实现了架构无关的虚拟内存管理。"
msgstr ""
"`axaddrspace` 模块定义了虚拟内存特别是嵌套页表的数据结构。通过复用 ArceOS 的"
"页表等数据结构，实现了架构无关的虚拟内存管理。"

#: src/architecture/arch.md:43
msgid ""
"`axdevice` 模块定义了虚拟设备统一访问接口，提供了虚拟设备的基本抽象和封装，允"
"许虚拟机通过统一的接口访问不同的虚拟设备，从而实现虚拟机对硬件资源的访问。"
msgstr ""
"`axdevice` 模块定义了虚拟设备统一访问接口，提供了虚拟设备的基本抽象和封装，允"
"许虚拟机通过统一的接口访问不同的虚拟设备，从而实现虚拟机对硬件资源的访问。"

#: src/architecture/arch.md:45
msgid "2.5. 具体实现模块"
msgstr "2.5. 具体实现模块"

#: src/architecture/arch.md:47
msgid ""
"基于 `axvcpu` 和 `axdevice` 模块，ArceOS-Hypervisor 实现了不同架构下的具体虚"
"拟 CPU 和虚拟设备模块，虚拟 CPU 包括 `x86_vcpu`、`arm_vcpu` 和 `riscv_vcpu`，"
"虚拟设备包括 `x86_vlapic`、`arm_gic` 以及正在实现的 `virtio_blk`、"
"`virtio_net` 等等。这些模块实现了具体的虚拟化功能，并且通过 `axvcpu` 和 "
"`axdevice` 模块提供的统一接口与其它模块进行交互，这使得代码的复用性和可移植性"
"得到了极大的提高。"
msgstr ""
"基于 `axvcpu` 和 `axdevice` 模块，ArceOS-Hypervisor 实现了不同架构下的具体虚"
"拟 CPU 和虚拟设备模块，虚拟 CPU 包括 `x86_vcpu`、`arm_vcpu` 和 `riscv_vcpu`，"
"虚拟设备包括 `x86_vlapic`、`arm_gic` 以及正在实现的 `virtio_blk`、"
"`virtio_net` 等等。这些模块实现了具体的虚拟化功能，并且通过 `axvcpu` 和 "
"`axdevice` 模块提供的统一接口与其它模块进行交互，这使得代码的复用性和可移植性"
"得到了极大的提高。"

#: src/architecture/arch.md:54
msgid "3. 运行流程"
msgstr "3. 运行流程"

#: src/architecture/arch.md:56
msgid "3.1. 虚拟 CPU 调度"
msgstr "3.1. 虚拟 CPU 调度"

#: src/architecture/arch.md:58
msgid ""
"ArceOS-Hypervisor 的执行流程的核心是虚拟 CPU 的调度。在 ArceOS-Hypervisor "
"中，虚拟 CPU 是虚拟机的基本执行单元，每个虚拟机可以包含一个或多个虚拟 CPU。虚"
"拟 CPU 的调度是通过复用 ArceOS 的任务调度机制实现的，每个虚拟 CPU 作为一个任"
"务，由 ArceOS 的任务调度器进行调度："
msgstr ""
"ArceOS-Hypervisor 的执行流程的核心是虚拟 CPU 的调度。在 ArceOS-Hypervisor "
"中，虚拟 CPU 是虚拟机的基本执行单元，每个虚拟机可以包含一个或多个虚拟 CPU。虚"
"拟 CPU 的调度是通过复用 ArceOS 的任务调度机制实现的，每个虚拟 CPU 作为一个任"
"务，由 ArceOS 的任务调度器进行调度："

#: src/architecture/arch.md:60
msgid "![vcpu scheduling](../assets/vcpu-scheduling-base.png)"
msgstr "![vcpu scheduling](../assets/vcpu-scheduling-base.png)"

#: src/architecture/arch.md:62
msgid ""
"ArceOS-Hypervisor 还支持混合的调度策略。对于不同的虚拟 CPU，可以采用不同的调"
"度策略，例如，对于实时任务，可以将对应的虚拟 CPU 固定在一个物理 CPU 上，独占"
"物理 CPU 的资源，以保证实时任务的响应时间；对于普通任务，则通过调度器进行动态"
"调度，以实现资源的高效利用："
msgstr ""
"ArceOS-Hypervisor 还支持混合的调度策略。对于不同的虚拟 CPU，可以采用不同的调"
"度策略，例如，对于实时任务，可以将对应的虚拟 CPU 固定在一个物理 CPU 上，独占"
"物理 CPU 的资源，以保证实时任务的响应时间；对于普通任务，则通过调度器进行动态"
"调度，以实现资源的高效利用："

#: src/architecture/arch.md:64
msgid "![vcpu scheduling](../assets/vcpu-scheduling.png)"
msgstr "![vcpu scheduling](../assets/vcpu-scheduling.png)"

#: src/architecture/arch.md:66
msgid ""
"未来计划实现：unikernel axtask、宏内核 process 以及 AxVisor vcpu 的统一调度"
msgstr ""
"未来计划实现：unikernel axtask、宏内核 process 以及 AxVisor vcpu 的统一调度"

#: src/architecture/arch.md:68
msgid "![](../assets/axtask.png)"
msgstr "![](../assets/axtask.png)"

#: src/architecture/arch.md:70
msgid "![](../assets/cpu.png)"
msgstr "![](../assets/cpu.png)"

#: src/architecture/arch.md:72
msgid "3.3. 二阶段地址翻译"
msgstr "3.3. 二阶段地址翻译"

#: src/architecture/arch.md:74 src/architecture/memory.md:7
msgid "![](../assets/pt.png)"
msgstr "![](../assets/pt.png)"

#: src/architecture/arch.md:76
msgid "3.3. VMExit 处理"
msgstr "3.3. VMExit 处理"

#: src/architecture/arch.md:78
msgid "![vmexit handling](../assets/vmexit-handling.png)"
msgstr "![vmexit handling](../assets/vmexit-handling.png)"

#: src/architecture/arch.md:81
msgid "3.4 虚拟设备实现"
msgstr "3.4 虚拟设备实现"

#: src/architecture/arch.md:83
msgid "![](../assets/driver-device.png)"
msgstr "![](../assets/driver-device.png)"

#: src/architecture/arch.md:85
msgid "3.4.1 Virtio-device"
msgstr "3.4.1 Virtio-device"

#: src/architecture/arch.md:87
msgid "![](../assets/io.png)"
msgstr "![](../assets/io.png)"

#: src/architecture/arch.md:89
msgid ""
"AxVisor 实现 virtio-device 后端设备，具体的设备实现通过类似影子进程的设计转发"
"给 Linux 实现"
msgstr ""
"AxVisor 实现 virtio-device 后端设备，具体的设备实现通过类似影子进程的设计转发"
"给 Linux 实现"

#: src/architecture/arch.md:91
msgid "![virtio](../assets/virtio-backend.png)"
msgstr "![virtio](../assets/virtio-backend.png)"

#: src/architecture/arch.md:93
msgid "3.5. 影子进程"
msgstr "3.5. 影子进程"

#: src/architecture/arch.md:95
msgid ""
"影子进程是一种通过将具体设备直通给虚拟机内的 Linux 等成品操作系统，让其他虚拟"
"机通过虚拟机间通信和共享内存等方式与这个 Linux 进行通信，从而利用 Linux 中的"
"现有驱动程序来实现虚拟设备的一种技术。影子进程技术可以大大减少虚拟机监控器的"
"开发工作量，提高虚拟机监控器的可移植性和可扩展性。"
msgstr ""
"影子进程是一种通过将具体设备直通给虚拟机内的 Linux 等成品操作系统，让其他虚拟"
"机通过虚拟机间通信和共享内存等方式与这个 Linux 进行通信，从而利用 Linux 中的"
"现有驱动程序来实现虚拟设备的一种技术。影子进程技术可以大大减少虚拟机监控器的"
"开发工作量，提高虚拟机监控器的可移植性和可扩展性。"

#: src/architecture/axvisor.md:3
msgid ""
"[AxVisor]((https://github.com/arceos-hypervisor/axvisor/)) 作为虚拟机监控器"
"（VMM）运行，构建并作为 ArceOS 独立内核应用程序运行。"
msgstr ""
"[AxVisor]((https://github.com/arceos-hypervisor/axvisor/)) 作为虚拟机监控器"
"（VMM）运行，构建并作为 ArceOS 独立内核应用程序运行。"

#: src/architecture/axvisor.md:5
msgid "![](../assets/arceos-hv-dep.svg)"
msgstr "![](../assets/arceos-hv-dep.svg)"

#: src/architecture/axvisor.md:7
msgid ""
"如上依赖关系图所示，它提供了一个全局视角的虚拟化资源管理，作为连接 ArceOS 核"
"心功能组件与虚拟化相关组件的桥梁。"
msgstr ""
"如上依赖关系图所示，它提供了一个全局视角的虚拟化资源管理，作为连接 ArceOS 核"
"心功能组件与虚拟化相关组件的桥梁。"

#: src/architecture/axvisor.md:9
msgid ""
"一方面，它直接依赖于 ArceOS 提供的 axstd 库，调用 ArceOS 的核心功能。一些直接"
"的依赖包括："
msgstr ""
"一方面，它直接依赖于 ArceOS 提供的 axstd 库，调用 ArceOS 的核心功能。一些直接"
"的依赖包括："

#: src/architecture/axvisor.md:11
msgid ""
"​[axtask](https://arceos.org/arceos/axtask/index.html) based vCpu management "
"and scheduling"
msgstr ""
"​[axtask](https://arceos.org/arceos/axtask/index.html) based vCpu management "
"and scheduling"

#: src/architecture/axvisor.md:12
msgid ""
"[axhal](https://arceos.org/arceos/axhal/index.html) for platform-specific "
"operations and interrupt handling"
msgstr ""
"[axhal](https://arceos.org/arceos/axhal/index.html) for platform-specific "
"operations and interrupt handling"

#: src/architecture/axvisor.md:13
msgid ""
"[axconfig](https://arceos.org/arceos/axconfig/index.html) for platform "
"configuration"
msgstr ""
"[axconfig](https://arceos.org/arceos/axconfig/index.html) for platform "
"configuration"

#: src/architecture/axvisor.md:15
msgid ""
"另一方面，它依赖于 [axvm](./axvm.md) 来实现虚拟机管理（配置与运行时），包括："
msgstr ""
"另一方面，它依赖于 [axvm](./axvm.md) 来实现虚拟机管理（配置与运行时），包括："

#: src/architecture/axvisor.md:17
msgid "​CRUD operations for guest VMs"
msgstr "​CRUD operations for guest VMs"

#: src/architecture/axvisor.md:18
msgid "​VM lifecycle control: setup, boot, notification and shutdown"
msgstr "​VM lifecycle control: setup, boot, notification and shutdown"

#: src/architecture/axvisor.md:19
msgid "Hypercall handling for communication between hypervisor and guest VMs"
msgstr "Hypercall handling for communication between hypervisor and guest VMs"

#: src/architecture/axvisor.md:21
msgid "VM 管理"
msgstr "VM 管理"

#: src/architecture/axvisor.md:23
msgid "hypercall handler"
msgstr "hypercall handler"

#: src/architecture/axvisor.md:24
msgid "GLOBAL_VM_LIST"
msgstr "GLOBAL_VM_LIST"

#: src/architecture/axvisor.md:26
msgid "基于 axtask 的 vCPU 调度"
msgstr "基于 axtask 的 vCPU 调度"

#: src/architecture/axvisor.md:28
msgid ""
"[axvcpu](./vcpu/vcpu.md) 仅负责虚拟化功能支持，例如通过 vmlaunch/vmexit 进入/"
"退出客户机。"
msgstr ""
"[axvcpu](./vcpu/vcpu.md) 仅负责虚拟化功能支持，例如通过 vmlaunch/vmexit 进入/"
"退出客户机。"

#: src/architecture/axvisor.md:30
msgid ""
"由于 ArceOS 已经提供了 axtask 用于在单一特权级别下进行运行时控制流管理，我们"
"可以重用其调度器并与之共同发展。"
msgstr ""
"由于 ArceOS 已经提供了 axtask 用于在单一特权级别下进行运行时控制流管理，我们"
"可以重用其调度器并与之共同发展。"

#: src/architecture/axvisor.md:32
msgid ""
"在虚拟机启动和设置过程中，axvisor 为每个 vCPU 分配 axtask，将任务的入口函数设"
"置为 `vcpu_run()`，如果 vCPU 有专用的物理 CPU 集，它还会初始化 CPU 掩码。"
msgstr ""
"在虚拟机启动和设置过程中，axvisor 为每个 vCPU 分配 axtask，将任务的入口函数设"
"置为 `vcpu_run()`，如果 vCPU 有专用的物理 CPU 集，它还会初始化 CPU 掩码。"

#: src/architecture/axvisor.md:34
msgid "`vcpu_run()`"
msgstr "`vcpu_run()`"

#: src/architecture/axvisor.md:36
msgid "`vcpu_run()` 函数是 vCPU 任务的主要例程，可以总结如下："
msgstr "`vcpu_run()` 函数是 vCPU 任务的主要例程，可以总结如下："

#: src/architecture/axvisor.md:47 src/architecture/multi_layer_VM-Exit.md:118
msgid "// match vcpu.run() {\n"
msgstr "// match vcpu.run() {\n"

#: src/architecture/axvisor.md:52
msgid "// Irq injection logic\n"
msgstr "// Irq injection logic\n"

#: src/architecture/axvisor.md:59
msgid "// Sleep target axtask.\n"
msgstr "// Sleep target axtask.\n"

#: src/architecture/axvisor.md:66
msgid "// Spawn axtask for target vCpu.\n"
msgstr "// Spawn axtask for target vCpu.\n"

#: src/architecture/axvisor.md:72 src/architecture/multi_layer_VM-Exit.md:140
msgid "\"Unhandled VM-Exit\""
msgstr "\"Unhandled VM-Exit\""

#: src/architecture/axvisor.md:81
msgid "Task 扩展"
msgstr "Task 扩展"

#: src/architecture/axvisor.md:83
msgid ""
"该机制允许调用者在不修改 axtask 结构体源代码的情况下自定义其扩展字段，（这是"
"一种类似于线程局部存储（TLS）的轻量级机制）。"
msgstr ""
"该机制允许调用者在不修改 axtask 结构体源代码的情况下自定义其扩展字段，（这是"
"一种类似于线程局部存储（TLS）的轻量级机制）。"

#: src/architecture/axvisor.md:87
msgid "axtask 结构体的基本字段:"
msgstr "axtask 结构体的基本字段:"

#: src/architecture/axvisor.md:89
msgid ""
"任务执行所需的基本信息，包括函数调用上下文、栈指针以及其他运行时元数据。"
msgstr ""
"任务执行所需的基本信息，包括函数调用上下文、栈指针以及其他运行时元数据。"

#: src/architecture/axvisor.md:91
msgid "使用场景"
msgstr "使用场景"

#: src/architecture/axvisor.md:92
msgid "宏内核的扩展"
msgstr "宏内核的扩展"

#: src/architecture/axvisor.md:93
msgid "Process metadata (e.g., PID)"
msgstr "Process metadata (e.g., PID)"

#: src/architecture/axvisor.md:94
msgid "Memory management informations like page table"
msgstr "Memory management informations like page table"

#: src/architecture/axvisor.md:95
msgid "Resource management including fd table"
msgstr "Resource management including fd table"

#: src/architecture/axvisor.md:96 src/architecture/axvisor.md:100
#: src/architecture/vcpu/vcpu.md:11 src/architecture/device/device.md:9
msgid "..."
msgstr "..."

#: src/architecture/axvisor.md:97
msgid "hypervisor 扩展"
msgstr "hypervisor 扩展"

#: src/architecture/axvisor.md:98
msgid "vCPU state"
msgstr "vCPU state"

#: src/architecture/axvisor.md:99
msgid "Metadata of the associated VM"
msgstr "Metadata of the associated VM"

#: src/architecture/axvisor.md:102
msgid "Task 扩展设计"
msgstr "Task 扩展设计"

#: src/architecture/axvisor.md:104
msgid "将 `task_ext_ptr` 引入作为扩展字段"
msgstr "将 `task_ext_ptr` 引入作为扩展字段"

#: src/architecture/axvisor.md:105
msgid "利用基于指针的访问方式，实现与原生结构体字段相当的内存访问性能。"
msgstr "利用基于指针的访问方式，实现与原生结构体字段相当的内存访问性能。"

#: src/architecture/axvisor.md:106
msgid ""
"通过 [def_task_ext](https://arceos.org/arceos/axtask/macro.def_task_ext."
"html) 在编译时确定扩展字段的大小。"
msgstr ""
"通过 [def_task_ext](https://arceos.org/arceos/axtask/macro.def_task_ext."
"html) 在编译时确定扩展字段的大小。"

#: src/architecture/axvisor.md:107
msgid "在堆上分配内存，将扩展字段指针 `task_ext_ptr` 设置为该内存块。"
msgstr "在堆上分配内存，将扩展字段指针 `task_ext_ptr` 设置为该内存块。"

#: src/architecture/axvisor.md:108
msgid "暴露引用 API 供外部访问"
msgstr "暴露引用 API 供外部访问"

#: src/architecture/axvisor.md:109
msgid "由 `init_task_ext` 初始化"
msgstr "由 `init_task_ext` 初始化"

#: src/architecture/axvisor.md:112
msgid "// arceos/modules/axtask/src/task_ext.rs\n"
msgstr "// arceos/modules/axtask/src/task_ext.rs\n"

#: src/architecture/axvisor.md:119
msgid "/// Get a reference to the task extended data.\n"
msgstr "/// Get a reference to the task extended data.\n"

#: src/architecture/axvisor.md:128
msgid "\"assertion failed: !ptr.is_null()\""
msgstr "\"assertion failed: !ptr.is_null()\""

#: src/architecture/axvisor.md:134
msgid "// arceos/modules/axtask/src/task.rs\n"
msgstr "// arceos/modules/axtask/src/task.rs\n"

#: src/architecture/axvisor.md:137
msgid ""
"/// Returns the pointer to the user-defined task extended data.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The caller should not access the pointer directly, use [`TaskExtRef::"
"task_ext`]\n"
"    /// or [`TaskExtMut::task_ext_mut`] instead.\n"
"    ///\n"
"    /// [`TaskExtRef::task_ext`]: crate::task_ext::TaskExtRef::task_ext\n"
"    /// [`TaskExtMut::task_ext_mut`]: crate::task_ext::TaskExtMut::"
"task_ext_mut\n"
msgstr ""
"/// Returns the pointer to the user-defined task extended data.\n"
"    ///\n"
"    /// # Safety\n"
"    ///\n"
"    /// The caller should not access the pointer directly, use [`TaskExtRef::"
"task_ext`]\n"
"    /// or [`TaskExtMut::task_ext_mut`] instead.\n"
"    ///\n"
"    /// [`TaskExtRef::task_ext`]: crate::task_ext::TaskExtRef::task_ext\n"
"    /// [`TaskExtMut::task_ext_mut`]: crate::task_ext::TaskExtMut::"
"task_ext_mut\n"

#: src/architecture/axvisor.md:150
msgid ""
"/// Initialize the user-defined task extended data.\n"
"    ///\n"
"    /// Returns a reference to the task extended data if it has not been\n"
"    /// initialized yet (empty), otherwise returns [`None`].\n"
msgstr ""
"/// Initialize the user-defined task extended data.\n"
"    ///\n"
"    /// Returns a reference to the task extended data if it has not been\n"
"    /// initialized yet (empty), otherwise returns [`None`].\n"

#: src/architecture/axvisor.md:166
msgid "`TaskExt` in axvisor"
msgstr "`TaskExt` in axvisor"

#: src/architecture/axvisor.md:169
msgid "// axvisor/src/task.rs\n"
msgstr "// axvisor/src/task.rs\n"

#: src/architecture/axvisor.md:173
msgid "/// Task extended data for the hypervisor.\n"
msgstr "/// Task extended data for the hypervisor.\n"

#: src/architecture/axvisor.md:176
msgid "/// The VM.\n"
msgstr "/// The VM.\n"

#: src/architecture/axvisor.md:178
msgid "/// The virtual memory address space.\n"
msgstr "/// The virtual memory address space.\n"

#: src/architecture/axvisor.md:189
msgid "// axvisor/src/vmm/vcpus.rs\n"
msgstr "// axvisor/src/vmm/vcpus.rs\n"

#: src/architecture/axvisor.md:194
msgid "\"VM[{}]-VCpu[{}]\""
msgstr "\"VM[{}]-VCpu[{}]\""

#: src/architecture/axvisor.md:197
#: src/architecture/axvisor_api/comparison.md:26
#: src/architecture/axvisor_api/comparison.md:32
#: src/architecture/axvisor_api/comparison.md:42
#: src/architecture/axvisor_api/comparison.md:46
#: src/architecture/axvisor_api/comparison.md:50
#: src/architecture/axvisor_api/comparison.md:54
#: src/architecture/axvisor_api/comparison.md:76
#: src/architecture/axvisor_api/comparison.md:82
#: src/architecture/axvisor_api/comparison.md:93
#: src/architecture/axvisor_api/comparison.md:97
#: src/architecture/axvisor_api/comparison.md:101
#: src/architecture/axvisor_api/comparison.md:105
#: src/architecture/axvisor_api/comparison.md:137
#: src/architecture/axvisor_api/comparison.md:143
#: src/architecture/axvisor_api/comparison.md:152
#: src/architecture/axvisor_api/comparison.md:156
#: src/architecture/axvisor_api/comparison.md:160
#: src/architecture/axvisor_api/comparison.md:164
#: src/architecture/vcpu/arm_vcpu.md:287
msgid "// ...\n"
msgstr "// ...\n"

#: src/architecture/axvisor.md:203
msgid "irq & timer"
msgstr "irq & timer"

#: src/architecture/axvisor.md:205
msgid "External Interrupt"
msgstr "External Interrupt"

#: src/architecture/axvisor.md:207
msgid ""
"所有来自外部设备的中断都通过多层次的 VM-Exit 处理例程返回给 axvisor 进行处"
"理。因为 只有 axvisor 拥有全局资源管理视角。"
msgstr ""
"所有来自外部设备的中断都通过多层次的 VM-Exit 处理例程返回给 axvisor 进行处"
"理。因为 只有 axvisor 拥有全局资源管理视角。"

#: src/architecture/axvisor.md:209
msgid "axvisor 根据中断号和虚拟机配置文件识别外部中断："
msgstr "axvisor 根据中断号和虚拟机配置文件识别外部中断："

#: src/architecture/axvisor.md:210
msgid ""
"如果中断是预留给 axvisor 的（例如 axvisor 自己的时钟中断），则由 axhal 提供"
"的 ArceOS 中断处理例程来处理。"
msgstr ""
"如果中断是预留给 axvisor 的（例如 axvisor 自己的时钟中断），则由 axhal 提供"
"的 ArceOS 中断处理例程来处理。"

#: src/architecture/axvisor.md:212
msgid ""
"如果中断属于某个客户虚拟机（例如客户虚拟机的直通磁盘中断），则该中断会直接注"
"入到对应的虚拟机。"
msgstr ""
"如果中断属于某个客户虚拟机（例如客户虚拟机的直通磁盘中断），则该中断会直接注"
"入到对应的虚拟机。"

#: src/architecture/axvisor.md:213
msgid ""
"请注意，一些架构的中断控制器可以配置为在不经过 VM-Exit 的情况下直接将外部中断"
"注入到虚拟机中（例如 x86 提供的已发布中断）"
msgstr ""
"请注意，一些架构的中断控制器可以配置为在不经过 VM-Exit 的情况下直接将外部中断"
"注入到虚拟机中（例如 x86 提供的已发布中断）"

#: src/architecture/axvisor.md:215
msgid "Timer"
msgstr "Timer"

#: src/architecture/axvisor.md:217
msgid ""
"草拟设计请参考 [discussion#36](https://github.com/orgs/arceos-hypervisor/"
"discussions/36#discussioncomment-11002988)。"
msgstr ""
"草拟设计请参考 [discussion#36](https://github.com/orgs/arceos-hypervisor/"
"discussions/36#discussioncomment-11002988)。"

#: src/architecture/axvisor_api/comparison.md:1
msgid "Axvisor API：设计的思考与妥协"
msgstr "Axvisor API：设计的思考与妥协"

#: src/architecture/axvisor_api/comparison.md:3
msgid "1. 为什么需要 Axvisor API？"
msgstr "1. 为什么需要 Axvisor API？"

#: src/architecture/axvisor_api/comparison.md:5
msgid ""
"在 Axvisor 的整体架构中，ArceOS 处于最底层，负责提供内存管理、任务调度、设备"
"驱动、同步原语等多种基础功能；这些功能会被 Axvisor 的各个组件所使用。然而，从"
"软件工程的角度上，我们不能让 Axvisor 的各个组件直接依赖于 ArceOS （的 "
"`axstd` 等接口组件）；这一方面是因为我们希望 ArceOS 与 Axvisor 之间的耦合度尽"
"可能的低，这样可以提高系统的可移植性、可扩展性和可维护性，另一方面则是因为，"
"将对 ArceOS 的依赖分散在各个组件中，会使得依赖和 feature 管理变得极度混乱，容"
"易出现各种错误。"
msgstr ""
"在 Axvisor 的整体架构中，ArceOS 处于最底层，负责提供内存管理、任务调度、设备"
"驱动、同步原语等多种基础功能；这些功能会被 Axvisor 的各个组件所使用。然而，从"
"软件工程的角度上，我们不能让 Axvisor 的各个组件直接依赖于 ArceOS （的 "
"`axstd` 等接口组件）；这一方面是因为我们希望 ArceOS 与 Axvisor 之间的耦合度尽"
"可能的低，这样可以提高系统的可移植性、可扩展性和可维护性，另一方面则是因为，"
"将对 ArceOS 的依赖分散在各个组件中，会使得依赖和 feature 管理变得极度混乱，容"
"易出现各种错误。"

#: src/architecture/axvisor_api/comparison.md:7
msgid ""
"因此，我们需要一个统一的接口，收拢对 ArceOS 的依赖，同时提供给 Axvisor 的各个"
"组件使用。在这里也存在着两个选择，第一是这个接口层放置在所有组件的下层，"
"ArceOS 则被接口层直接依赖，位于最底层；第二是这个接口层同样放置在所有组件的下"
"层，但是 ArceOS 与接口层之间并不直接依赖，接口层只提供接口的定义，实现则由最"
"上层的 app 层来完成。显然，第二种方案在耦合度和可移植性上更有优势，因此我们选"
"择了第二种方案。"
msgstr ""
"因此，我们需要一个统一的接口，收拢对 ArceOS 的依赖，同时提供给 Axvisor 的各个"
"组件使用。在这里也存在着两个选择，第一是这个接口层放置在所有组件的下层，"
"ArceOS 则被接口层直接依赖，位于最底层；第二是这个接口层同样放置在所有组件的下"
"层，但是 ArceOS 与接口层之间并不直接依赖，接口层只提供接口的定义，实现则由最"
"上层的 app 层来完成。显然，第二种方案在耦合度和可移植性上更有优势，因此我们选"
"择了第二种方案。"

#: src/architecture/axvisor_api/comparison.md:9
msgid "2. Axvisor API 应该如何实现"
msgstr "2. Axvisor API 应该如何实现"

#: src/architecture/axvisor_api/comparison.md:11
msgid "如何实现这样的定义与实现分离的接口呢？我们有很多可行的方案。"
msgstr "如何实现这样的定义与实现分离的接口呢？我们有很多可行的方案。"

#: src/architecture/axvisor_api/comparison.md:13
msgid ""
"第一种，也是目前所广泛使用的方案，是在下层定义一个 trait，上层实现这个 "
"trait，在需要使用这个 trait 的地方，通过泛型参数来传递这个 trait。例如："
msgstr ""
"第一种，也是目前所广泛使用的方案，是在下层定义一个 trait，上层实现这个 "
"trait，在需要使用这个 trait 的地方，通过泛型参数来传递这个 trait。例如："

#: src/architecture/axvisor_api/comparison.md:16
#: src/architecture/axvisor_api/comparison.md:65
#: src/architecture/axvisor_api/comparison.md:117
msgid "// 下层定义\n"
msgstr "// 下层定义\n"

#: src/architecture/axvisor_api/comparison.md:23
#: src/architecture/axvisor_api/comparison.md:73
#: src/architecture/axvisor_api/comparison.md:134
msgid "// 中层使用\n"
msgstr "// 中层使用\n"

#: src/architecture/axvisor_api/comparison.md:36
#: src/architecture/axvisor_api/comparison.md:86
#: src/architecture/axvisor_api/comparison.md:147
msgid "// 上层实现\n"
msgstr "// 上层实现\n"

#: src/architecture/axvisor_api/comparison.md:59
msgid ""
"这种方案的优点是简单易懂，并且编译器有着非常充分的信息，可以进行很好的优化；"
"实现时也可以很清楚的知道哪些接口是必须实现的。然而，这种方案也有着明显的缺"
"点，那就是，具体的实现必须通过泛型参数一层一层地传递下去，一旦某一个较为下层"
"的组件需要使用一个接口，那么这个接口就必须在所有的中间层都写一遍，这会使得代"
"码的可读性和可维护性变得较差。"
msgstr ""
"这种方案的优点是简单易懂，并且编译器有着非常充分的信息，可以进行很好的优化；"
"实现时也可以很清楚的知道哪些接口是必须实现的。然而，这种方案也有着明显的缺"
"点，那就是，具体的实现必须通过泛型参数一层一层地传递下去，一旦某一个较为下层"
"的组件需要使用一个接口，那么这个接口就必须在所有的中间层都写一遍，这会使得代"
"码的可读性和可维护性变得较差。"

#: src/architecture/axvisor_api/comparison.md:61
msgid ""
"另一种方案则是贾越凯学长所实现的 `crate_interface` 方案。这个方案在链接时通过"
"符号将接口的定义和实现连接起来，通过特殊定义的数个宏，消除了对泛型参数的依"
"赖。"
msgstr ""
"另一种方案则是贾越凯学长所实现的 `crate_interface` 方案。这个方案在链接时通过"
"符号将接口的定义和实现连接起来，通过特殊定义的数个宏，消除了对泛型参数的依"
"赖。"

#: src/architecture/axvisor_api/comparison.md:110
msgid ""
"相比于通过泛型参数进行依赖注入的方案，`crate_interface` 方案的优点在于无需写"
"出泛型参数，代码更加简洁；同时保留了 trait 的定义，能够明确地知道哪些接口是必"
"须实现的。这个方案的缺点在于，调用接口时需要通过宏，这会使得代码的可读性变"
"差；同时，由于接口的实现是通过符号链接的，因此在编译时会有一些限制，例如无法"
"在一个 crate 中同时实现两个相同的接口，不过考虑到我们的需求（调用 ArceOS 的系"
"统功能），这个限制并不会对我们造成太大的困扰。"
msgstr ""
"相比于通过泛型参数进行依赖注入的方案，`crate_interface` 方案的优点在于无需写"
"出泛型参数，代码更加简洁；同时保留了 trait 的定义，能够明确地知道哪些接口是必"
"须实现的。这个方案的缺点在于，调用接口时需要通过宏，这会使得代码的可读性变"
"差；同时，由于接口的实现是通过符号链接的，因此在编译时会有一些限制，例如无法"
"在一个 crate 中同时实现两个相同的接口，不过考虑到我们的需求（调用 ArceOS 的系"
"统功能），这个限制并不会对我们造成太大的困扰。"

#: src/architecture/axvisor_api/comparison.md:112
msgid "3. Axvisor API 的设计与妥协"
msgstr "3. Axvisor API 的设计与妥协"

#: src/architecture/axvisor_api/comparison.md:114
msgid ""
"目前 `axvisor_api` crate 中使用了一种改良的定义接口的方式，即使用 `mod` 组织 "
"API，使用标注在 `mod` 上的 `#[api_mod]` 和 `#[api_mod_impl]` 宏来定义和实现接"
"口。示例如下："
msgstr ""
"目前 `axvisor_api` crate 中使用了一种改良的定义接口的方式，即使用 `mod` 组织 "
"API，使用标注在 `mod` 上的 `#[api_mod]` 和 `#[api_mod_impl]` 宏来定义和实现接"
"口。示例如下："

#: src/architecture/axvisor_api/comparison.md:169
msgid "这种实现方式的优点在于："
msgstr "这种实现方式的优点在于："

#: src/architecture/axvisor_api/comparison.md:171
msgid ""
"组织更加接近于普通的 Rust 模块组织，易于理解；调用接口也使用普通的函数调用语"
"法，对调用者心智负担较小；"
msgstr ""
"组织更加接近于普通的 Rust 模块组织，易于理解；调用接口也使用普通的函数调用语"
"法，对调用者心智负担较小；"

#: src/architecture/axvisor_api/comparison.md:172
msgid ""
"接口模块中可以定义一些辅助和工具内容，方便实用，例如 API 相关的类型别名，基"
"于 API 的简单封装等；"
msgstr ""
"接口模块中可以定义一些辅助和工具内容，方便实用，例如 API 相关的类型别名，基"
"于 API 的简单封装等；"

#: src/architecture/axvisor_api/comparison.md:174
msgid "但是这种实现方式也有一些缺点："
msgstr "但是这种实现方式也有一些缺点："

#: src/architecture/axvisor_api/comparison.md:176
msgid "不容易一次性看出有哪些接口是必须实现的；"
msgstr "不容易一次性看出有哪些接口是必须实现的；"

#: src/architecture/axvisor_api/comparison.md:178
msgid ""
"实际上，这两个宏背后使用了 `crate_interface` crate 作为底层实现；虽然技术上可"
"以绕过 `crate_interface`，只使用 `link_name` 来实现接口，但这样就会完全失去使"
"用 trait 来约束必须实现的接口的优势。而现在虽然使用了 trait，但是视觉上仍然不"
"容易看出哪些接口是必须实现的；针对这一点，`api_mod` 宏现在会自动在文档中生成"
"一个列表，列出所有的接口，方便查看。"
msgstr ""
"实际上，这两个宏背后使用了 `crate_interface` crate 作为底层实现；虽然技术上可"
"以绕过 `crate_interface`，只使用 `link_name` 来实现接口，但这样就会完全失去使"
"用 trait 来约束必须实现的接口的优势。而现在虽然使用了 trait，但是视觉上仍然不"
"容易看出哪些接口是必须实现的；针对这一点，`api_mod` 宏现在会自动在文档中生成"
"一个列表，列出所有的接口，方便查看。"

#: src/architecture/axvisor_api/comparison.md:180
msgid ""
"在 `#[api_mod]` 标注的 `mod` 中，允许所有能够出现在普通 `mod` 中的内容，包括 "
"`struct`、`enum`、`const` 等，这样可能会使得接口模块变得过于臃肿，不易维护；"
msgstr ""
"在 `#[api_mod]` 标注的 `mod` 中，允许所有能够出现在普通 `mod` 中的内容，包括 "
"`struct`、`enum`、`const` 等，这样可能会使得接口模块变得过于臃肿，不易维护；"

#: src/architecture/axvisor_api/comparison.md:182
msgid ""
"这一点可以通过约定来解决，例如只在接口模块中定义接口相关的内容，其他内容放在"
"其他模块中。"
msgstr ""
"这一点可以通过约定来解决，例如只在接口模块中定义接口相关的内容，其他内容放在"
"其他模块中。"

#: src/architecture/axvisor_api/comparison.md:184
msgid ""
"目前，经过与贾越凯、胡柯洋等同学的讨论，我们认为可以先在使用现有泛型参数传递"
"方式极为不便的情况下，使用 `axvisor_api` crate 来实现 API，以评估其实际表现和"
"可用性；如果在实际使用中发现了问题，再考虑是否需要进一步改进。"
msgstr ""
"目前，经过与贾越凯、胡柯洋等同学的讨论，我们认为可以先在使用现有泛型参数传递"
"方式极为不便的情况下，使用 `axvisor_api` crate 来实现 API，以评估其实际表现和"
"可用性；如果在实际使用中发现了问题，再考虑是否需要进一步改进。"

#: src/architecture/axvm.md:1
msgid ""
"[AxVM](https://github.com/arceos-hypervisor/axvm): resource management "
"within each VM"
msgstr ""
"[AxVM](https://github.com/arceos-hypervisor/axvm): resource management "
"within each VM"

#: src/architecture/axvm.md:3
msgid "WIP 🚧"
msgstr "WIP 🚧"

#: src/architecture/axvm.md:5
msgid "address space of guest VM"
msgstr "address space of guest VM"

#: src/architecture/axvm.md:6
msgid "axvcpu list"
msgstr "axvcpu list"

#: src/architecture/axvm.md:7
msgid "axdevice list"
msgstr "axdevice list"

#: src/architecture/axvm.md:10
msgid "/// A Virtual Machine.\n"
msgstr "/// A Virtual Machine.\n"

#: src/architecture/axvm.md:25
msgid "// Todo: use more efficient lock.\n"
msgstr "// Todo: use more efficient lock.\n"

#: src/architecture/vcpu/vcpu.md:1
msgid "AxVCpu: Virtual CPU interface and wrapper for ArceOS."
msgstr "AxVCpu: Virtual CPU interface and wrapper for ArceOS."

#: src/architecture/vcpu/vcpu.md:3
msgid ""
"[axvcpu](https://github.com/arceos-hypervisor/axvcpu) 提供 CPU 虚拟化支持"
msgstr ""
"[axvcpu](https://github.com/arceos-hypervisor/axvcpu) 提供 CPU 虚拟化支持"

#: src/architecture/vcpu/vcpu.md:4
msgid "高度依赖于架构"
msgstr "高度依赖于架构"

#: src/architecture/vcpu/vcpu.md:5
msgid "存储不同架构的异常上下文框架"
msgstr "存储不同架构的异常上下文框架"

#: src/architecture/vcpu/vcpu.md:6
msgid "基本调度项"
msgstr "基本调度项"

#: src/architecture/vcpu/vcpu.md:7
msgid "特定架构的 vCPU 实现需要被分离到独立的 crate 中:"
msgstr "特定架构的 vCPU 实现需要被分离到独立的 crate 中:"

#: src/architecture/vcpu/vcpu.md:8
msgid "[arm_vcpu](https://github.com/arceos-hypervisor/arm_vcpu)"
msgstr "[arm_vcpu](https://github.com/arceos-hypervisor/arm_vcpu)"

#: src/architecture/vcpu/vcpu.md:9
msgid "[x86_vcpu](https://github.com/arceos-hypervisor/x86_vcpu)"
msgstr "[x86_vcpu](https://github.com/arceos-hypervisor/x86_vcpu)"

#: src/architecture/vcpu/vcpu.md:10
msgid "[riscv_vcpu](https://github.com/arceos-hypervisor/riscv_vcpu)"
msgstr "[riscv_vcpu](https://github.com/arceos-hypervisor/riscv_vcpu)"

#: src/architecture/vcpu/vcpu.md:14
msgid ""
"/// A trait for architecture-specific vcpu.\n"
"///\n"
"/// This trait is an abstraction for virtual CPUs of different "
"architectures.\n"
msgstr ""
"/// A trait for architecture-specific vcpu.\n"
"///\n"
"/// This trait is an abstraction for virtual CPUs of different "
"architectures.\n"

#: src/architecture/vcpu/vcpu.md:18
msgid ""
"/// The configuration for creating a new [`AxArchVCpu`]. Used by "
"[`AxArchVCpu::new`].\n"
msgstr ""
"/// The configuration for creating a new [`AxArchVCpu`]. Used by "
"[`AxArchVCpu::new`].\n"

#: src/architecture/vcpu/vcpu.md:20
msgid ""
"/// The configuration for setting up a created [`AxArchVCpu`]. Used by "
"[`AxArchVCpu::setup`].\n"
msgstr ""
"/// The configuration for setting up a created [`AxArchVCpu`]. Used by "
"[`AxArchVCpu::setup`].\n"

#: src/architecture/vcpu/vcpu.md:23
msgid "/// Create a new `AxArchVCpu`.\n"
msgstr "/// Create a new `AxArchVCpu`.\n"

#: src/architecture/vcpu/vcpu.md:26
msgid ""
"/// Set the entry point of the vcpu.\n"
"    ///\n"
"    /// It's guaranteed that this function is called only once, before "
"[`AxArchVCpu::setup`] being called.\n"
msgstr ""
"/// Set the entry point of the vcpu.\n"
"    ///\n"
"    /// It's guaranteed that this function is called only once, before "
"[`AxArchVCpu::setup`] being called.\n"

#: src/architecture/vcpu/vcpu.md:31
msgid ""
"/// Set the EPT root of the vcpu.\n"
"    ///\n"
"    /// It's guaranteed that this function is called only once, before "
"[`AxArchVCpu::setup`] being called.\n"
msgstr ""
"/// Set the EPT root of the vcpu.\n"
"    ///\n"
"    /// It's guaranteed that this function is called only once, before "
"[`AxArchVCpu::setup`] being called.\n"

#: src/architecture/vcpu/vcpu.md:36
msgid ""
"/// Setup the vcpu.\n"
"    ///\n"
"    /// It's guaranteed that this function is called only once, after "
"[`AxArchVCpu::set_entry`] and [`AxArchVCpu::set_ept_root`] being called.\n"
msgstr ""
"/// Setup the vcpu.\n"
"    ///\n"
"    /// It's guaranteed that this function is called only once, after "
"[`AxArchVCpu::set_entry`] and [`AxArchVCpu::set_ept_root`] being called.\n"

#: src/architecture/vcpu/vcpu.md:41
msgid "/// Run the vcpu until a vm-exit occurs.\n"
msgstr "/// Run the vcpu until a vm-exit occurs.\n"

#: src/architecture/vcpu/vcpu.md:44
msgid "/// Bind the vcpu to the current physical CPU.\n"
msgstr "/// Bind the vcpu to the current physical CPU.\n"

#: src/architecture/vcpu/vcpu.md:47
msgid "/// Unbind the vcpu from the current physical CPU.\n"
msgstr "/// Unbind the vcpu from the current physical CPU.\n"

#: src/architecture/vcpu/vcpu.md:50
msgid ""
"/// Set the value of a general-purpose register according to the given "
"index.\n"
msgstr ""
"/// Set the value of a general-purpose register according to the given "
"index.\n"

#: src/architecture/vcpu/vcpu.md:84 src/architecture/vcpu/vcpu.md:171
#: src/architecture/vcpu/vcpu.md:183 src/architecture/irq/vgic.md:665
#: src/architecture/irq/vgic.md:752 src/architecture/irq/vgic.md:764
#: src/architecture/multi_layer_VM-Exit.md:184
#: src/architecture/multi_layer_VM-Exit.md:271
#: src/architecture/multi_layer_VM-Exit.md:283
msgid "\"button\""
msgstr "\"button\""

#: src/architecture/vcpu/vcpu.md:84 src/architecture/irq/vgic.md:665
#: src/architecture/multi_layer_VM-Exit.md:184
msgid "\"scroll-to-top\""
msgstr "\"scroll-to-top\""

#: src/architecture/vcpu/vcpu.md:84 src/architecture/irq/vgic.md:665
#: src/architecture/multi_layer_VM-Exit.md:184
msgid "\"scroll-to-top hidden\""
msgstr "\"scroll-to-top hidden\""

#: src/architecture/vcpu/vcpu.md:84 src/architecture/irq/vgic.md:665
#: src/architecture/multi_layer_VM-Exit.md:184
msgid "\"scrollToTop()\""
msgstr "\"scrollToTop()\""

#: src/architecture/vcpu/vcpu.md:85 src/architecture/irq/vgic.md:666
#: src/architecture/multi_layer_VM-Exit.md:185
msgid "\"fa fa-angle-up\""
msgstr "\"fa fa-angle-up\""

#: src/architecture/vcpu/vcpu.md:88 src/architecture/irq/vgic.md:669
#: src/architecture/multi_layer_VM-Exit.md:188
msgid "\"smooth\""
msgstr "\"smooth\""

#: src/architecture/vcpu/vcpu.md:89 src/architecture/irq/vgic.md:670
#: src/architecture/multi_layer_VM-Exit.md:189
msgid "\"scroll\""
msgstr "\"scroll\""

#: src/architecture/vcpu/vcpu.md:90 src/architecture/irq/vgic.md:671
#: src/architecture/multi_layer_VM-Exit.md:190
msgid "\".scroll-to-top\""
msgstr "\".scroll-to-top\""

#: src/architecture/vcpu/vcpu.md:91 src/architecture/irq/vgic.md:672
#: src/architecture/multi_layer_VM-Exit.md:191
msgid "\"hidden\""
msgstr "\"hidden\""

#: src/architecture/vcpu/vcpu.md:116 src/architecture/vcpu/vcpu.md:132
#: src/architecture/irq/vgic.md:697 src/architecture/irq/vgic.md:713
#: src/architecture/multi_layer_VM-Exit.md:216
#: src/architecture/multi_layer_VM-Exit.md:232
msgid "\"ocean\""
msgstr "\"ocean\""

#: src/architecture/vcpu/vcpu.md:120 src/architecture/vcpu/vcpu.md:136
#: src/architecture/irq/vgic.md:701 src/architecture/irq/vgic.md:717
#: src/architecture/multi_layer_VM-Exit.md:220
#: src/architecture/multi_layer_VM-Exit.md:236
msgid "\"forest\""
msgstr "\"forest\""

#: src/architecture/vcpu/vcpu.md:124 src/architecture/vcpu/vcpu.md:140
#: src/architecture/irq/vgic.md:705 src/architecture/irq/vgic.md:721
#: src/architecture/multi_layer_VM-Exit.md:224
#: src/architecture/multi_layer_VM-Exit.md:240
msgid "\"lava\""
msgstr "\"lava\""

#: src/architecture/vcpu/vcpu.md:168 src/architecture/irq/vgic.md:749
#: src/architecture/multi_layer_VM-Exit.md:268
msgid "\"display: none\""
msgstr "\"display: none\""

#: src/architecture/vcpu/vcpu.md:168 src/architecture/irq/vgic.md:749
#: src/architecture/multi_layer_VM-Exit.md:268
msgid "\"0.2.11\""
msgstr "\"0.2.11\""

#: src/architecture/vcpu/vcpu.md:168 src/architecture/irq/vgic.md:749
#: src/architecture/multi_layer_VM-Exit.md:268
msgid "\"announcement-banner\""
msgstr "\"announcement-banner\""

#: src/architecture/vcpu/vcpu.md:168 src/architecture/irq/vgic.md:749
#: src/architecture/multi_layer_VM-Exit.md:268
msgid "\"default\""
msgstr "\"default\""

#: src/architecture/vcpu/vcpu.md:175 src/architecture/irq/vgic.md:756
#: src/architecture/multi_layer_VM-Exit.md:275
msgid "\".announcement-banner\""
msgstr "\".announcement-banner\""

#: src/architecture/vcpu/vcpu.md:176 src/architecture/irq/vgic.md:757
#: src/architecture/multi_layer_VM-Exit.md:276
msgid "\"data-id\""
msgstr "\"data-id\""

#: src/architecture/vcpu/vcpu.md:177 src/architecture/irq/vgic.md:758
#: src/architecture/multi_layer_VM-Exit.md:277
msgid "\"p\""
msgstr "\"p\""

#: src/architecture/vcpu/vcpu.md:178 src/architecture/vcpu/vcpu.md:185
#: src/architecture/irq/vgic.md:759 src/architecture/irq/vgic.md:766
#: src/architecture/multi_layer_VM-Exit.md:278
#: src/architecture/multi_layer_VM-Exit.md:285
msgid "\"mdbook-announcement-banner\""
msgstr "\"mdbook-announcement-banner\""

#: src/architecture/vcpu/vcpu.md:180 src/architecture/irq/vgic.md:761
#: src/architecture/multi_layer_VM-Exit.md:280
msgid "\"flex\""
msgstr "\"flex\""

#: src/architecture/vcpu/vcpu.md:181 src/architecture/irq/vgic.md:762
#: src/architecture/multi_layer_VM-Exit.md:281
msgid "\".page\""
msgstr "\".page\""

#: src/architecture/vcpu/vcpu.md:183 src/architecture/vcpu/vcpu.md:220
#: src/architecture/irq/vgic.md:764 src/architecture/irq/vgic.md:801
#: src/architecture/multi_layer_VM-Exit.md:283
#: src/architecture/multi_layer_VM-Exit.md:320
msgid "\"click\""
msgstr "\"click\""

#: src/architecture/vcpu/vcpu.md:196 src/architecture/irq/vgic.md:777
#: src/architecture/multi_layer_VM-Exit.md:296
msgid "\"https://giscus.app/client.js\""
msgstr "\"https://giscus.app/client.js\""

#: src/architecture/vcpu/vcpu.md:197 src/architecture/irq/vgic.md:778
#: src/architecture/multi_layer_VM-Exit.md:297
msgid "\"arceos-hypervisor/doc\""
msgstr "\"arceos-hypervisor/doc\""

#: src/architecture/vcpu/vcpu.md:198 src/architecture/irq/vgic.md:779
#: src/architecture/multi_layer_VM-Exit.md:298
msgid "\"R_kgDOLMHfvQ\""
msgstr "\"R_kgDOLMHfvQ\""

#: src/architecture/vcpu/vcpu.md:199 src/architecture/irq/vgic.md:780
#: src/architecture/multi_layer_VM-Exit.md:299
msgid "\"Comments\""
msgstr "\"Comments\""

#: src/architecture/vcpu/vcpu.md:200 src/architecture/irq/vgic.md:781
#: src/architecture/multi_layer_VM-Exit.md:300
msgid "\"DIC_kwDOLMHfvc4CoqAB\""
msgstr "\"DIC_kwDOLMHfvc4CoqAB\""

#: src/architecture/vcpu/vcpu.md:201 src/architecture/irq/vgic.md:782
#: src/architecture/multi_layer_VM-Exit.md:301
msgid "\"title\""
msgstr "\"title\""

#: src/architecture/vcpu/vcpu.md:202 src/architecture/vcpu/vcpu.md:204
#: src/architecture/irq/vgic.md:783 src/architecture/irq/vgic.md:785
#: src/architecture/multi_layer_VM-Exit.md:302
#: src/architecture/multi_layer_VM-Exit.md:304
msgid "\"0\""
msgstr "\"0\""

#: src/architecture/vcpu/vcpu.md:203 src/architecture/irq/vgic.md:784
#: src/architecture/multi_layer_VM-Exit.md:303
msgid "\"1\""
msgstr "\"1\""

#: src/architecture/vcpu/vcpu.md:205 src/architecture/irq/vgic.md:786
#: src/architecture/multi_layer_VM-Exit.md:305
msgid "\"bottom\""
msgstr "\"bottom\""

#: src/architecture/vcpu/vcpu.md:206 src/architecture/vcpu/vcpu.md:216
#: src/architecture/irq/vgic.md:787 src/architecture/irq/vgic.md:797
#: src/architecture/multi_layer_VM-Exit.md:306
#: src/architecture/multi_layer_VM-Exit.md:316
msgid "\"light\""
msgstr "\"light\""

#: src/architecture/vcpu/vcpu.md:207 src/architecture/irq/vgic.md:788
#: src/architecture/multi_layer_VM-Exit.md:307
msgid "\"zh-CN\""
msgstr "\"zh-CN\""

#: src/architecture/vcpu/vcpu.md:208 src/architecture/irq/vgic.md:789
#: src/architecture/multi_layer_VM-Exit.md:308
msgid "\"eager\""
msgstr "\"eager\""

#: src/architecture/vcpu/vcpu.md:209 src/architecture/irq/vgic.md:790
#: src/architecture/multi_layer_VM-Exit.md:309
msgid "\"anonymous\""
msgstr "\"anonymous\""

#: src/architecture/vcpu/vcpu.md:214 src/architecture/irq/vgic.md:795
#: src/architecture/multi_layer_VM-Exit.md:314
msgid "\"script[data-repo][data-repo-id]\""
msgstr "\"script[data-repo][data-repo-id]\""

#: src/architecture/vcpu/vcpu.md:215 src/architecture/vcpu/vcpu.md:218
#: src/architecture/irq/vgic.md:796 src/architecture/irq/vgic.md:799
#: src/architecture/multi_layer_VM-Exit.md:315
#: src/architecture/multi_layer_VM-Exit.md:318
msgid "\"data-theme\""
msgstr "\"data-theme\""

#: src/architecture/vcpu/vcpu.md:215 src/architecture/irq/vgic.md:796
#: src/architecture/multi_layer_VM-Exit.md:315
msgid "\"book\""
msgstr "\"book\""

#: src/architecture/vcpu/vcpu.md:216 src/architecture/irq/vgic.md:797
#: src/architecture/multi_layer_VM-Exit.md:316
msgid "\"rust\""
msgstr "\"rust\""

#: src/architecture/vcpu/vcpu.md:216 src/architecture/irq/vgic.md:797
#: src/architecture/multi_layer_VM-Exit.md:316
msgid "\"dark\""
msgstr "\"dark\""

#: src/architecture/vcpu/vcpu.md:217 src/architecture/irq/vgic.md:798
#: src/architecture/multi_layer_VM-Exit.md:317
msgid "\"mdbook-theme\""
msgstr "\"mdbook-theme\""

#: src/architecture/vcpu/vcpu.md:217 src/architecture/irq/vgic.md:798
#: src/architecture/multi_layer_VM-Exit.md:317
msgid "\"class\""
msgstr "\"class\""

#: src/architecture/vcpu/vcpu.md:219 src/architecture/irq/vgic.md:800
#: src/architecture/multi_layer_VM-Exit.md:319
msgid "\"button[role='menuitem'].theme\""
msgstr "\"button[role='menuitem'].theme\""

#: src/architecture/vcpu/vcpu.md:222 src/architecture/irq/vgic.md:803
#: src/architecture/multi_layer_VM-Exit.md:322
msgid "\"iframe.giscus-frame\""
msgstr "\"iframe.giscus-frame\""

#: src/architecture/vcpu/vcpu.md:223 src/architecture/irq/vgic.md:804
#: src/architecture/multi_layer_VM-Exit.md:323
msgid "\"*\""
msgstr "\"*\""

#: src/architecture/vcpu/x86_vcpu.md:1
msgid "[x86_64](https://github.com/arceos-hypervisor/x86_vcpu)"
msgstr "[x86_64](https://github.com/arceos-hypervisor/x86_vcpu)"

#: src/architecture/vcpu/x86_vcpu.md:5 src/architecture/memory.md:3
msgid "介绍"
msgstr "介绍"

#: src/architecture/vcpu/x86_vcpu.md:7
msgid "定义 x86_64 架构的 vCPU 结构和虚拟化相关接口支持。"
msgstr "定义 x86_64 架构的 vCPU 结构和虚拟化相关接口支持。"

#: src/architecture/vcpu/x86_vcpu.md:9
msgid ""
"crate 用户必须使用 [`crate_interface::impl_interface`](https://crates.io/"
"crates/crate_interface) 实现 `PhysFrameIf` trait，以提供 `PhysFrame` 分配和释"
"放的低级实现，相关实现可参考 [ArceOS](https://github.com/arceos-org/arceos/"
"blob/main/modules/axhal/src/paging.rs)。"
msgstr ""
"crate 用户必须使用 [`crate_interface::impl_interface`](https://crates.io/"
"crates/crate_interface) 实现 `PhysFrameIf` trait，以提供 `PhysFrame` 分配和释"
"放的低级实现，相关实现可参考 [ArceOS](https://github.com/arceos-org/arceos/"
"blob/main/modules/axhal/src/paging.rs)。"

#: src/architecture/vcpu/x86_vcpu.md:11
msgid "Example"
msgstr "Example"

#: src/architecture/vcpu/x86_vcpu.md:13
msgid ""
"```\n"
"use x86_vcpu::PhysFrameIf;\n"
"\n"
"struct PhysFrameIfImpl;\n"
"\n"
"#[crate_interface::impl_interface]\n"
"impl axvm::PhysFrameIf for PhysFrameIfImpl {\n"
"    fn alloc_frame() -> Option<PhysAddr> {\n"
"        // Your implementation here\n"
"    }\n"
"    fn dealloc_frame(paddr: PhysAddr) {\n"
"        // Your implementation here\n"
"    }\n"
"    fn phys_to_virt(paddr: PhysAddr) -> VirtAddr {\n"
"        // Your implementation here\n"
"    }\n"
"}\n"
"```"
msgstr ""
"```\n"
"use x86_vcpu::PhysFrameIf;\n"
"\n"
"struct PhysFrameIfImpl;\n"
"\n"
"#[crate_interface::impl_interface]\n"
"impl axvm::PhysFrameIf for PhysFrameIfImpl {\n"
"    fn alloc_frame() -> Option<PhysAddr> {\n"
"        // Your implementation here\n"
"    }\n"
"    fn dealloc_frame(paddr: PhysAddr) {\n"
"        // Your implementation here\n"
"    }\n"
"    fn phys_to_virt(paddr: PhysAddr) -> VirtAddr {\n"
"        // Your implementation here\n"
"    }\n"
"}\n"
"```"

#: src/architecture/vcpu/x86_vcpu.md:32 src/architecture/memory.md:10
msgid "系统架构"
msgstr "系统架构"

#: src/architecture/vcpu/x86_vcpu.md:34 src/architecture/memory.md:12
msgid "模块组织"
msgstr "模块组织"

#: src/architecture/vcpu/x86_vcpu.md:54
msgid "核心组件"
msgstr "核心组件"

#: src/architecture/vcpu/x86_vcpu.md:56
msgid "`VmxVcpu`: 虚拟 CPU 实现，管理客户机状态和执行"
msgstr "`VmxVcpu`: 虚拟 CPU 实现，管理客户机状态和执行"

#: src/architecture/vcpu/x86_vcpu.md:57
msgid "`VmxPerCpuState`: 每物理 CPU 的 VMX 状态"
msgstr "`VmxPerCpuState`: 每物理 CPU 的 VMX 状态"

#: src/architecture/vcpu/x86_vcpu.md:58
msgid "`VMCS` 管理: 虚拟机控制结构字段的读写操作"
msgstr "`VMCS` 管理: 虚拟机控制结构字段的读写操作"

#: src/architecture/vcpu/x86_vcpu.md:59
msgid "`EPT` 控制: 扩展页表配置和违规处理"
msgstr "`EPT` 控制: 扩展页表配置和违规处理"

#: src/architecture/vcpu/x86_vcpu.md:60
msgid "物理内存管理: 通过 PhysFrame 抽象管理物理内存"
msgstr "物理内存管理: 通过 PhysFrame 抽象管理物理内存"

#: src/architecture/vcpu/x86_vcpu.md:62 src/architecture/memory.md:36
msgid "关键数据结构"
msgstr "关键数据结构"

#: src/architecture/vcpu/x86_vcpu.md:64
msgid "`GeneralRegisters`"
msgstr "`GeneralRegisters`"

#: src/architecture/vcpu/x86_vcpu.md:65
msgid "用于存储和操作 X86_64 通用寄存器状态："
msgstr "用于存储和操作 X86_64 通用寄存器状态："

#: src/architecture/vcpu/x86_vcpu.md:72
msgid "// ... 其他寄存器\n"
msgstr "// ... 其他寄存器\n"

#: src/architecture/vcpu/x86_vcpu.md:76
msgid "提供按索引访问和修改寄存器值的方法："
msgstr "提供按索引访问和修改寄存器值的方法："

#: src/architecture/vcpu/x86_vcpu.md:78
msgid "`get_reg_of_index(index: u8) -> u64`"
msgstr "`get_reg_of_index(index: u8) -> u64`"

#: src/architecture/vcpu/x86_vcpu.md:79
msgid "`set_reg_of_index(index: u8, value: u64)`"
msgstr "`set_reg_of_index(index: u8, value: u64)`"

#: src/architecture/vcpu/x86_vcpu.md:81
msgid "`VmxVcpu`"
msgstr "`VmxVcpu`"

#: src/architecture/vcpu/x86_vcpu.md:82
msgid "虚拟 CPU 的核心实现："
msgstr "虚拟 CPU 的核心实现："

#: src/architecture/vcpu/x86_vcpu.md:84
msgid ""
"```\n"
"pub struct VmxVcpu<H: AxVCpuHal> {\n"
"    guest_regs: GeneralRegisters,\n"
"    host_stack_top: u64,\n"
"    launched: bool,\n"
"    vmcs: VmxRegion<H>,\n"
"    io_bitmap: IOBitmap<H>,\n"
"    msr_bitmap: MsrBitmap<H>,\n"
"    // ... 其他字段\n"
"}\n"
"```"
msgstr ""
"```\n"
"pub struct VmxVcpu<H: AxVCpuHal> {\n"
"    guest_regs: GeneralRegisters,\n"
"    host_stack_top: u64,\n"
"    launched: bool,\n"
"    vmcs: VmxRegion<H>,\n"
"    io_bitmap: IOBitmap<H>,\n"
"    msr_bitmap: MsrBitmap<H>,\n"
"    // ... 其他字段\n"
"}\n"
"```"

#: src/architecture/vcpu/x86_vcpu.md:96
msgid "`GuestPageWalkInfo`"
msgstr "`GuestPageWalkInfo`"

#: src/architecture/vcpu/x86_vcpu.md:97
msgid "存储客户机页表遍历所需的信息："
msgstr "存储客户机页表遍历所需的信息："

#: src/architecture/vcpu/x86_vcpu.md:99
msgid ""
"```\n"
"pub struct GuestPageWalkInfo {\n"
"    pub top_entry: usize,\n"
"    pub level: usize,\n"
"    pub width: u32,\n"
"    // ... 权限和控制位\n"
"}\n"
"```"
msgstr ""
"```\n"
"pub struct GuestPageWalkInfo {\n"
"    pub top_entry: usize,\n"
"    pub level: usize,\n"
"    pub width: u32,\n"
"    // ... 权限和控制位\n"
"}\n"
"```"

#: src/architecture/vcpu/x86_vcpu.md:108
msgid "`PhysFrame`"
msgstr "`PhysFrame`"

#: src/architecture/vcpu/x86_vcpu.md:109
msgid "物理内存页面的安全抽象："
msgstr "物理内存页面的安全抽象："

#: src/architecture/vcpu/x86_vcpu.md:118 src/architecture/memory.md:52
msgid "核心功能实现"
msgstr "核心功能实现"

#: src/architecture/vcpu/x86_vcpu.md:119
msgid "VCPU 生命周期管理"
msgstr "VCPU 生命周期管理"

#: src/architecture/vcpu/x86_vcpu.md:121
msgid ""
"```\n"
"// 创建新的虚拟 CPU\n"
"pub fn new() -> AxResult<Self> { ... }\n"
"\n"
"// 配置虚拟 CPU\n"
"pub fn setup(&mut self, ept_root: HostPhysAddr, entry: GuestPhysAddr) -> "
"AxResult { ... }\n"
"\n"
"// 绑定到当前物理 CPU\n"
"pub fn bind_to_current_processor(&self) -> AxResult { ... }\n"
"\n"
"// 执行客户机代码\n"
"pub fn inner_run(&mut self) -> Option<VmxExitInfo> { ... }\n"
"```"
msgstr ""
"```\n"
"// 创建新的虚拟 CPU\n"
"pub fn new() -> AxResult<Self> { ... }\n"
"\n"
"// 配置虚拟 CPU\n"
"pub fn setup(&mut self, ept_root: HostPhysAddr, entry: GuestPhysAddr) -> "
"AxResult { ... }\n"
"\n"
"// 绑定到当前物理 CPU\n"
"pub fn bind_to_current_processor(&self) -> AxResult { ... }\n"
"\n"
"// 执行客户机代码\n"
"pub fn inner_run(&mut self) -> Option<VmxExitInfo> { ... }\n"
"```"

#: src/architecture/vcpu/x86_vcpu.md:135
msgid "VMCS 设置"
msgstr "VMCS 设置"

#: src/architecture/vcpu/x86_vcpu.md:145
msgid "VM 进入/退出处理"
msgstr "VM 进入/退出处理"

#: src/architecture/vcpu/x86_vcpu.md:147
msgid ""
"```\n"
"#[naked]\n"
"unsafe extern \"C\" fn vmx_launch(&mut self) -> usize { ... }\n"
"\n"
"#[naked]\n"
"unsafe extern \"C\" fn vmx_resume(&mut self) -> usize { ... }\n"
"\n"
"fn builtin_vmexit_handler(&mut self, exit_info: &VmxExitInfo) -> "
"Option<AxResult> { ... }\n"
"```"
msgstr ""
"```\n"
"#[naked]\n"
"unsafe extern \"C\" fn vmx_launch(&mut self) -> usize { ... }\n"
"\n"
"#[naked]\n"
"unsafe extern \"C\" fn vmx_resume(&mut self) -> usize { ... }\n"
"\n"
"fn builtin_vmexit_handler(&mut self, exit_info: &VmxExitInfo) -> "
"Option<AxResult> { ... }\n"
"```"

#: src/architecture/vcpu/x86_vcpu.md:157
msgid "事件注入"
msgstr "事件注入"

#: src/architecture/vcpu/x86_vcpu.md:159
msgid ""
"```\n"
"/// Add a virtual interrupt or exception to the pending events list,\n"
"/// and try to inject it before later VM entries.\n"
"pub fn queue_event(&mut self, vector: u8, err_code: Option<u32>) { ... }\n"
"\n"
"/// Try to inject a pending event before next VM entry.\n"
"fn inject_pending_events(&mut self) -> AxResult { ... }\n"
"```"
msgstr ""
"```\n"
"/// Add a virtual interrupt or exception to the pending events list,\n"
"/// and try to inject it before later VM entries.\n"
"pub fn queue_event(&mut self, vector: u8, err_code: Option<u32>) { ... }\n"
"\n"
"/// Try to inject a pending event before next VM entry.\n"
"fn inject_pending_events(&mut self) -> AxResult { ... }\n"
"```"

#: src/architecture/vcpu/x86_vcpu.md:168
msgid "I/O 和 MSR 拦截"
msgstr "I/O 和 MSR 拦截"

#: src/architecture/vcpu/x86_vcpu.md:170
msgid ""
"```\n"
"/// Set I/O intercept by modifying I/O bitmap.\n"
"pub fn set_io_intercept_of_range(&mut self, port_base: u32, count: u32, "
"intercept: bool) { ... }\n"
"\n"
"/// Set msr intercept by modifying msr bitmap.\n"
"pub fn set_msr_intercept_of_range(&mut self, msr: u32, intercept: bool) "
"{ ... }\n"
"```"
msgstr ""
"```\n"
"/// Set I/O intercept by modifying I/O bitmap.\n"
"pub fn set_io_intercept_of_range(&mut self, port_base: u32, count: u32, "
"intercept: bool) { ... }\n"
"\n"
"/// Set msr intercept by modifying msr bitmap.\n"
"pub fn set_msr_intercept_of_range(&mut self, msr: u32, intercept: bool) "
"{ ... }\n"
"```"

#: src/architecture/vcpu/x86_vcpu.md:178
msgid "关键技术"
msgstr "关键技术"

#: src/architecture/vcpu/x86_vcpu.md:179
msgid "VMX 操作模式"
msgstr "VMX 操作模式"

#: src/architecture/vcpu/x86_vcpu.md:180
msgid "实现了完整的 VMX 操作模式切换："
msgstr "实现了完整的 VMX 操作模式切换："

#: src/architecture/vcpu/x86_vcpu.md:182
msgid "通过 `VMXON` 指令进入 VMX 操作模式"
msgstr "通过 `VMXON` 指令进入 VMX 操作模式"

#: src/architecture/vcpu/x86_vcpu.md:183
msgid "通过 `VMLAUNCH` 和 `VMRESUME` 指令执行客户机代码"
msgstr "通过 `VMLAUNCH` 和 `VMRESUME` 指令执行客户机代码"

#: src/architecture/vcpu/x86_vcpu.md:184
msgid "通过 VM 退出处理程序响应客户机事件"
msgstr "通过 VM 退出处理程序响应客户机事件"

#: src/architecture/vcpu/x86_vcpu.md:186
msgid "嵌套分页 (EPT)"
msgstr "嵌套分页 (EPT)"

#: src/architecture/vcpu/x86_vcpu.md:187
msgid "使用扩展页表实现高效内存虚拟化："
msgstr "使用扩展页表实现高效内存虚拟化："

#: src/architecture/vcpu/x86_vcpu.md:189
msgid "配置 EPT 指针 (EPTP)"
msgstr "配置 EPT 指针 (EPTP)"

#: src/architecture/vcpu/x86_vcpu.md:190
msgid "处理 EPT 违规事件"
msgstr "处理 EPT 违规事件"

#: src/architecture/vcpu/x86_vcpu.md:191
msgid "支持内存访问权限控制"
msgstr "支持内存访问权限控制"

#: src/architecture/vcpu/x86_vcpu.md:193
msgid "寄存器状态切换"
msgstr "寄存器状态切换"

#: src/architecture/vcpu/x86_vcpu.md:195
msgid "通过X86汇编代码实现状态切换："
msgstr "通过X86汇编代码实现状态切换："

#: src/architecture/vcpu/x86_vcpu.md:197
msgid "`save_regs_to_stack!` 宏保存寄存器状态到堆栈"
msgstr "`save_regs_to_stack!` 宏保存寄存器状态到堆栈"

#: src/architecture/vcpu/x86_vcpu.md:198
msgid "`restore_regs_from_stack!` 宏从堆栈恢复寄存器状态"
msgstr "`restore_regs_from_stack!` 宏从堆栈恢复寄存器状态"

#: src/architecture/vcpu/x86_vcpu.md:199
msgid "特殊处理栈指针 (RSP) 以确保正确的状态切换"
msgstr "特殊处理栈指针 (RSP) 以确保正确的状态切换"

#: src/architecture/vcpu/x86_vcpu.md:201
msgid "指令模拟"
msgstr "指令模拟"

#: src/architecture/vcpu/x86_vcpu.md:203
msgid "为特定指令提供模拟实现："
msgstr "为特定指令提供模拟实现："

#: src/architecture/vcpu/x86_vcpu.md:205
msgid "CPUID 指令模拟，提供自定义处理器信息"
msgstr "CPUID 指令模拟，提供自定义处理器信息"

#: src/architecture/vcpu/x86_vcpu.md:206
msgid "XSETBV 指令处理，管理扩展状态"
msgstr "XSETBV 指令处理，管理扩展状态"

#: src/architecture/vcpu/x86_vcpu.md:207
msgid "CR 寄存器访问处理"
msgstr "CR 寄存器访问处理"

#: src/architecture/vcpu/x86_vcpu.md:209 src/architecture/vcpu/arm_vcpu.md:265
msgid "内存管理"
msgstr "内存管理"

#: src/architecture/vcpu/x86_vcpu.md:211
msgid "物理内存分配"
msgstr "物理内存分配"

#: src/architecture/vcpu/x86_vcpu.md:213
msgid "通过 PhysFrame 抽象提供安全的物理内存管理："
msgstr "通过 PhysFrame 抽象提供安全的物理内存管理："

#: src/architecture/vcpu/x86_vcpu.md:215
msgid "自动释放不再使用的物理页面"
msgstr "自动释放不再使用的物理页面"

#: src/architecture/vcpu/x86_vcpu.md:216
msgid "支持零填充和自定义初始化"
msgstr "支持零填充和自定义初始化"

#: src/architecture/vcpu/x86_vcpu.md:217
msgid "提供物理地址到虚拟地址的转换"
msgstr "提供物理地址到虚拟地址的转换"

#: src/architecture/vcpu/x86_vcpu.md:219
msgid "EPT 页表管理"
msgstr "EPT 页表管理"

#: src/architecture/vcpu/x86_vcpu.md:221
msgid "实现二级地址转换机制："
msgstr "实现二级地址转换机制："

#: src/architecture/vcpu/x86_vcpu.md:223
msgid "创建和管理 EPT 页表结构"
msgstr "创建和管理 EPT 页表结构"

#: src/architecture/vcpu/x86_vcpu.md:224
msgid "支持不同的页面粒度 (4KB, 2MB, 1GB)"
msgstr "支持不同的页面粒度 (4KB, 2MB, 1GB)"

#: src/architecture/vcpu/x86_vcpu.md:225
msgid "处理页面权限和访问控制"
msgstr "处理页面权限和访问控制"

#: src/architecture/vcpu/arm_vcpu.md:1
msgid "[aarch64](https://github.com/arceos-hypervisor/arm_vcpu)"
msgstr "[aarch64](https://github.com/arceos-hypervisor/arm_vcpu)"

#: src/architecture/vcpu/arm_vcpu.md:5
msgid "ARM 虚拟化简介"
msgstr "ARM 虚拟化简介"

#: src/architecture/vcpu/arm_vcpu.md:7
msgid ""
"ARM 的硬件辅助虚拟化技术叫做 ARM-V (Virtualization) 技术，从 ARMv8 开始比较好"
"的支持这种硬件辅助虚拟化技术。类似 X86 根/非根模式，ARM 引入多个异常级来控制"
"资源访问权限。宿主机上 VMM 运行在 EL2 层，客户机操作系统运行在 EL1 层，应用程"
"序运行在 EL0 层。"
msgstr ""
"ARM 的硬件辅助虚拟化技术叫做 ARM-V (Virtualization) 技术，从 ARMv8 开始比较好"
"的支持这种硬件辅助虚拟化技术。类似 X86 根/非根模式，ARM 引入多个异常级来控制"
"资源访问权限。宿主机上 VMM 运行在 EL2 层，客户机操作系统运行在 EL1 层，应用程"
"序运行在 EL0 层。"

#: src/architecture/vcpu/arm_vcpu.md:9
msgid ""
"ARMv8 的异常级分为 4 级（EL0~EL3），权限也是从低到高。同时也分了两个 CPU 运行"
"状态（Non-secure 和 Secure），顾名思义为了安全和非安全的运行态，此处不扩展。"
"每一级运行的内容如下图所示："
msgstr ""
"ARMv8 的异常级分为 4 级（EL0~EL3），权限也是从低到高。同时也分了两个 CPU 运行"
"状态（Non-secure 和 Secure），顾名思义为了安全和非安全的运行态，此处不扩展。"
"每一级运行的内容如下图所示："

#: src/architecture/vcpu/arm_vcpu.md:11
msgid "![](../../assets/arm_vcpu.webp)"
msgstr "![](../../assets/arm_vcpu.webp)"

#: src/architecture/vcpu/arm_vcpu.md:13
msgid ""
"运行在不同异常级最大的区别就是能够访问的寄存器组不同，同时也影响了某些硬件行"
"为（比如对页表的 lookup）。运行在高异常级时可以访问低异常级的寄存器组，反之不"
"行。 为了切换到更高的异常级（主动触发某个异常级的异常），需要主动执行特殊的指"
"令： • Supervisor Call (SVC)。一般由 EL0 切换到 EL1 的指令，会进入 EL1 的异常"
"向量表。 • Hypervisor Call (HVC) 。Non-secure EL1 切换到 EL2 的指令，会进入"
"到 EL2 的异常向量表。 • Secure monitor Call (SMC) 。切换到 EL3 的指令，只有"
"在 EL1、EL2 执行有效。"
msgstr ""
"运行在不同异常级最大的区别就是能够访问的寄存器组不同，同时也影响了某些硬件行"
"为（比如对页表的 lookup）。运行在高异常级时可以访问低异常级的寄存器组，反之不"
"行。 为了切换到更高的异常级（主动触发某个异常级的异常），需要主动执行特殊的指"
"令： • Supervisor Call (SVC)。一般由 EL0 切换到 EL1 的指令，会进入 EL1 的异常"
"向量表。 • Hypervisor Call (HVC) 。Non-secure EL1 切换到 EL2 的指令，会进入"
"到 EL2 的异常向量表。 • Secure monitor Call (SMC) 。切换到 EL3 的指令，只有"
"在 EL1、EL2 执行有效。"

#: src/architecture/vcpu/arm_vcpu.md:19
msgid "项目概述"
msgstr "项目概述"

#: src/architecture/vcpu/arm_vcpu.md:21
msgid ""
"arm_vcpu 是 axvisor 项目的重要组成部分，特别为 ARM 架构设计的虚拟 CPU 实现。"
"该项目提供了在 ARM64 架构上实现虚拟机（VM）的底层组件，使操作系统或 "
"hypervisor 能够创建和管理虚拟 CPU，进而运行客户操作系统。"
msgstr ""
"arm_vcpu 是 axvisor 项目的重要组成部分，特别为 ARM 架构设计的虚拟 CPU 实现。"
"该项目提供了在 ARM64 架构上实现虚拟机（VM）的底层组件，使操作系统或 "
"hypervisor 能够创建和管理虚拟 CPU，进而运行客户操作系统。"

#: src/architecture/vcpu/arm_vcpu.md:23
msgid "核心组件结构"
msgstr "核心组件结构"

#: src/architecture/vcpu/arm_vcpu.md:25
msgid "主要模块"
msgstr "主要模块"

#: src/architecture/vcpu/arm_vcpu.md:27
msgid "项目包含以下核心模块："
msgstr "项目包含以下核心模块："

#: src/architecture/vcpu/arm_vcpu.md:29
msgid "**context_frame**: 定义了 ARM64 CPU 上下文帧结构"
msgstr "**context_frame**: 定义了 ARM64 CPU 上下文帧结构"

#: src/architecture/vcpu/arm_vcpu.md:30
msgid "**exception**: 处理异常和 VM 退出"
msgstr "**exception**: 处理异常和 VM 退出"

#: src/architecture/vcpu/arm_vcpu.md:31
msgid "**exception_utils**: 提供异常处理的工具函数"
msgstr "**exception_utils**: 提供异常处理的工具函数"

#: src/architecture/vcpu/arm_vcpu.md:32
msgid "**pcpu**: 物理 CPU 相关功能的实现"
msgstr "**pcpu**: 物理 CPU 相关功能的实现"

#: src/architecture/vcpu/arm_vcpu.md:33
msgid "**smc**: 安全监视器调用实现"
msgstr "**smc**: 安全监视器调用实现"

#: src/architecture/vcpu/arm_vcpu.md:34
msgid "**vcpu**: 虚拟 CPU 的核心实现"
msgstr "**vcpu**: 虚拟 CPU 的核心实现"

#: src/architecture/vcpu/arm_vcpu.md:36
msgid "核心数据结构"
msgstr "核心数据结构"

#: src/architecture/vcpu/arm_vcpu.md:38
msgid "Aarch64ContextFrame (src/context_frame.rs)"
msgstr "Aarch64ContextFrame (src/context_frame.rs)"

#: src/architecture/vcpu/arm_vcpu.md:42
msgid "// 通用寄存器\n"
msgstr "// 通用寄存器\n"

#: src/architecture/vcpu/arm_vcpu.md:43
msgid "// EL0 栈指针\n"
msgstr "// EL0 栈指针\n"

#: src/architecture/vcpu/arm_vcpu.md:44
msgid "// 异常链接寄存器\n"
msgstr "// 异常链接寄存器\n"

#: src/architecture/vcpu/arm_vcpu.md:45
msgid "// 保存的程序状态寄存器\n"
msgstr "// 保存的程序状态寄存器\n"

#: src/architecture/vcpu/arm_vcpu.md:49
msgid ""
"这个结构体代表了一个完整的 ARM64 CPU 上下文，包含了 CPU 的通用寄存器、栈指"
"针、返回地址和状态标志。当发生 VM 切换时，这些寄存器需要保存和恢复。"
msgstr ""
"这个结构体代表了一个完整的 ARM64 CPU 上下文，包含了 CPU 的通用寄存器、栈指"
"针、返回地址和状态标志。当发生 VM 切换时，这些寄存器需要保存和恢复。"

#: src/architecture/vcpu/arm_vcpu.md:51
msgid "GuestSystemRegisters (src/context_frame.rs)"
msgstr "GuestSystemRegisters (src/context_frame.rs)"

#: src/architecture/vcpu/arm_vcpu.md:55
msgid "// 通用定时器相关寄存器\n"
msgstr "// 通用定时器相关寄存器\n"

#: src/architecture/vcpu/arm_vcpu.md:59
msgid "// 虚拟ID寄存器\n"
msgstr "// 虚拟ID寄存器\n"

#: src/architecture/vcpu/arm_vcpu.md:63
msgid "// EL1/EL0 寄存器\n"
msgstr "// EL1/EL0 寄存器\n"

#: src/architecture/vcpu/arm_vcpu.md:68
msgid "// Hypervisor上下文\n"
msgstr "// Hypervisor上下文\n"

#: src/architecture/vcpu/arm_vcpu.md:75
msgid ""
"这个结构体包含了客户虚拟机的系统寄存器状态，包括定时器寄存器、CPU ID、异常控"
"制、内存管理等。这些寄存器在 VM 进入/退出时需要保存和恢复。"
msgstr ""
"这个结构体包含了客户虚拟机的系统寄存器状态，包括定时器寄存器、CPU ID、异常控"
"制、内存管理等。这些寄存器在 VM 进入/退出时需要保存和恢复。"

#: src/architecture/vcpu/arm_vcpu.md:77
msgid "Aarch64VCpu (src/vcpu.rs)"
msgstr "Aarch64VCpu (src/vcpu.rs)"

#: src/architecture/vcpu/arm_vcpu.md:89
msgid "Aarch64VCpu 是实现虚拟 CPU 的核心结构体，包含了虚拟 CPU 的完整状态："
msgstr "Aarch64VCpu 是实现虚拟 CPU 的核心结构体，包含了虚拟 CPU 的完整状态："

#: src/architecture/vcpu/arm_vcpu.md:91
msgid "`ctx`: 保存客户 VM 的 CPU 上下文"
msgstr "`ctx`: 保存客户 VM 的 CPU 上下文"

#: src/architecture/vcpu/arm_vcpu.md:92
msgid "`host_stack_top`: 主机栈顶指针，用于 VM 退出时恢复主机上下文"
msgstr "`host_stack_top`: 主机栈顶指针，用于 VM 退出时恢复主机上下文"

#: src/architecture/vcpu/arm_vcpu.md:93
msgid "`guest_system_regs`: 客户系统寄存器状态"
msgstr "`guest_system_regs`: 客户系统寄存器状态"

#: src/architecture/vcpu/arm_vcpu.md:94
msgid "`mpidr`: 多处理器 ID 寄存器值"
msgstr "`mpidr`: 多处理器 ID 寄存器值"

#: src/architecture/vcpu/arm_vcpu.md:96
msgid "关键功能实现"
msgstr "关键功能实现"

#: src/architecture/vcpu/arm_vcpu.md:98
msgid "VCPU 初始化和运行"
msgstr "VCPU 初始化和运行"

#: src/architecture/vcpu/arm_vcpu.md:100
msgid ""
"VCPU 的初始化在 `Aarch64VCpu::new()` 方法中实现，设置初始化 CPU 寄存器和系统"
"状态："
msgstr ""
"VCPU 的初始化在 `Aarch64VCpu::new()` 方法中实现，设置初始化 CPU 寄存器和系统"
"状态："

#: src/architecture/vcpu/arm_vcpu.md:117
msgid "VCPU 的运行在 `run()` 方法中实现："
msgstr "VCPU 的运行在 `run()` 方法中实现："

#: src/architecture/vcpu/arm_vcpu.md:122
msgid "// 保存主机 SP_EL0 到上下文中\n"
msgstr "// 保存主机 SP_EL0 到上下文中\n"

#: src/architecture/vcpu/arm_vcpu.md:128
msgid "\"Invalid TrapKind\""
msgstr "\"Invalid TrapKind\""

#: src/architecture/vcpu/arm_vcpu.md:133
msgid "异常处理机制"
msgstr "异常处理机制"

#: src/architecture/vcpu/arm_vcpu.md:135
msgid ""
"异常处理是通过异常向量表和处理函数实现的。异常向量表在 `exception.S` 中定义："
msgstr ""
"异常处理是通过异常向量表和处理函数实现的。异常向量表在 `exception.S` 中定义："

#: src/architecture/vcpu/arm_vcpu.md:137
msgid ""
"```assembly\n"
".section .text\n"
".p2align 11\n"
".global exception_vector_base_vcpu\n"
"exception_vector_base_vcpu:\n"
"    // current EL, with SP_EL0\n"
"    INVALID_EXCP_EL2 0 0\n"
"    ...\n"
"    // lower EL, aarch64\n"
"    HANDLE_LOWER_SYNC_VCPU\n"
"    HANDLE_LOWER_IRQ_VCPU\n"
"    ...\n"
"```"
msgstr ""
"```assembly\n"
".section .text\n"
".p2align 11\n"
".global exception_vector_base_vcpu\n"
"exception_vector_base_vcpu:\n"
"    // current EL, with SP_EL0\n"
"    INVALID_EXCP_EL2 0 0\n"
"    ...\n"
"    // lower EL, aarch64\n"
"    HANDLE_LOWER_SYNC_VCPU\n"
"    HANDLE_LOWER_IRQ_VCPU\n"
"    ...\n"
"```"

#: src/architecture/vcpu/arm_vcpu.md:151
msgid "同步异常处理在 `handle_exception_sync` 函数中实现："
msgstr "同步异常处理在 `handle_exception_sync` 函数中实现："

#: src/architecture/vcpu/arm_vcpu.md:163
msgid "// 处理超级调用\n"
msgstr "// 处理超级调用\n"

#: src/architecture/vcpu/arm_vcpu.md:171
msgid "VM 进入/退出流程"
msgstr "VM 进入/退出流程"

#: src/architecture/vcpu/arm_vcpu.md:173
msgid "VM 进入是通过 `run_guest()` 函数实现的："
msgstr "VM 进入是通过 `run_guest()` 函数实现的："

#: src/architecture/vcpu/arm_vcpu.md:179
msgid "// 保存主机上下文\n"
msgstr "// 保存主机上下文\n"

#: src/architecture/vcpu/arm_vcpu.md:181
msgid "\"mov x9, sp\""
msgstr "\"mov x9, sp\""

#: src/architecture/vcpu/arm_vcpu.md:182
msgid "\"mov x10, x11\""
msgstr "\"mov x10, x11\""

#: src/architecture/vcpu/arm_vcpu.md:183
msgid ""
"// 保存当前主机栈顶到 Aarch64VCpu 结构中\n"
"            \"str x9, [x10]\""
msgstr ""
"// 保存当前主机栈顶到 Aarch64VCpu 结构中\n"
"            \"str x9, [x10]\""

#: src/architecture/vcpu/arm_vcpu.md:185
msgid "\"mov x0, x11\""
msgstr "\"mov x0, x11\""

#: src/architecture/vcpu/arm_vcpu.md:186
msgid "\"b context_vm_entry\""
msgstr "\"b context_vm_entry\""

#: src/architecture/vcpu/arm_vcpu.md:187
msgid "\"x11\""
msgstr "\"x11\""

#: src/architecture/vcpu/arm_vcpu.md:192
msgid "// 返回值，实际返回值是在 x0 中，当 return_run_guest 返回时\n"
msgstr "// 返回值，实际返回值是在 x0 中，当 return_run_guest 返回时\n"

#: src/architecture/vcpu/arm_vcpu.md:197
msgid "VM 退出是通过 `vmexit_handler()` 函数处理的："
msgstr "VM 退出是通过 `vmexit_handler()` 函数处理的："

#: src/architecture/vcpu/arm_vcpu.md:202
msgid "// 保存客户系统寄存器\n"
msgstr "// 保存客户系统寄存器\n"

#: src/architecture/vcpu/arm_vcpu.md:205
msgid "// 保存客户 SP_EL0 到 Aarch64VCpu 结构中\n"
msgstr "// 保存客户 SP_EL0 到 Aarch64VCpu 结构中\n"

#: src/architecture/vcpu/arm_vcpu.md:208
msgid "// 恢复主机的 SP_EL0\n"
msgstr "// 恢复主机的 SP_EL0\n"

#: src/architecture/vcpu/arm_vcpu.md:217
msgid "\"Unhandled exception {:?}\""
msgstr "\"Unhandled exception {:?}\""

#: src/architecture/vcpu/arm_vcpu.md:222
msgid "物理 CPU 初始化"
msgstr "物理 CPU 初始化"

#: src/architecture/vcpu/arm_vcpu.md:224
msgid ""
"物理 CPU 初始化在 `Aarch64PerCpu::new()` 和 `hardware_enable()` 方法中实现："
msgstr ""
"物理 CPU 初始化在 `Aarch64PerCpu::new()` 和 `hardware_enable()` 方法中实现："

#: src/architecture/vcpu/arm_vcpu.md:228
msgid "// 首先保存原始异常向量表基址\n"
msgstr "// 首先保存原始异常向量表基址\n"

#: src/architecture/vcpu/arm_vcpu.md:231
msgid "// 设置当前 VBAR_EL2 为本 crate 中定义的 exception_vector_base_vcpu\n"
msgstr "// 设置当前 VBAR_EL2 为本 crate 中定义的 exception_vector_base_vcpu\n"

#: src/architecture/vcpu/arm_vcpu.md:234
msgid "// 启用虚拟化功能\n"
msgstr "// 启用虚拟化功能\n"

#: src/architecture/vcpu/arm_vcpu.md:247
msgid "关键机制解析"
msgstr "关键机制解析"

#: src/architecture/vcpu/arm_vcpu.md:249
msgid "上下文切换机制"
msgstr "上下文切换机制"

#: src/architecture/vcpu/arm_vcpu.md:251
msgid "上下文切换是虚拟化的核心机制，包括以下步骤："
msgstr "上下文切换是虚拟化的核心机制，包括以下步骤："

#: src/architecture/vcpu/arm_vcpu.md:253
msgid "**VM 进入时**:"
msgstr "**VM 进入时**:"

#: src/architecture/vcpu/arm_vcpu.md:255
msgid "保存主机上下文（通用寄存器、栈指针）"
msgstr "保存主机上下文（通用寄存器、栈指针）"

#: src/architecture/vcpu/arm_vcpu.md:256
msgid "加载客户 VM 上下文和系统寄存器"
msgstr "加载客户 VM 上下文和系统寄存器"

#: src/architecture/vcpu/arm_vcpu.md:257
msgid "通过 `eret` 指令切换到 VM 执行"
msgstr "通过 `eret` 指令切换到 VM 执行"

#: src/architecture/vcpu/arm_vcpu.md:259
msgid "**VM 退出时**:"
msgstr "**VM 退出时**:"

#: src/architecture/vcpu/arm_vcpu.md:260
msgid "通过异常向量捕获退出事件"
msgstr "通过异常向量捕获退出事件"

#: src/architecture/vcpu/arm_vcpu.md:261
msgid "保存客户 VM 上下文和系统寄存器"
msgstr "保存客户 VM 上下文和系统寄存器"

#: src/architecture/vcpu/arm_vcpu.md:262
msgid "恢复主机上下文"
msgstr "恢复主机上下文"

#: src/architecture/vcpu/arm_vcpu.md:263
msgid "返回 VM 退出原因"
msgstr "返回 VM 退出原因"

#: src/architecture/vcpu/arm_vcpu.md:267
msgid ""
"虚拟 CPU 的内存管理主要通过 `EPT` (Extended Page Table) 或 ARM 中的第二阶段地"
"址转换实现："
msgstr ""
"虚拟 CPU 的内存管理主要通过 `EPT` (Extended Page Table) 或 ARM 中的第二阶段地"
"址转换实现："

#: src/architecture/vcpu/arm_vcpu.md:271
msgid "\"set vcpu ept root:{:#x}\""
msgstr "\"set vcpu ept root:{:#x}\""

#: src/architecture/vcpu/arm_vcpu.md:277
msgid "内存访问异常由 `handle_data_abort` 处理："
msgstr "内存访问异常由 `handle_data_abort` 处理："

#: src/architecture/vcpu/arm_vcpu.md:305
msgid "中断和异常处理"
msgstr "中断和异常处理"

#: src/architecture/vcpu/arm_vcpu.md:307
msgid ""
"中断和异常处理通过异常向量表和对应的处理函数实现。系统提供了以下主要异常处理"
"路径："
msgstr ""
"中断和异常处理通过异常向量表和对应的处理函数实现。系统提供了以下主要异常处理"
"路径："

#: src/architecture/vcpu/arm_vcpu.md:309
msgid "**同步异常处理**：处理客户 VM 的指令执行异常"
msgstr "**同步异常处理**：处理客户 VM 的指令执行异常"

#: src/architecture/vcpu/arm_vcpu.md:310
msgid "**中断处理**：处理物理中断并将其路由到适当的目标（主机或客户 VM）"
msgstr "**中断处理**：处理物理中断并将其路由到适当的目标（主机或客户 VM）"

#: src/architecture/vcpu/arm_vcpu.md:311
msgid "**SMC 调用处理**：安全监控器调用的处理"
msgstr "**SMC 调用处理**：安全监控器调用的处理"

#: src/architecture/vcpu/arm_vcpu.md:313
msgid "附 1：参考资料"
msgstr "附 1：参考资料"

#: src/architecture/vcpu/arm_vcpu.md:315
msgid "ARM 官方虚拟化手册："
msgstr "ARM 官方虚拟化手册："

#: src/architecture/vcpu/arm_vcpu.md:317
msgid ""
"[Introduction to virtualization](https://developer.arm.com/"
"documentation/102142/0100/Introduction-to-virtualization)"
msgstr ""
"[Introduction to virtualization](https://developer.arm.com/"
"documentation/102142/0100/Introduction-to-virtualization)"

#: src/architecture/vcpu/arm_vcpu.md:318
msgid ""
"[Armv8-A virtualization](https://developer.arm.com/-/media/"
"Arm%20Developer%20Community/PDF/Learn%20the%20Architecture/Armv8-"
"A%20virtualization.pdf?revision=a765a7df-1a00-434d-b241-357bfda2dd31)"
msgstr ""
"[Armv8-A virtualization](https://developer.arm.com/-/media/"
"Arm%20Developer%20Community/PDF/Learn%20the%20Architecture/Armv8-"
"A%20virtualization.pdf?revision=a765a7df-1a00-434d-b241-357bfda2dd31)"

#: src/architecture/vcpu/riscv_vcpu.md:3
msgid "本节介绍在RISC-V体系结构中，与**CPU虚拟化**相关的基本知识、原理和设计。"
msgstr ""
"本节介绍在RISC-V体系结构中，与**CPU虚拟化**相关的基本知识、原理和设计。"

#: src/architecture/vcpu/riscv_vcpu.md:5
msgid "体系结构的虚拟化扩展 'H'"
msgstr "体系结构的虚拟化扩展 'H'"

#: src/architecture/vcpu/riscv_vcpu.md:7
msgid ""
"与x86等体系架构类似，RISC-V也采取了硬件辅助虚拟化的方式，以提升虚拟化效率，这"
"种方式表现为对体系结构的一个扩展，代号'H'。"
msgstr ""
"与x86等体系架构类似，RISC-V也采取了硬件辅助虚拟化的方式，以提升虚拟化效率，这"
"种方式表现为对体系结构的一个扩展，代号'H'。"

#: src/architecture/vcpu/riscv_vcpu.md:13
msgid ""
"上图来自RISC-V官方文档，可以看出，虚拟化扩展'H' 在原有的**非虚拟化世界**基础"
"上创造了一个平行的**虚拟化世界**。"
msgstr ""
"上图来自RISC-V官方文档，可以看出，虚拟化扩展'H' 在原有的**非虚拟化世界**基础"
"上创造了一个平行的**虚拟化世界**。"

#: src/architecture/vcpu/riscv_vcpu.md:15
msgid ""
"虚拟化世界是一个虚拟的计算机环境，它包含了两个特权级，正好可以满足各类主流的"
"客户操作系统（Guest OS）设计与机制上对特权级保护的需要，其中**VS**用于运行"
"Guest OS的内核，**VU**用于运行Guest OS支撑的用户态应用。只要不触及**敏感指令"
"**，整个Guest OS及其之上的应用都只会在这个虚拟世界中运行，如此就保证了较高的"
"执行效率；只有执行到**敏感指令**，虚拟世界无法提供虚拟化支持时，才会跳回到非"
"虚拟化世界，此时Hypervisor接管系统执行权，处理虚拟世界模式中无法处理的情况"
"后，再返回到虚拟世界中继续运行。"
msgstr ""
"虚拟化世界是一个虚拟的计算机环境，它包含了两个特权级，正好可以满足各类主流的"
"客户操作系统（Guest OS）设计与机制上对特权级保护的需要，其中**VS**用于运行"
"Guest OS的内核，**VU**用于运行Guest OS支撑的用户态应用。只要不触及**敏感指令"
"**，整个Guest OS及其之上的应用都只会在这个虚拟世界中运行，如此就保证了较高的"
"执行效率；只有执行到**敏感指令**，虚拟世界无法提供虚拟化支持时，才会跳回到非"
"虚拟化世界，此时Hypervisor接管系统执行权，处理虚拟世界模式中无法处理的情况"
"后，再返回到虚拟世界中继续运行。"

#: src/architecture/vcpu/riscv_vcpu.md:17
msgid ""
"特权级**HS**是让两个世界相互切换机制得以实现的关键，Hypervisor就运行在这个特"
"权级。该特权级在原有**S**特权级的基础上增加了一些特性与机制，针对虚拟化，新增"
"了一些寄存器，扩展了某些寄存器的属性位，例如，在一个特殊的寄存器标志位的控制"
"下，HS特权级可以决定是向**U**还是向**VS**返回。（后面专门说明该寄存器标志位）"
msgstr ""
"特权级**HS**是让两个世界相互切换机制得以实现的关键，Hypervisor就运行在这个特"
"权级。该特权级在原有**S**特权级的基础上增加了一些特性与机制，针对虚拟化，新增"
"了一些寄存器，扩展了某些寄存器的属性位，例如，在一个特殊的寄存器标志位的控制"
"下，HS特权级可以决定是向**U**还是向**VS**返回。（后面专门说明该寄存器标志位）"

#: src/architecture/vcpu/riscv_vcpu.md:19
msgid "下面为'H'扩展的相关概念和机制给出更准确的描述。"
msgstr "下面为'H'扩展的相关概念和机制给出更准确的描述。"

#: src/architecture/vcpu/riscv_vcpu.md:21
msgid "非虚拟化世界 - 基本模式，或简称H-Mode。（在x86体系结构中，称为根模式）"
msgstr "非虚拟化世界 - 基本模式，或简称H-Mode。（在x86体系结构中，称为根模式）"

#: src/architecture/vcpu/riscv_vcpu.md:23
msgid "虚拟化世界 - 虚拟模式，或简称V-Mode。（在x86体系结构中，称为非根模式）"
msgstr "虚拟化世界 - 虚拟模式，或简称V-Mode。（在x86体系结构中，称为非根模式）"

#: src/architecture/vcpu/riscv_vcpu.md:25
msgid ""
"按照'H'扩展的设计，模式与特权级之间是**正交**的关系。图1虽然直观，但未能很好"
"的体现这种正交的关系，它应该是受到了**模拟器**层次示意图的影响。但Hypervisor"
"与模拟器还是有明确的区别。下面是更准确的图示："
msgstr ""
"按照'H'扩展的设计，模式与特权级之间是**正交**的关系。图1虽然直观，但未能很好"
"的体现这种正交的关系，它应该是受到了**模拟器**层次示意图的影响。但Hypervisor"
"与模拟器还是有明确的区别。下面是更准确的图示："

#: src/architecture/vcpu/riscv_vcpu.md:31
msgid ""
"虚拟机是对物理机的“高效”复制，高效主要体现在虚拟机与物理机的“同质性”上，核心"
"是CPU指令集的兼容，让虚拟机需要执行的大多数指令都可以不须翻译过程，而直接运行"
"在物理CPU上。"
msgstr ""
"虚拟机是对物理机的“高效”复制，高效主要体现在虚拟机与物理机的“同质性”上，核心"
"是CPU指令集的兼容，让虚拟机需要执行的大多数指令都可以不须翻译过程，而直接运行"
"在物理CPU上。"

#: src/architecture/vcpu/riscv_vcpu.md:33
msgid ""
"Guest所在的虚拟机运行在V-Mode模式中，一般的CPU指令直接由物理CPU执行，并不需要"
"Hypervisor这一层次的中介干预，这是主流；只是在触及敏感指令才会切换到H-Mode，"
"由Hypervisor处理。由于触及敏感指令是相对少数的情况，所以上面的正交关系示意图"
"应该是更为合理的表述。"
msgstr ""
"Guest所在的虚拟机运行在V-Mode模式中，一般的CPU指令直接由物理CPU执行，并不需要"
"Hypervisor这一层次的中介干预，这是主流；只是在触及敏感指令才会切换到H-Mode，"
"由Hypervisor处理。由于触及敏感指令是相对少数的情况，所以上面的正交关系示意图"
"应该是更为合理的表述。"

#: src/architecture/vcpu/riscv_vcpu.md:35
msgid ""
"本节只是涉及CPU虚拟化，事实上，对于内存和设备虚拟化来说，如果Hypervisor已经完"
"成了特定物理页帧与Guest的分配关联，如果对特定外设采取了Passthrough的方案，那"
"么Guest在运行中同样是直通物理硬件，而不需要Hypervisor作为中介干预的，"
"Hypervisor在此类情况下，只是提前为Guest做了setup的工作。"
msgstr ""
"本节只是涉及CPU虚拟化，事实上，对于内存和设备虚拟化来说，如果Hypervisor已经完"
"成了特定物理页帧与Guest的分配关联，如果对特定外设采取了Passthrough的方案，那"
"么Guest在运行中同样是直通物理硬件，而不需要Hypervisor作为中介干预的，"
"Hypervisor在此类情况下，只是提前为Guest做了setup的工作。"

#: src/architecture/vcpu/riscv_vcpu.md:37
msgid "CPU虚拟化涉及的关键对象及相互关系"
msgstr "CPU虚拟化涉及的关键对象及相互关系"

#: src/architecture/vcpu/riscv_vcpu.md:39
msgid ""
"在CPU虚拟化方面涉及的关键对象主要包括vCPU、虚拟机VM、物理CPU、任务Task和运行"
"队列RUN_QUEUE，其中任务Task与运行队列由ArceOS提供，Hypervisor基于对它们的扩展"
"和使用来实现所需的功能，它们的关系如下："
msgstr ""
"在CPU虚拟化方面涉及的关键对象主要包括vCPU、虚拟机VM、物理CPU、任务Task和运行"
"队列RUN_QUEUE，其中任务Task与运行队列由ArceOS提供，Hypervisor基于对它们的扩展"
"和使用来实现所需的功能，它们的关系如下："

#: src/architecture/vcpu/riscv_vcpu.md:43
msgid "以vCPU为起点进行分析，它是虚拟化世界中逻辑执行的主体。"
msgstr "以vCPU为起点进行分析，它是虚拟化世界中逻辑执行的主体。"

#: src/architecture/vcpu/riscv_vcpu.md:45
msgid ""
"每个虚拟机VM至少有一个vCPU，称为Primary vCPU，也是Boot vCPU。在此基础上，虚拟"
"机VM可以包含更多的Secondary vCPU。这些从属于同一个虚拟机的vCPU在执行上是相互"
"独立的，它们可以在不同的物理CPU上被同时调度执行。"
msgstr ""
"每个虚拟机VM至少有一个vCPU，称为Primary vCPU，也是Boot vCPU。在此基础上，虚拟"
"机VM可以包含更多的Secondary vCPU。这些从属于同一个虚拟机的vCPU在执行上是相互"
"独立的，它们可以在不同的物理CPU上被同时调度执行。"

#: src/architecture/vcpu/riscv_vcpu.md:47
msgid ""
"vCPU实现的基础是ArceOS中的Task，它们可以看作是同一个对象在不同层面各自的表现"
"形式，即在虚拟世界中表现为vCPU，而在ArceOS Hypervisor中的运行形式就是Task。"
msgstr ""
"vCPU实现的基础是ArceOS中的Task，它们可以看作是同一个对象在不同层面各自的表现"
"形式，即在虚拟世界中表现为vCPU，而在ArceOS Hypervisor中的运行形式就是Task。"

#: src/architecture/vcpu/riscv_vcpu.md:49
msgid ""
"每个物理CPU有自己的RUN_QUEUE，如果想指定vCPU在某个或某组物理CPU上执行，只要把"
"vCPU对应Task调度到相应的RUN_QUEUE即可。"
msgstr ""
"每个物理CPU有自己的RUN_QUEUE，如果想指定vCPU在某个或某组物理CPU上执行，只要把"
"vCPU对应Task调度到相应的RUN_QUEUE即可。"

#: src/architecture/vcpu/riscv_vcpu.md:51
msgid "虚拟机首次启动前的准备"
msgstr "虚拟机首次启动前的准备"

#: src/architecture/vcpu/riscv_vcpu.md:53
msgid ""
"虚拟机VM首次启动前，Hypervisor需要为其检查和准备必要的条件。与CPU相关的核心工"
"作："
msgstr ""
"虚拟机VM首次启动前，Hypervisor需要为其检查和准备必要的条件。与CPU相关的核心工"
"作："

#: src/architecture/vcpu/riscv_vcpu.md:55
msgid "检查确认硬件平台支持‘H'扩展"
msgstr "检查确认硬件平台支持‘H'扩展"

#: src/architecture/vcpu/riscv_vcpu.md:57
msgid ""
"底层平台必须支持RISC-V的’H'扩展，首先OpenSBI固件在启动时会检查misa寄存器的第7"
"个状态位，如果是1表示支持虚拟化扩展。"
msgstr ""
"底层平台必须支持RISC-V的’H'扩展，首先OpenSBI固件在启动时会检查misa寄存器的第7"
"个状态位，如果是1表示支持虚拟化扩展。"

#: src/architecture/vcpu/riscv_vcpu.md:61
msgid ""
"Hypervisor可以通过查看OpenSBI的输出来确定是否支持。但目前Hypervisor采取的方式"
"是：直接尝试读hgatp，如果读失败，则说明底层平台不支持‘H’扩展。"
msgstr ""
"Hypervisor可以通过查看OpenSBI的输出来确定是否支持。但目前Hypervisor采取的方式"
"是：直接尝试读hgatp，如果读失败，则说明底层平台不支持‘H’扩展。"

#: src/architecture/vcpu/riscv_vcpu.md:63
msgid "OpenSBI可以通过把misa的第7位设置为0，来从固件层面关闭对虚拟化的支持。"
msgstr "OpenSBI可以通过把misa的第7位设置为0，来从固件层面关闭对虚拟化的支持。"

#: src/architecture/vcpu/riscv_vcpu.md:65
msgid "设置寄存器hstatus状态，为切换到虚拟化模式做准备"
msgstr "设置寄存器hstatus状态，为切换到虚拟化模式做准备"

#: src/architecture/vcpu/riscv_vcpu.md:67
msgid ""
"特权级HS是U特权级切换和VS特权级切换的汇聚点，执行sret进行特权级返回时，通过"
"hstatus的SPV这一位来确定返回的方向。"
msgstr ""
"特权级HS是U特权级切换和VS特权级切换的汇聚点，执行sret进行特权级返回时，通过"
"hstatus的SPV这一位来确定返回的方向。"

#: src/architecture/vcpu/riscv_vcpu.md:69
msgid ""
"SPV这一位的作用是保存进入HS特权级之前的原始模式，如果是0，表示之前是非虚拟化"
"模式，即从U特权级切换而来；如果是1，表示之前是在虚拟化模式中运行，即从VS特权"
"级切换而来。"
msgstr ""
"SPV这一位的作用是保存进入HS特权级之前的原始模式，如果是0，表示之前是非虚拟化"
"模式，即从U特权级切换而来；如果是1，表示之前是在虚拟化模式中运行，即从VS特权"
"级切换而来。"

#: src/architecture/vcpu/riscv_vcpu.md:73
msgid ""
"Hypervisor在首次进入虚拟机之前，把hstatus的SPV设置为1，这样将来在执行sret时就"
"能够确保进入到虚拟机中运行。"
msgstr ""
"Hypervisor在首次进入虚拟机之前，把hstatus的SPV设置为1，这样将来在执行sret时就"
"能够确保进入到虚拟机中运行。"

#: src/architecture/vcpu/riscv_vcpu.md:75
msgid "设置Guest寄存器sepc和sstatus，指定Guest OS 内核最初启动的指令地址和状态"
msgstr ""
"设置Guest寄存器sepc和sstatus，指定Guest OS 内核最初启动的指令地址和状态"

#: src/architecture/vcpu/riscv_vcpu.md:77
msgid ""
"预先为Guest伪造现场，当虚拟器首次启动时，将从Guest OS内核的入口开始执行。"
msgstr ""
"预先为Guest伪造现场，当虚拟器首次启动时，将从Guest OS内核的入口开始执行。"

#: src/architecture/vcpu/riscv_vcpu.md:83
msgid ""
"准备工作完成后，Hypervisor通过VM-Entry过程首次启动虚拟机（实际是启动Primary "
"vCPU），由此进入一个循环："
msgstr ""
"准备工作完成后，Hypervisor通过VM-Entry过程首次启动虚拟机（实际是启动Primary "
"vCPU），由此进入一个循环："

#: src/architecture/vcpu/riscv_vcpu.md:87
msgid ""
"虚拟机启动后，Guest OS的内核与用户态应用在虚拟环境中运行，如同在物理机器中运"
"行；触及敏感指令时将触发VM-Exit过程，退出虚拟化模式，控制权返回到Hypervisor，"
"Hypervisor根据退出原因进行相应的处理，然后再次经由VM-Entry过程进入虚拟机，"
"Guest将从上次执行的断点处恢复执行，如同从未被打断执行一样。如此循环往复，直至"
"虚拟机关闭。"
msgstr ""
"虚拟机启动后，Guest OS的内核与用户态应用在虚拟环境中运行，如同在物理机器中运"
"行；触及敏感指令时将触发VM-Exit过程，退出虚拟化模式，控制权返回到Hypervisor，"
"Hypervisor根据退出原因进行相应的处理，然后再次经由VM-Entry过程进入虚拟机，"
"Guest将从上次执行的断点处恢复执行，如同从未被打断执行一样。如此循环往复，直至"
"虚拟机关闭。"

#: src/architecture/vcpu/riscv_vcpu.md:89
msgid "VM-Entry: 从Host到Guest"
msgstr "VM-Entry: 从Host到Guest"

#: src/architecture/vcpu/riscv_vcpu.md:91
msgid ""
"VM-Entry是从Host环境进入Guest环境的过程，在体系结构的层面看，物理CPU需要完成"
"从非虚拟化模式到虚拟化模式的切换。在切换过程中，一些跨模式共享的寄存器就可能"
"遭到破坏。因此，Hypervisor需要在物理层执行切换前，预先保存部分寄存器组的状态"
"到Host上下文中。此外，物理层面的模式切换完成后，会立即基于当时的寄存器状态继"
"续工作，因此还需要在模式切换前，从Guest上下文中恢复相关寄存器到上次离开Guest"
"环境到状态。vCPU代表了虚拟环境中独立的执行流，因此Host和Guest上下文同一由vCPU"
"来维护。"
msgstr ""
"VM-Entry是从Host环境进入Guest环境的过程，在体系结构的层面看，物理CPU需要完成"
"从非虚拟化模式到虚拟化模式的切换。在切换过程中，一些跨模式共享的寄存器就可能"
"遭到破坏。因此，Hypervisor需要在物理层执行切换前，预先保存部分寄存器组的状态"
"到Host上下文中。此外，物理层面的模式切换完成后，会立即基于当时的寄存器状态继"
"续工作，因此还需要在模式切换前，从Guest上下文中恢复相关寄存器到上次离开Guest"
"环境到状态。vCPU代表了虚拟环境中独立的执行流，因此Host和Guest上下文同一由vCPU"
"来维护。"

#: src/architecture/vcpu/riscv_vcpu.md:95
msgid ""
"具体到RISC-V体系结构，对于VM-Entry，保存/恢复上下文的工作在\\_run_guest中完"
"成，最后执行sret指令完成物理CPU的模式切换。过程\\_run_guest定义在riscv_vcpu/"
"src/trap.S文件中，关键的数据结构和过程如下："
msgstr ""
"具体到RISC-V体系结构，对于VM-Entry，保存/恢复上下文的工作在\\_run_guest中完"
"成，最后执行sret指令完成物理CPU的模式切换。过程\\_run_guest定义在riscv_vcpu/"
"src/trap.S文件中，关键的数据结构和过程如下："

#: src/architecture/vcpu/riscv_vcpu.md:97
msgid ""
"RISCV_VCPU保存寄存器上下文的结构，参见riscv_cpu/src/vcpu.rs和riscv_cpu/src/"
"regs.rs"
msgstr ""
"RISCV_VCPU保存寄存器上下文的结构，参见riscv_cpu/src/vcpu.rs和riscv_cpu/src/"
"regs.rs"

#: src/architecture/vcpu/riscv_vcpu.md:106
msgid ""
"// CPU state that's shared between our's and the guest's execution "
"environment. Saved/restored"
msgstr ""
"// CPU state that's shared between our's and the guest's execution "
"environment. Saved/restored"

#: src/architecture/vcpu/riscv_vcpu.md:107
msgid "// when entering/exiting a VM."
msgstr "// when entering/exiting a VM."

#: src/architecture/vcpu/riscv_vcpu.md:113
msgid ""
"每个RISCV_VCPU实例中通过regs成员保存寄存器状态，具体又分为Host上下文hyp_regs"
"和Guest上下文guest_regs。"
msgstr ""
"每个RISCV_VCPU实例中通过regs成员保存寄存器状态，具体又分为Host上下文hyp_regs"
"和Guest上下文guest_regs。"

#: src/architecture/vcpu/riscv_vcpu.md:115
msgid "向\\_run_guest传入上下文数据区的起始地址，参见riscv_vcpu/src/vcpu.rs"
msgstr "向\\_run_guest传入上下文数据区的起始地址，参见riscv_vcpu/src/vcpu.rs"

#: src/architecture/vcpu/riscv_vcpu.md:117
msgid ""
"RISCV_VCPU的主运行方法run在调用\\_run_guest时，会传入其regs成员的地址作为参"
"数。"
msgstr ""
"RISCV_VCPU的主运行方法run在调用\\_run_guest时，会传入其regs成员的地址作为参"
"数。"

#: src/architecture/vcpu/riscv_vcpu.md:122
#: src/architecture/vcpu/riscv_vcpu.md:203
msgid ""
"// Safe to run the guest as it only touches memory assigned to it by being "
"owned"
msgstr ""
"// Safe to run the guest as it only touches memory assigned to it by being "
"owned"

#: src/architecture/vcpu/riscv_vcpu.md:123
#: src/architecture/vcpu/riscv_vcpu.md:204
msgid "// by its page table"
msgstr "// by its page table"

#: src/architecture/vcpu/riscv_vcpu.md:128
msgid "RISCV_VCPU成员regs的地址作为第一个参数，在汇编层面保存在a0寄存器中。"
msgstr "RISCV_VCPU成员regs的地址作为第一个参数，在汇编层面保存在a0寄存器中。"

#: src/architecture/vcpu/riscv_vcpu.md:130
msgid "过程\\_run_guest关于保存Host上下文的实现，参见riscv_vcpu/src/trap.S"
msgstr "过程\\_run_guest关于保存Host上下文的实现，参见riscv_vcpu/src/trap.S"

#: src/architecture/vcpu/riscv_vcpu.md:132
msgid ""
"接上面，\\_run_guest中的a0保存的是RISCV_VCPU的成员regs的开始地址，加上偏移就"
"可以访问到Host/Guest两组上下文中存放各个寄存器的具体位置。"
msgstr ""
"接上面，\\_run_guest中的a0保存的是RISCV_VCPU的成员regs的开始地址，加上偏移就"
"可以访问到Host/Guest两组上下文中存放各个寄存器的具体位置。"

#: src/architecture/vcpu/riscv_vcpu.md:145
msgid "过程\\_run_guest关于恢复Guest上下文的实现"
msgstr "过程\\_run_guest关于恢复Guest上下文的实现"

#: src/architecture/vcpu/riscv_vcpu.md:148
msgid "/* Restore the gprs from this GuestInfo */"
msgstr "/* Restore the gprs from this GuestInfo */"

#: src/architecture/vcpu/riscv_vcpu.md:155
msgid "为Guest运行提前准备，把涉及的寄存器状态从上下文中恢复出来。"
msgstr "为Guest运行提前准备，把涉及的寄存器状态从上下文中恢复出来。"

#: src/architecture/vcpu/riscv_vcpu.md:157
msgid "执行模式切换，进入到虚拟机执行Guest OS"
msgstr "执行模式切换，进入到虚拟机执行Guest OS"

#: src/architecture/vcpu/riscv_vcpu.md:159
msgid ""
"在前面已经保存和恢复上下文的基础上，通过指令`sret`完成物理CPU模式的切换，进入"
"到Guest环境中执行。"
msgstr ""
"在前面已经保存和恢复上下文的基础上，通过指令`sret`完成物理CPU模式的切换，进入"
"到Guest环境中执行。"

#: src/architecture/vcpu/riscv_vcpu.md:161
msgid "VM-Exit：从Gust返回Host"
msgstr "VM-Exit：从Gust返回Host"

#: src/architecture/vcpu/riscv_vcpu.md:163
msgid ""
"VM-Exit是虚拟机无法满足虚拟化条件时，从体系结构硬件发起的、由特殊trap响应函数"
"配合的自动过程。从执行逻辑上看，它基本上是GuestVM-Entry的逆向过程。"
msgstr ""
"VM-Exit是虚拟机无法满足虚拟化条件时，从体系结构硬件发起的、由特殊trap响应函数"
"配合的自动过程。从执行逻辑上看，它基本上是GuestVM-Entry的逆向过程。"

#: src/architecture/vcpu/riscv_vcpu.md:167
msgid "VM-Exit过程的触发"
msgstr "VM-Exit过程的触发"

#: src/architecture/vcpu/riscv_vcpu.md:169
msgid ""
"VM-Exit过程的触发是物理硬件的基本机制，相当于宏内核模式下，低特权级程序在执行"
"某些特权操作时所触发的trap过程。软件层面Hypervisor需要做的工作就是在上次执行"
"\\_run_guest时，提前注册响应函数\\_guest_exit。"
msgstr ""
"VM-Exit过程的触发是物理硬件的基本机制，相当于宏内核模式下，低特权级程序在执行"
"某些特权操作时所触发的trap过程。软件层面Hypervisor需要做的工作就是在上次执行"
"\\_run_guest时，提前注册响应函数\\_guest_exit。"

#: src/architecture/vcpu/riscv_vcpu.md:178
msgid ""
"对于RISC-V，寄存器stvec保存trap响应函数入口表的起始地址，对于虚拟化导致的trap"
"同样适用。"
msgstr ""
"对于RISC-V，寄存器stvec保存trap响应函数入口表的起始地址，对于虚拟化导致的trap"
"同样适用。"

#: src/architecture/vcpu/riscv_vcpu.md:180
msgid "VM-Exit的响应过程"
msgstr "VM-Exit的响应过程"

#: src/architecture/vcpu/riscv_vcpu.md:182
msgid "响应过程主体就是\\_guest_exit的实现，参见riscv_vcpu/src/trap.S"
msgstr "响应过程主体就是\\_guest_exit的实现，参见riscv_vcpu/src/trap.S"

#: src/architecture/vcpu/riscv_vcpu.md:198
msgid ""
"由于逻辑上基本是\\_run_guest的逆过程，不再赘述。但是需要特别注意该过程的最后"
"一行是`ret`指令，是普通的函数返回指令，原理是从寄存器ra取出返回地址后跳转。回"
"顾VM-Entry中切换模式进入虚拟机时，执行的是\\_run_guest，如下："
msgstr ""
"由于逻辑上基本是\\_run_guest的逆过程，不再赘述。但是需要特别注意该过程的最后"
"一行是`ret`指令，是普通的函数返回指令，原理是从寄存器ra取出返回地址后跳转。回"
"顾VM-Entry中切换模式进入虚拟机时，执行的是\\_run_guest，如下："

#: src/architecture/vcpu/riscv_vcpu.md:206
msgid "// <- Reg 'ra' points to this line."
msgstr "// <- Reg 'ra' points to this line."

#: src/architecture/vcpu/riscv_vcpu.md:209
msgid ""
"当时寄存器ra保存的就是\\_run_guest函数的下一行指令代码地址，所以此时执行`ret`"
"的效果就是返回到该处继续执行。"
msgstr ""
"当时寄存器ra保存的就是\\_run_guest函数的下一行指令代码地址，所以此时执行`ret`"
"的效果就是返回到该处继续执行。"

#: src/architecture/vcpu/riscv_vcpu.md:211
msgid ""
"从Hypervisor的角度看，它执行\\_run_guest的效果就如同执行了一次普通的函数调"
"用，但是内部已经经历了一次从进入虚拟机到退出虚拟机的完整周期。"
msgstr ""
"从Hypervisor的角度看，它执行\\_run_guest的效果就如同执行了一次普通的函数调"
"用，但是内部已经经历了一次从进入虚拟机到退出虚拟机的完整周期。"

#: src/architecture/vcpu/riscv_vcpu.md:213
msgid "附1：参考资料"
msgstr "附1：参考资料"

#: src/architecture/vcpu/riscv_vcpu.md:215
msgid "RISC-V官方指令手册中，关于‘H’扩展的章节。"
msgstr "RISC-V官方指令手册中，关于‘H’扩展的章节。"

#: src/architecture/vcpu/riscv_vcpu.md:217
msgid ""
"[riscv-docs/riscv-privileged-20211203.pdf at main · konpoe/riscv-docs]"
"(https://github.com/konpoe/riscv-docs/blob/main/riscv-privileged-20211203."
"pdf)"
msgstr ""
"[riscv-docs/riscv-privileged-20211203.pdf at main · konpoe/riscv-docs]"
"(https://github.com/konpoe/riscv-docs/blob/main/riscv-privileged-20211203."
"pdf)"

#: src/architecture/vcpu/riscv_vcpu.md:219
msgid "附2：vCPU与物理CPU绑定"
msgstr "附2：vCPU与物理CPU绑定"

#: src/architecture/vcpu/riscv_vcpu.md:221
msgid ""
"如正文所述，Hypervisor基于对ArceOS的扩展实现。vCPU与ArceOS的Task是一体的，因"
"此vCPU与物理CPU的绑定关系是通过Task与物理CPU的绑定关系来实现的。"
msgstr ""
"如正文所述，Hypervisor基于对ArceOS的扩展实现。vCPU与ArceOS的Task是一体的，因"
"此vCPU与物理CPU的绑定关系是通过Task与物理CPU的绑定关系来实现的。"

#: src/architecture/vcpu/riscv_vcpu.md:223
msgid ""
"ArceOS提供了要给cpumask的功能，即通过位图的形式指定Task可以被哪些RUN_QUEUE所"
"执行，RUN_QUEUE与物理CPU是一一对应的关系，由此可以实现vCPU到物理CPU的绑定。"
"<style> .scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; "
"display: none; align-items: center; justify-content: center; position: "
"fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--"
"page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--"
"bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden "
"{ display: none; } .scroll-to-top i { transform: translateY(-2px); } @media "
"(min-width: 1080px) { .scroll-to-top { display: flex; } } </style> <button "
"type=\"button\" aria-label=\"scroll-to-top\" class=\"scroll-to-top hidden\" "
"onclick=\"scrollToTop()\"> <i class=\"fa fa-angle-up\"></i> </button>"
msgstr ""
"ArceOS提供了要给cpumask的功能，即通过位图的形式指定Task可以被哪些RUN_QUEUE所"
"执行，RUN_QUEUE与物理CPU是一一对应的关系，由此可以实现vCPU到物理CPU的绑定。"
"<style> .scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; "
"display: none; align-items: center; justify-content: center; position: "
"fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--"
"page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--"
"bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden "
"{ display: none; } .scroll-to-top i { transform: translateY(-2px); } @media "
"(min-width: 1080px) { .scroll-to-top { display: flex; } } </style> <button "
"type=\"button\" aria-label=\"scroll-to-top\" class=\"scroll-to-top hidden\" "
"onclick=\"scrollToTop()\"> <i class=\"fa fa-angle-up\"></i> </button>"

#: src/architecture/vcpu/loongarch_vcpu.md:1
msgid ""
"🚧 Coming soon.<style> .scroll-to-top { font-size: 2.5rem; width: 3.2rem; "
"height: 3.2rem; display: none; align-items: center; justify-content: center; "
"position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px "
"+ var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: "
"var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top."
"hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } "
"@media (min-width: 1080px) { .scroll-to-top { display: flex; } } </style> "
"<button type=\"button\" aria-label=\"scroll-to-top\" class=\"scroll-to-top "
"hidden\" onclick=\"scrollToTop()\"> <i class=\"fa fa-angle-up\"></i> </"
"button>"
msgstr ""
"🚧 Coming soon.<style> .scroll-to-top { font-size: 2.5rem; width: 3.2rem; "
"height: 3.2rem; display: none; align-items: center; justify-content: center; "
"position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px "
"+ var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: "
"var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top."
"hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } "
"@media (min-width: 1080px) { .scroll-to-top { display: flex; } } </style> "
"<button type=\"button\" aria-label=\"scroll-to-top\" class=\"scroll-to-top "
"hidden\" onclick=\"scrollToTop()\"> <i class=\"fa fa-angle-up\"></i> </"
"button>"

#: src/architecture/memory.md:5
msgid ""
"内存虚拟化由[axaddrspace](https://github.com/arceos-hypervisor/axaddrspace)实"
"现，该模块与架构无关，负责管理和映射客户虚拟机的二级地址空间（GPA -> HPA）"
msgstr ""
"内存虚拟化由[axaddrspace](https://github.com/arceos-hypervisor/axaddrspace)实"
"现，该模块与架构无关，负责管理和映射客户虚拟机的二级地址空间（GPA -> HPA）"

#: src/architecture/memory.md:40
msgid "客户机物理地址空间结构体"
msgstr "客户机物理地址空间结构体"

#: src/architecture/memory.md:44
msgid "//地址空间范围\n"
msgstr "//地址空间范围\n"

#: src/architecture/memory.md:45
msgid "//内存区域集合\n"
msgstr "//内存区域集合\n"

#: src/architecture/memory.md:46
msgid "//嵌套页表实例\n"
msgstr "//嵌套页表实例\n"

#: src/architecture/memory.md:50
msgid ""
"该结构体使用了一个泛型类型参数<H>，该参数受page_table_multiarch模块中"
"PagingHandler trait的约束。"
msgstr ""
"该结构体使用了一个泛型类型参数<H>，该参数受page_table_multiarch模块中"
"PagingHandler trait的约束。"

#: src/architecture/memory.md:54
msgid "功能代码"
msgstr "功能代码"

#: src/architecture/memory.md:56
msgid ""
"定义一个统一内存映射后端枚举类型 `Backend<H>`，用于抽象不同策略的物理内存管理"
"方式。通过泛型参数 `H: PagingHandler` 实现对不同页表操作接口的兼容，允许后端"
"适配不同架构的页表实现（如x86_64的EPT、ARM的Stage-2页表）。"
msgstr ""
"定义一个统一内存映射后端枚举类型 `Backend<H>`，用于抽象不同策略的物理内存管理"
"方式。通过泛型参数 `H: PagingHandler` 实现对不同页表操作接口的兼容，允许后端"
"适配不同架构的页表实现（如x86_64的EPT、ARM的Stage-2页表）。"

#: src/architecture/memory.md:60
msgid "/// Linear mapping backend.\n"
msgstr "/// Linear mapping backend.\n"

#: src/architecture/memory.md:62
msgid "/// `vaddr - paddr`.\n"
msgstr "/// `vaddr - paddr`.\n"

#: src/architecture/memory.md:65
msgid "/// Allocation mapping backend.\n"
msgstr "/// Allocation mapping backend.\n"

#: src/architecture/memory.md:73
msgid "当前支持两种内存映射后端策略："
msgstr "当前支持两种内存映射后端策略："

#: src/architecture/memory.md:75
msgid "Linear（线性映射）**`物理地址 = 虚拟地址 - pa_va_offset`**"
msgstr "Linear（线性映射）**`物理地址 = 虚拟地址 - pa_va_offset`**"

#: src/architecture/memory.md:77
msgid "Alloc（动态分配映射）：通过全局分配器动态获取物理帧，支持两种模式："
msgstr "Alloc（动态分配映射）：通过全局分配器动态获取物理帧，支持两种模式："

#: src/architecture/memory.md:78
msgid "**预分配模式 (`populate=true`)**: 立即分配所有物理帧，无缺页开销"
msgstr "**预分配模式 (`populate=true`)**: 立即分配所有物理帧，无缺页开销"

#: src/architecture/memory.md:79
msgid "**按需分配模式 (`populate=false`)**: 延迟分配，通过缺页异常触发分配"
msgstr "**按需分配模式 (`populate=false`)**: 延迟分配，通过缺页异常触发分配"

#: src/architecture/memory.md:83
msgid "文件alloc.rs实现了动态分配映射:"
msgstr "文件alloc.rs实现了动态分配映射:"

#: src/architecture/memory.md:85
msgid "方法"
msgstr "方法"

#: src/architecture/memory.md:85
#: src/architecture/device/passthrough_device.md:47
msgid "功能描述"
msgstr "功能描述"

#: src/architecture/memory.md:87
msgid "`new_alloc`"
msgstr "`new_alloc`"

#: src/architecture/memory.md:87
msgid "创建后端实例，指定是否预分配"
msgstr "创建后端实例，指定是否预分配"

#: src/architecture/memory.md:88
msgid "`map_alloc`"
msgstr "`map_alloc`"

#: src/architecture/memory.md:88
msgid "建立客户机虚拟地址到动态分配物理帧的映射"
msgstr "建立客户机虚拟地址到动态分配物理帧的映射"

#: src/architecture/memory.md:89
msgid "`unmap_alloc`"
msgstr "`unmap_alloc`"

#: src/architecture/memory.md:89
msgid "解除映射并释放关联的物理帧"
msgstr "解除映射并释放关联的物理帧"

#: src/architecture/memory.md:90
msgid "`handle_page_fault`"
msgstr "`handle_page_fault`"

#: src/architecture/memory.md:90
msgid "处理缺页异常，为未映射的地址分配物理帧"
msgstr "处理缺页异常，为未映射的地址分配物理帧"

#: src/architecture/memory.md:92
msgid "文件linear.rs实现了线性映射，功能有："
msgstr "文件linear.rs实现了线性映射，功能有："

#: src/architecture/memory.md:94
msgid ""
"```\n"
"impl<H: PagingHandler> Backend<H> {\n"
"    // 创建线性映射后端实例\n"
"    pub const fn new_linear(pa_va_offset: usize) -> Self\n"
"    // 执行线性映射\n"
"    pub(crate) fn map_linear(...) -> bool \n"
"    // 解除线性映射\n"
"    pub(crate) fn unmap_linear(...) -> bool\n"
"\n"
"}\n"
"```"
msgstr ""
"```\n"
"impl<H: PagingHandler> Backend<H> {\n"
"    // 创建线性映射后端实例\n"
"    pub const fn new_linear(pa_va_offset: usize) -> Self\n"
"    // 执行线性映射\n"
"    pub(crate) fn map_linear(...) -> bool \n"
"    // 解除线性映射\n"
"    pub(crate) fn unmap_linear(...) -> bool\n"
"\n"
"}\n"
"```"

#: src/architecture/memory.md:108
msgid ""
"axaddrspace通过使用`page_table_multiarch`的泛型页表框架和`page_table_entry`的"
"标准接口定义，实现了支持x86、ARM、RISC-V的嵌套页表管理的多架构兼容。"
msgstr ""
"axaddrspace通过使用`page_table_multiarch`的泛型页表框架和`page_table_entry`的"
"标准接口定义，实现了支持x86、ARM、RISC-V的嵌套页表管理的多架构兼容。"

#: src/architecture/memory.md:110
msgid "依赖注入"
msgstr "依赖注入"

#: src/architecture/memory.md:112
msgid ""
"`AddrSpace`结构体表示虚拟机的内存区域和二级地址映射，依赖于泛型类型"
"`PagingHandler`处理页表相关操作。`axaddrspace`由`axvm`的`AxVM`结构体拥有和管"
"理，而`AxVM`依赖于定义在`axvm`的`hal.rs`中的`AxVMHal` trait。"
msgstr ""
"`AddrSpace`结构体表示虚拟机的内存区域和二级地址映射，依赖于泛型类型"
"`PagingHandler`处理页表相关操作。`axaddrspace`由`axvm`的`AxVM`结构体拥有和管"
"理，而`AxVM`依赖于定义在`axvm`的`hal.rs`中的`AxVMHal` trait。"

#: src/architecture/memory.md:114
msgid "实际上，`PagingHandler`是`AxVMHal` trait的一个关联类型："
msgstr "实际上，`PagingHandler`是`AxVMHal` trait的一个关联类型："

#: src/architecture/memory.md:116
msgid ""
"```\n"
"// 底层软件（内核或虚拟机监控程序）必须实现的接口\n"
"pub trait AxVMHal: Sized {\n"
"    type PagingHandler: page_table_multiarch::PagingHandler;\n"
"    // 将虚拟地址转换为对应的物理地址\n"
"    fn virt_to_phys(vaddr: HostVirtAddr) -> HostPhysAddr;\n"
"    // 获取当前时间（纳秒）\n"
"    fn current_time_nanos() -> u64;\n"
"\t// ...\n"
"}\n"
"```"
msgstr ""
"```\n"
"// 底层软件（内核或虚拟机监控程序）必须实现的接口\n"
"pub trait AxVMHal: Sized {\n"
"    type PagingHandler: page_table_multiarch::PagingHandler;\n"
"    // 将虚拟地址转换为对应的物理地址\n"
"    fn virt_to_phys(vaddr: HostVirtAddr) -> HostPhysAddr;\n"
"    // 获取当前时间（纳秒）\n"
"    fn current_time_nanos() -> u64;\n"
"\t// ...\n"
"}\n"
"```"

#: src/architecture/memory.md:128
msgid ""
"`AxVMHal`由`vmm-app`中的`AxVMHalImpl`实现，其关联类型`PagingHandler`依赖于"
"ArceOS的`axhal`模块提供的`PagingHandlerImpl`："
msgstr ""
"`AxVMHal`由`vmm-app`中的`AxVMHalImpl`实现，其关联类型`PagingHandler`依赖于"
"ArceOS的`axhal`模块提供的`PagingHandlerImpl`："

#: src/architecture/memory.md:130
msgid ""
"```\n"
"pub struct AxVMHalImpl;\n"
"\n"
"impl AxVMHal for AxVMHalImpl {\n"
"    type PagingHandler = axhal::paging::PagingHandlerImpl;\n"
"    fn virt_to_phys(vaddr: VirtAddr) -> PhysAddr {\n"
"        axhal::mem::virt_to_phys(vaddr)\n"
"    }\n"
"    fn current_time_nanos() -> u64 {\n"
"        axhal::time::monotonic_time_nanos()\n"
"    }\n"
"\t// ...\n"
"}\n"
"```"
msgstr ""
"```\n"
"pub struct AxVMHalImpl;\n"
"\n"
"impl AxVMHal for AxVMHalImpl {\n"
"    type PagingHandler = axhal::paging::PagingHandlerImpl;\n"
"    fn virt_to_phys(vaddr: VirtAddr) -> PhysAddr {\n"
"        axhal::mem::virt_to_phys(vaddr)\n"
"    }\n"
"    fn current_time_nanos() -> u64 {\n"
"        axhal::time::monotonic_time_nanos()\n"
"    }\n"
"\t// ...\n"
"}\n"
"```"

#: src/architecture/memory.md:145
msgid ""
"当前设计通过Rust的泛型类型（Trait）及其关联类型机制实现了依赖注入。<style> ."
"scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: "
"none; align-items: center; justify-content: center; position: fixed; "
"padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-"
"padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); "
"background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden "
"{ display: none; } .scroll-to-top i { transform: translateY(-2px); } @media "
"(min-width: 1080px) { .scroll-to-top { display: flex; } } </style> <button "
"type=\"button\" aria-label=\"scroll-to-top\" class=\"scroll-to-top hidden\" "
"onclick=\"scrollToTop()\"> <i class=\"fa fa-angle-up\"></i> </button>"
msgstr ""
"当前设计通过Rust的泛型类型（Trait）及其关联类型机制实现了依赖注入。<style> ."
"scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: "
"none; align-items: center; justify-content: center; position: fixed; "
"padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-"
"padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); "
"background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden "
"{ display: none; } .scroll-to-top i { transform: translateY(-2px); } @media "
"(min-width: 1080px) { .scroll-to-top { display: flex; } } </style> <button "
"type=\"button\" aria-label=\"scroll-to-top\" class=\"scroll-to-top hidden\" "
"onclick=\"scrollToTop()\"> <i class=\"fa fa-angle-up\"></i> </button>"

#: src/architecture/irq/irq.md:1
msgid "虚拟中断控制器"
msgstr "虚拟中断控制器"

#: src/architecture/irq/irq.md:3
msgid "各架构控制器"
msgstr "各架构控制器"

#: src/architecture/irq/irq.md:5
msgid "x86_64: local Apic (xAPIC and x2APIC) and IO Apic"
msgstr "x86_64: local Apic (xAPIC and x2APIC) and IO Apic"

#: src/architecture/irq/irq.md:6
msgid "aarch64: GIC (v2,v3,v4)"
msgstr "aarch64: GIC (v2,v3,v4)"

#: src/architecture/irq/irq.md:7
msgid "riscv64: PLIC or APLIC"
msgstr "riscv64: PLIC or APLIC"

#: src/architecture/irq/irq.md:9
msgid "实现方式"
msgstr "实现方式"

#: src/architecture/irq/irq.md:11
msgid "虚拟控制器"
msgstr "虚拟控制器"

#: src/architecture/irq/irq.md:13
msgid ""
"为相应架构的中断控制器设计虚拟控制器模型，为每个 `vcpu` 创建一个内部中断模拟"
"设备，用于管理 `systime` 中断等，为每个客户机创建一个外部中断模拟设备，用于管"
"理 `io` 中断。"
msgstr ""
"为相应架构的中断控制器设计虚拟控制器模型，为每个 `vcpu` 创建一个内部中断模拟"
"设备，用于管理 `systime` 中断等，为每个客户机创建一个外部中断模拟设备，用于管"
"理 `io` 中断。"

#: src/architecture/irq/irq.md:15
msgid "MMIO 区域注册"
msgstr "MMIO 区域注册"

#: src/architecture/irq/irq.md:17
msgid ""
"在客户机进行中断控制器的寄存器读写时，会通过 `data abort` 陷入到虚拟机，到达 "
"`axvcpu` 的如下代码段："
msgstr ""
"在客户机进行中断控制器的寄存器读写时，会通过 `data abort` 陷入到虚拟机，到达 "
"`axvcpu` 的如下代码段："

#: src/architecture/irq/irq.md:53
msgid ""
"通过 `handle_mmio_read` 和 `handle_mmio_write` 实现相应 `mmio` 范围内的地址访"
"问会路由到相应虚拟设备。"
msgstr ""
"通过 `handle_mmio_read` 和 `handle_mmio_write` 实现相应 `mmio` 范围内的地址访"
"问会路由到相应虚拟设备。"

#: src/architecture/irq/irq.md:55
msgid "通过对相应虚拟寄存器的读写逻辑，实现对客户机中断设置的权限控制。"
msgstr "通过对相应虚拟寄存器的读写逻辑，实现对客户机中断设置的权限控制。"

#: src/architecture/irq/irq.md:57
msgid "中断透传"
msgstr "中断透传"

#: src/architecture/irq/irq.md:59
msgid ""
"虚拟中断控制器通过配置表，判断客户机是否有权限控制中断号，若有权限，则将客户"
"机中断号相应操作透传到物理中断控制器。"
msgstr ""
"虚拟中断控制器通过配置表，判断客户机是否有权限控制中断号，若有权限，则将客户"
"机中断号相应操作透传到物理中断控制器。"

#: src/architecture/irq/irq.md:61
msgid "虚拟设备到 Guest OS 的通知"
msgstr "虚拟设备到 Guest OS 的通知"

#: src/architecture/irq/irq.md:63
msgid ""
"绝大多数情况下，虚拟设备通知 Guest OS 的方式是虚拟中断。但虚拟中断并不完全来"
"自虚拟设备，也可能来自直通设备的物理中断（由 Hypervisor 转发）或者来自某个 "
"VCpu 的虚拟 IPI（同样由 Hypervisor 转发）。因此，需要一个统一的虚拟中断注入接"
"口，用以向指定的 VCpu 注入中断。"
msgstr ""
"绝大多数情况下，虚拟设备通知 Guest OS 的方式是虚拟中断。但虚拟中断并不完全来"
"自虚拟设备，也可能来自直通设备的物理中断（由 Hypervisor 转发）或者来自某个 "
"VCpu 的虚拟 IPI（同样由 Hypervisor 转发）。因此，需要一个统一的虚拟中断注入接"
"口，用以向指定的 VCpu 注入中断。"

#: src/architecture/irq/irq.md:65
msgid ""
"这个接口应该放置在 AxVM 中，签名类似于 inject_interrupt_to_vcpu(target: "
"Option<CpuMask>, vector: usize) -> AxResult。其中 target 可以控制中断注入的目"
"标 VCpu，是任意一个 VCpu，指定一个 VCpu，指定一组 VCpu，或者所有 VCpu；"
"vector 是中断向量。放置在 AxVM 中的原因是，中断注入的操作可能需要访问 VGIC 等"
"设备。"
msgstr ""
"这个接口应该放置在 AxVM 中，签名类似于 inject_interrupt_to_vcpu(target: "
"Option<CpuMask>, vector: usize) -> AxResult。其中 target 可以控制中断注入的目"
"标 VCpu，是任意一个 VCpu，指定一个 VCpu，指定一组 VCpu，或者所有 VCpu；"
"vector 是中断向量。放置在 AxVM 中的原因是，中断注入的操作可能需要访问 VGIC 等"
"设备。"

#: src/architecture/irq/irq.md:67
msgid ""
"为了设备不直接依赖于 AxVM 或者 AxVCpu，虚拟设备结构体不能直接调用 "
"inject_interrupt_to_vcpu，而是应当通过提供给设备的一个闭包来实现中断注入。"
msgstr ""
"为了设备不直接依赖于 AxVM 或者 AxVCpu，虚拟设备结构体不能直接调用 "
"inject_interrupt_to_vcpu，而是应当通过提供给设备的一个闭包来实现中断注入。"

#: src/architecture/irq/irq.md:69
msgid ""
"系统时钟和虚拟设备等中断通过全虚拟化方式实现，每个 `vcpu` 都有一个中断向量"
"表，用于记录客户机中断号对应的中断状态。"
msgstr ""
"系统时钟和虚拟设备等中断通过全虚拟化方式实现，每个 `vcpu` 都有一个中断向量"
"表，用于记录客户机中断号对应的中断状态。"

#: src/architecture/irq/irq.md:71
msgid ""
"当虚拟设备触发中断时，向物理中断控制器发送软中断，由物理中断控制器将中断请求"
"转发到 `vcpu`。"
msgstr ""
"当虚拟设备触发中断时，向物理中断控制器发送软中断，由物理中断控制器将中断请求"
"转发到 `vcpu`。"

#: src/architecture/irq/irq.md:73
msgid "`inject_interrupt_to_vcpu` 的实现"
msgstr "`inject_interrupt_to_vcpu` 的实现"

#: src/architecture/irq/irq.md:75
msgid ""
"为了保持 AxVM 的架构无关性，AxVCpu 和 AxArchVCpu 仍然应该提供一个 "
"inject_interrupt 方法，用以向当前 VCpu 注入中断。AxVM 的 "
"inject_interrupt_to_vcpu 方法应该根据 target 参数，调用对应 AxVCpu 的 "
"inject_interrupt 方法。在 aarch64 和 riscv64 平台上，AxArchVCpu 在 setup 时，"
"应该通过 SetupConfig 得到一个实际完成中断注入的闭包；而在 x86 平台上，"
"AxArchVCpu 本身具有中断注入的能力，因此无需进一步的配置。"
msgstr ""
"为了保持 AxVM 的架构无关性，AxVCpu 和 AxArchVCpu 仍然应该提供一个 "
"inject_interrupt 方法，用以向当前 VCpu 注入中断。AxVM 的 "
"inject_interrupt_to_vcpu 方法应该根据 target 参数，调用对应 AxVCpu 的 "
"inject_interrupt 方法。在 aarch64 和 riscv64 平台上，AxArchVCpu 在 setup 时，"
"应该通过 SetupConfig 得到一个实际完成中断注入的闭包；而在 x86 平台上，"
"AxArchVCpu 本身具有中断注入的能力，因此无需进一步的配置。"

#: src/architecture/irq/irq.md:77
msgid ""
"当被注入中断时，如果 VCpu 正在当前核心上运行，可以直接通过各个架构的虚拟化机"
"制注入中断；如果 VCpu 处于当前核心就绪队列中，则应该记录中断，等 VCpu 下次运"
"行时再注入；如果 VCpu 在非当前核心上运行，可以通过 IPI 通知目标核心的 "
"Hypervisor，由 Hypervisor 负责注入中断。"
msgstr ""
"当被注入中断时，如果 VCpu 正在当前核心上运行，可以直接通过各个架构的虚拟化机"
"制注入中断；如果 VCpu 处于当前核心就绪队列中，则应该记录中断，等 VCpu 下次运"
"行时再注入；如果 VCpu 在非当前核心上运行，可以通过 IPI 通知目标核心的 "
"Hypervisor，由 Hypervisor 负责注入中断。"

#: src/architecture/irq/irq.md:79
msgid "参考资料"
msgstr "参考资料"

#: src/architecture/irq/irq.md:81
msgid ""
"Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volum 3C: "
"CHAPTER 30 APIC VIRTUALIZATION AND VIRTUAL INTERRUPTS"
msgstr ""
"Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volum 3C: "
"CHAPTER 30 APIC VIRTUALIZATION AND VIRTUAL INTERRUPTS"

#: src/architecture/irq/irq.md:82
msgid ""
"[ARM Generic Interrupt Controller Architecture version 2.0 - Architecture "
"Specification](https://developer.arm.com/documentation/ihi0048/latest/)"
msgstr ""
"[ARM Generic Interrupt Controller Architecture version 2.0 - Architecture "
"Specification](https://developer.arm.com/documentation/ihi0048/latest/)"

#: src/architecture/irq/irq.md:83
msgid ""
"[Arm Generic Interrupt Controller (GIC) Architecture Specification GIC "
"architecture version 3 and version 4](https://developer.arm.com/"
"documentation/ihi0069/latest/)"
msgstr ""
"[Arm Generic Interrupt Controller (GIC) Architecture Specification GIC "
"architecture version 3 and version 4](https://developer.arm.com/"
"documentation/ihi0069/latest/)"

#: src/architecture/irq/irq.md:84
msgid ""
"https://github.com/riscv/riscv-plic-spec/blob/master/riscv-plic.adoc<style> ."
"scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: "
"none; align-items: center; justify-content: center; position: fixed; "
"padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-"
"padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); "
"background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden "
"{ display: none; } .scroll-to-top i { transform: translateY(-2px); } @media "
"(min-width: 1080px) { .scroll-to-top { display: flex; } } </style> <button "
"type=\"button\" aria-label=\"scroll-to-top\" class=\"scroll-to-top hidden\" "
"onclick=\"scrollToTop()\"> <i class=\"fa fa-angle-up\"></i> </button>"
msgstr ""
"https://github.com/riscv/riscv-plic-spec/blob/master/riscv-plic.adoc<style> ."
"scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: "
"none; align-items: center; justify-content: center; position: fixed; "
"padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-"
"padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); "
"background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden "
"{ display: none; } .scroll-to-top i { transform: translateY(-2px); } @media "
"(min-width: 1080px) { .scroll-to-top { display: flex; } } </style> <button "
"type=\"button\" aria-label=\"scroll-to-top\" class=\"scroll-to-top hidden\" "
"onclick=\"scrollToTop()\"> <i class=\"fa fa-angle-up\"></i> </button>"

#: src/architecture/irq/vgic.md:3
msgid "一、GICv2介绍"
msgstr "一、GICv2介绍"

#: src/architecture/irq/vgic.md:5
msgid "![](../../assets/vgicv2/banner.png)"
msgstr "![](../../assets/vgicv2/banner.png)"

#: src/architecture/irq/vgic.md:7
msgid ""
"通过上图可以确定，GIC 主要包含 3 部分：Distributor、CPU interfaces 和 "
"Virtual CPU interfaces。Virtual CPU interfaces 包含 Virtual interface "
"control 和 Virtual CPU interface。"
msgstr ""
"通过上图可以确定，GIC 主要包含 3 部分：Distributor、CPU interfaces 和 "
"Virtual CPU interfaces。Virtual CPU interfaces 包含 Virtual interface "
"control 和 Virtual CPU interface。"

#: src/architecture/irq/vgic.md:9
msgid "![](../../assets/vgicv2/no-virtualization.png)"
msgstr "![](../../assets/vgicv2/no-virtualization.png)"

#: src/architecture/irq/vgic.md:11
msgid "中断进入 distributor，然后分发到 CPU interface"
msgstr "中断进入 distributor，然后分发到 CPU interface"

#: src/architecture/irq/vgic.md:13
msgid ""
"某个 CPU 触发中断后，读 GICC_IAR 拿到中断信息，处理完后写 GICC_EOIR 和 "
"GICC_DIR（如果 GICC_CTLR.EOImodeNS 是 0，则 EOI 的同时也会 DI）"
msgstr ""
"某个 CPU 触发中断后，读 GICC_IAR 拿到中断信息，处理完后写 GICC_EOIR 和 "
"GICC_DIR（如果 GICC_CTLR.EOImodeNS 是 0，则 EOI 的同时也会 DI）"

#: src/architecture/irq/vgic.md:15
msgid "GICD、GICC 寄存器都是 MMIO 的，device tree 中会给出物理地址"
msgstr "GICD、GICC 寄存器都是 MMIO 的，device tree 中会给出物理地址"

#: src/architecture/irq/vgic.md:19
msgid "中断类型"
msgstr "中断类型"

#: src/architecture/irq/vgic.md:21
msgid "1. **软件生成中断（Software Generated Interrupts, SGI）**"
msgstr "1. **软件生成中断（Software Generated Interrupts, SGI）**"

#: src/architecture/irq/vgic.md:23
msgid "**中断号范围**：0 到 15（共 16 个中断号）"
msgstr "**中断号范围**：0 到 15（共 16 个中断号）"

#: src/architecture/irq/vgic.md:24
msgid ""
"**用途**：用于处理器间通信（IPI），允许一个处理器核心向另一个处理器核心发送中"
"断信号。"
msgstr ""
"**用途**：用于处理器间通信（IPI），允许一个处理器核心向另一个处理器核心发送中"
"断信号。"

#: src/architecture/irq/vgic.md:25
msgid ""
"**特点**：每个核心都可以生成和接收这些中断，通常用于任务调度、同步等操作。"
msgstr ""
"**特点**：每个核心都可以生成和接收这些中断，通常用于任务调度、同步等操作。"

#: src/architecture/irq/vgic.md:27
msgid "2. **私有外设中断（Private Peripheral Interrupts, PPI）**"
msgstr "2. **私有外设中断（Private Peripheral Interrupts, PPI）**"

#: src/architecture/irq/vgic.md:29
msgid "**中断号范围**：16 到 31（共 16 个中断号）"
msgstr "**中断号范围**：16 到 31（共 16 个中断号）"

#: src/architecture/irq/vgic.md:30
msgid ""
"**用途**：用于处理与特定处理器核心直接相关的硬件事件，例如计时器中断、性能监"
"控中断、调试中断等。"
msgstr ""
"**用途**：用于处理与特定处理器核心直接相关的硬件事件，例如计时器中断、性能监"
"控中断、调试中断等。"

#: src/architecture/irq/vgic.md:31
msgid "**特点**：这些中断是每个核心私有的，只有对应的核心会处理这些中断。"
msgstr "**特点**：这些中断是每个核心私有的，只有对应的核心会处理这些中断。"

#: src/architecture/irq/vgic.md:33
msgid "3. **共享外设中断（Shared Peripheral Interrupts, SPI）**"
msgstr "3. **共享外设中断（Shared Peripheral Interrupts, SPI）**"

#: src/architecture/irq/vgic.md:35
msgid "**中断号范围**：32 到 1019（共 988 个中断号）"
msgstr "**中断号范围**：32 到 1019（共 988 个中断号）"

#: src/architecture/irq/vgic.md:37
msgid ""
"**用途**：用于处理系统中共享的外设中断，例如来自外部设备、网络接口、存储设备"
"等的中断。"
msgstr ""
"**用途**：用于处理系统中共享的外设中断，例如来自外部设备、网络接口、存储设备"
"等的中断。"

#: src/architecture/irq/vgic.md:39
msgid ""
"**特点**：这些中断是所有核心共享的，可以由任何一个核心处理，通常通过中断亲和"
"性（affinity）来决定哪个核心处理该中断。"
msgstr ""
"**特点**：这些中断是所有核心共享的，可以由任何一个核心处理，通常通过中断亲和"
"性（affinity）来决定哪个核心处理该中断。"

#: src/architecture/irq/vgic.md:41
msgid ""
"SPI默认发送vcpu 0上，同样将中断信号放到vcpu的ap_list字段排队，等待vcpu处理。"
msgstr ""
"SPI默认发送vcpu 0上，同样将中断信号放到vcpu的ap_list字段排队，等待vcpu处理。"

#: src/architecture/irq/vgic.md:45
msgid "Distributor 作用"
msgstr "Distributor 作用"

#: src/architecture/irq/vgic.md:46
msgid ""
"Distributor 主要作用为检测中断源、控制中断源行为和将中断源分发到指定 CPU 接口"
"上（针对每个 CPU 将优先级最高的中断转发到该接口上）。"
msgstr ""
"Distributor 主要作用为检测中断源、控制中断源行为和将中断源分发到指定 CPU 接口"
"上（针对每个 CPU 将优先级最高的中断转发到该接口上）。"

#: src/architecture/irq/vgic.md:48
msgid "Distributor 对中断的控制包括："
msgstr "Distributor 对中断的控制包括："

#: src/architecture/irq/vgic.md:50
msgid "全局启用中断转发到 CPU 接口"
msgstr "全局启用中断转发到 CPU 接口"

#: src/architecture/irq/vgic.md:52
msgid "开启或关闭每一个中断"
msgstr "开启或关闭每一个中断"

#: src/architecture/irq/vgic.md:53
msgid "为每个中断设置优先级"
msgstr "为每个中断设置优先级"

#: src/architecture/irq/vgic.md:54
msgid "为每个中断设置目标处理器列表"
msgstr "为每个中断设置目标处理器列表"

#: src/architecture/irq/vgic.md:55
msgid "设置每个外设中断触发方式（电平触发、边缘触发）"
msgstr "设置每个外设中断触发方式（电平触发、边缘触发）"

#: src/architecture/irq/vgic.md:56
msgid "为每个中断设置组"
msgstr "为每个中断设置组"

#: src/architecture/irq/vgic.md:57
msgid "将 SGI 转发到一个或多个处理器"
msgstr "将 SGI 转发到一个或多个处理器"

#: src/architecture/irq/vgic.md:58
msgid "每个中断状态可见"
msgstr "每个中断状态可见"

#: src/architecture/irq/vgic.md:59
msgid "提供软件设置或清除外设中断的挂起状态的一种机制"
msgstr "提供软件设置或清除外设中断的挂起状态的一种机制"

#: src/architecture/irq/vgic.md:61
msgid "中断 ID"
msgstr "中断 ID"

#: src/architecture/irq/vgic.md:62
msgid ""
"使用 ID 对中断源进行标识。每个 CPU 接口最多可以有 1020 个中断。SPI 和 PPI 中"
"断为每个接口特定的，SPI 为为所有接口共用，因此多处理器系统中实际中断数大于 "
"1020 个。"
msgstr ""
"使用 ID 对中断源进行标识。每个 CPU 接口最多可以有 1020 个中断。SPI 和 PPI 中"
"断为每个接口特定的，SPI 为为所有接口共用，因此多处理器系统中实际中断数大于 "
"1020 个。"

#: src/architecture/irq/vgic.md:64
msgid "CPU Interface"
msgstr "CPU Interface"

#: src/architecture/irq/vgic.md:65
msgid ""
"CPU 接口提供一个处理器连接到 GIC 的接口。每一个 CPU 接口都提供一个编程接口："
msgstr ""
"CPU 接口提供一个处理器连接到 GIC 的接口。每一个 CPU 接口都提供一个编程接口："

#: src/architecture/irq/vgic.md:67
msgid "允许向处理器发送中断请求信号"
msgstr "允许向处理器发送中断请求信号"

#: src/architecture/irq/vgic.md:68
msgid "确认中断"
msgstr "确认中断"

#: src/architecture/irq/vgic.md:69
msgid "指示中断处理完成"
msgstr "指示中断处理完成"

#: src/architecture/irq/vgic.md:70
msgid "为处理器设置中断优先级掩码"
msgstr "为处理器设置中断优先级掩码"

#: src/architecture/irq/vgic.md:71
msgid "为处理器定义抢占策略"
msgstr "为处理器定义抢占策略"

#: src/architecture/irq/vgic.md:72
msgid "选择最高优先级挂起中断"
msgstr "选择最高优先级挂起中断"

#: src/architecture/irq/vgic.md:76
msgid "二、中断处理状态机"
msgstr "二、中断处理状态机"

#: src/architecture/irq/vgic.md:78
msgid ""
"`GIC` 为每个 `CPU` 接口上每个受支持的中断维护一个状态机。下图显示了此状态机的"
"实例，以及可能的状态转换。"
msgstr ""
"`GIC` 为每个 `CPU` 接口上每个受支持的中断维护一个状态机。下图显示了此状态机的"
"实例，以及可能的状态转换。"

#: src/architecture/irq/vgic.md:80
msgid "![](../../assets/vgicv2/interrupt-state.png)"
msgstr "![](../../assets/vgicv2/interrupt-state.png)"

#: src/architecture/irq/vgic.md:82
msgid "Inactive：该中断源处于未激活状态"
msgstr "Inactive：该中断源处于未激活状态"

#: src/architecture/irq/vgic.md:83
msgid "Pending：中断源触发状态，GIC感知到，但还未被分发到PE"
msgstr "Pending：中断源触发状态，GIC感知到，但还未被分发到PE"

#: src/architecture/irq/vgic.md:84
msgid "Active：中断已经被某个PE认领确认"
msgstr "Active：中断已经被某个PE认领确认"

#: src/architecture/irq/vgic.md:85
msgid ""
"Active and pending：这个中断源的一次触发已经被PE确认，同时这个中断源的另一次"
"触发正在pending状态"
msgstr ""
"Active and pending：这个中断源的一次触发已经被PE确认，同时这个中断源的另一次"
"触发正在pending状态"

#: src/architecture/irq/vgic.md:87
msgid "添加挂起状态（A1、A2）"
msgstr "添加挂起状态（A1、A2）"

#: src/architecture/irq/vgic.md:89
msgid "对于一个 SGI，发生以下 2 种情况的 1 种："
msgstr "对于一个 SGI，发生以下 2 种情况的 1 种："

#: src/architecture/irq/vgic.md:90
msgid "软件写 **GICD_SGIR** 寄存器，指定目标处理器"
msgstr "软件写 **GICD_SGIR** 寄存器，指定目标处理器"

#: src/architecture/irq/vgic.md:91
msgid "目标处理器上软件写 **GICD_SPENDSGIRn** 寄存器"
msgstr "目标处理器上软件写 **GICD_SPENDSGIRn** 寄存器"

#: src/architecture/irq/vgic.md:93 src/architecture/irq/vgic.md:105
msgid "对于一个 SPI 或 PPI，发生以下 2 种情况的 1 种："
msgstr "对于一个 SPI 或 PPI，发生以下 2 种情况的 1 种："

#: src/architecture/irq/vgic.md:95
msgid "外设发出一个中断请求信号"
msgstr "外设发出一个中断请求信号"

#: src/architecture/irq/vgic.md:97
msgid "软件写 **GICD_ISPENDRn** 寄存器"
msgstr "软件写 **GICD_ISPENDRn** 寄存器"

#: src/architecture/irq/vgic.md:101
msgid "删除挂起状态（B1、B2）"
msgstr "删除挂起状态（B1、B2）"

#: src/architecture/irq/vgic.md:103
msgid "对于 SGI"
msgstr "对于 SGI"

#: src/architecture/irq/vgic.md:104
msgid "目标处理器写 **GICD_CPENDSGIRn** 寄存器"
msgstr "目标处理器写 **GICD_CPENDSGIRn** 寄存器"

#: src/architecture/irq/vgic.md:106
msgid "电平触发类型中断，信号取消"
msgstr "电平触发类型中断，信号取消"

#: src/architecture/irq/vgic.md:107
msgid "边沿触发类型中断，软件写 GICD_ICPENDRn 寄存器"
msgstr "边沿触发类型中断，软件写 GICD_ICPENDRn 寄存器"

#: src/architecture/irq/vgic.md:109
msgid "挂起到激活（C）"
msgstr "挂起到激活（C）"

#: src/architecture/irq/vgic.md:111
msgid "如果中断使能，并且高优先级，软件从 GICC_IAR 寄存器读取时发生状态改变。"
msgstr "如果中断使能，并且高优先级，软件从 GICC_IAR 寄存器读取时发生状态改变。"

#: src/architecture/irq/vgic.md:115
msgid "挂起到激活和挂起（D）"
msgstr "挂起到激活和挂起（D）"

#: src/architecture/irq/vgic.md:117
msgid "对于 SGI，这种转变发生在以下任一情况下："
msgstr "对于 SGI，这种转变发生在以下任一情况下："

#: src/architecture/irq/vgic.md:118
msgid "将 SGI 状态设置为挂起的写入操作与读取 GICC_IAR 几乎同时发生"
msgstr "将 SGI 状态设置为挂起的写入操作与读取 GICC_IAR 几乎同时发生"

#: src/architecture/irq/vgic.md:119
msgid ""
"当多个挂起的 SGI 具有相同 ID 时，并且它们来自同一个源处理器并指向同一个处理"
"器。其中一个 SGI 状态变为激活（C），其他 SGI 状态变为激活和挂起（D）"
msgstr ""
"当多个挂起的 SGI 具有相同 ID 时，并且它们来自同一个源处理器并指向同一个处理"
"器。其中一个 SGI 状态变为激活（C），其他 SGI 状态变为激活和挂起（D）"

#: src/architecture/irq/vgic.md:121
msgid "对于 SPI 或 PPI，满足以下所有条件，则发生这种转换"
msgstr "对于 SPI 或 PPI，满足以下所有条件，则发生这种转换"

#: src/architecture/irq/vgic.md:122
msgid "中断开启"
msgstr "中断开启"

#: src/architecture/irq/vgic.md:123
msgid "软件读取 GICC_IAR，读操作将激活状态添加到中断中。"
msgstr "软件读取 GICC_IAR，读操作将激活状态添加到中断中。"

#: src/architecture/irq/vgic.md:124
msgid "此外，还应满足以下条件之一："
msgstr "此外，还应满足以下条件之一："

#: src/architecture/irq/vgic.md:125
msgid ""
"对于电平触发中断，中断信号保持。通常都是这样，因为外设直到处理器处理完中断后"
"才会取消触发信号。"
msgstr ""
"对于电平触发中断，中断信号保持。通常都是这样，因为外设直到处理器处理完中断后"
"才会取消触发信号。"

#: src/architecture/irq/vgic.md:126
msgid ""
"对于边沿触发中断，是否发生此转换取决于读取 GICC_IAR 的时间（中断再次触发，上"
"一次未处理），读取 **GICC_IAR** 可能会转换到 C，后面可能会转换到 A2。"
msgstr ""
"对于边沿触发中断，是否发生此转换取决于读取 GICC_IAR 的时间（中断再次触发，上"
"一次未处理），读取 **GICC_IAR** 可能会转换到 C，后面可能会转换到 A2。"

#: src/architecture/irq/vgic.md:128
msgid "删除激活状态（E1、E2）"
msgstr "删除激活状态（E1、E2）"

#: src/architecture/irq/vgic.md:130
msgid "软件写入 GICC_EOIR 或 GICC_DIR 来停用中断，"
msgstr "软件写入 GICC_EOIR 或 GICC_DIR 来停用中断，"

#: src/architecture/irq/vgic.md:134
msgid "三、中断虚拟化设计"
msgstr "三、中断虚拟化设计"

#: src/architecture/irq/vgic.md:136
msgid "中断虚拟化概要"
msgstr "中断虚拟化概要"

#: src/architecture/irq/vgic.md:138
msgid "![](../../assets/vgicv2/vgic_summary.png)"
msgstr "![](../../assets/vgicv2/vgic_summary.png)"

#: src/architecture/irq/vgic.md:140
msgid "HCR_EL2.IMO 设置为 1 后，所有 IRQ 都会 trap 到 Hypervisor"
msgstr "HCR_EL2.IMO 设置为 1 后，所有 IRQ 都会 trap 到 Hypervisor"

#: src/architecture/irq/vgic.md:141
msgid "Hypervisor 判断该 IRQ 是否需要插入到 vCPU"
msgstr "Hypervisor 判断该 IRQ 是否需要插入到 vCPU"

#: src/architecture/irq/vgic.md:142
msgid ""
"插入 vIRQ 之后，在切换到 VM 之前需要 EOI 物理 IRQ，即 priority drop，降低运行"
"优先级，使之后 VM 运行时能够再次触发该中断"
msgstr ""
"插入 vIRQ 之后，在切换到 VM 之前需要 EOI 物理 IRQ，即 priority drop，降低运行"
"优先级，使之后 VM 运行时能够再次触发该中断"

#: src/architecture/irq/vgic.md:143
msgid ""
"回到 VM 后，GIC 在 EL1 触发 vIRQ，这时候 EOI 和 DI 会把 vIRQ 和物理 IRQ 都 "
"deactivate，因此不需要再 trap 到 Hypervisor ，不过如果是 SGI 的话并不会 "
"deactivate，需要 Hypervisor 自己处理。"
msgstr ""
"回到 VM 后，GIC 在 EL1 触发 vIRQ，这时候 EOI 和 DI 会把 vIRQ 和物理 IRQ 都 "
"deactivate，因此不需要再 trap 到 Hypervisor ，不过如果是 SGI 的话并不会 "
"deactivate，需要 Hypervisor 自己处理。"

#: src/architecture/irq/vgic.md:145
msgid "Hypervisor interface (GICH)"
msgstr "Hypervisor interface (GICH)"

#: src/architecture/irq/vgic.md:147
msgid "GICH base 物理地址在 device tree 中给出"
msgstr "GICH base 物理地址在 device tree 中给出"

#: src/architecture/irq/vgic.md:148
msgid "控制寄存器：GICH_HCR、GICH_VMCR 等"
msgstr "控制寄存器：GICH_HCR、GICH_VMCR 等"

#: src/architecture/irq/vgic.md:149
msgid "List 寄存器：GICH_LRn"
msgstr "List 寄存器：GICH_LRn"

#: src/architecture/irq/vgic.md:150
msgid ""
"KVM 中，这些寄存器保存在 `struct vgic_cpu` 的 `vgic_v2` 字段，`struct "
"vgic_cpu` 本身放在 `struct kvm_vcpu_arch`，每个 vCPU 一份"
msgstr ""
"KVM 中，这些寄存器保存在 `struct vgic_cpu` 的 `vgic_v2` 字段，`struct "
"vgic_cpu` 本身放在 `struct kvm_vcpu_arch`，每个 vCPU 一份"

#: src/architecture/irq/vgic.md:151
msgid ""
"vCPU switch 的时候，需要切换这些寄存器（KVM 在 `vgic-v2-switch.S` 中定义相关"
"切换函数）"
msgstr ""
"vCPU switch 的时候，需要切换这些寄存器（KVM 在 `vgic-v2-switch.S` 中定义相关"
"切换函数）"

#: src/architecture/irq/vgic.md:152
msgid "VM 无法访问 GICH 寄存器，因为根本没有映射"
msgstr "VM 无法访问 GICH 寄存器，因为根本没有映射"

#: src/architecture/irq/vgic.md:154
msgid "vCPU interface (GICV, GICC in VM's view)"
msgstr "vCPU interface (GICV, GICC in VM's view)"

#: src/architecture/irq/vgic.md:156
msgid "GICV 也是物理 GIC 上存在的，base 物理地址同样在 device tree 中给出"
msgstr "GICV 也是物理 GIC 上存在的，base 物理地址同样在 device tree 中给出"

#: src/architecture/irq/vgic.md:157
msgid ""
"KVM 在系统全局的一个结构体（`struct vgic_params vgic_v2_params`）保存了这个物"
"理地址"
msgstr ""
"KVM 在系统全局的一个结构体（`struct vgic_params vgic_v2_params`）保存了这个物"
"理地址"

#: src/architecture/irq/vgic.md:158
msgid ""
"创建 VM 时 Hypervisor 把一个特定的 GPA（KVM 中通过 `ioctl` 设置该地址）映射"
"到 GICV base 物理地址，然后把这个 GPA 作为 GICC base 在 device tree 中传给 VM"
msgstr ""
"创建 VM 时 Hypervisor 把一个特定的 GPA（KVM 中通过 `ioctl` 设置该地址）映射"
"到 GICV base 物理地址，然后把这个 GPA 作为 GICC base 在 device tree 中传给 VM"

#: src/architecture/irq/vgic.md:159
msgid "VM 以为自己在访问 GICC，实际上它在访问 GICV"
msgstr "VM 以为自己在访问 GICC，实际上它在访问 GICV"

#: src/architecture/irq/vgic.md:160
msgid ""
"目前理解这些 GICV 寄存器在 vCPU switch 的时候是不需要保存的（KVM 里没有保存 "
"GICV 相关的代码），因为它其实在硬件里访问的是 GICH 配置的那些寄存器，比如 LR"
msgstr ""
"目前理解这些 GICV 寄存器在 vCPU switch 的时候是不需要保存的（KVM 里没有保存 "
"GICV 相关的代码），因为它其实在硬件里访问的是 GICH 配置的那些寄存器，比如 LR"

#: src/architecture/irq/vgic.md:162
msgid "Virtual distributor (GICD in VM's view)"
msgstr "Virtual distributor (GICD in VM's view)"

#: src/architecture/irq/vgic.md:164
msgid "实际是内核里的一个结构体（`struct vgic_dist`）"
msgstr "实际是内核里的一个结构体（`struct vgic_dist`）"

#: src/architecture/irq/vgic.md:165
msgid "在 device tree 中给 VM 一个 GICD base，但实际上没有映射"
msgstr "在 device tree 中给 VM 一个 GICD base，但实际上没有映射"

#: src/architecture/irq/vgic.md:166
msgid ""
"VM 访问 GICD 时，trap & emulate，直接返回或设置 `struct vgic_dist` 里的字段"
"（在 `vgic-v2-emul.c` 文件中）"
msgstr ""
"VM 访问 GICD 时，trap & emulate，直接返回或设置 `struct vgic_dist` 里的字段"
"（在 `vgic-v2-emul.c` 文件中）"

#: src/architecture/irq/vgic.md:167
msgid ""
"每个 VM 一个，而不是每个 vCPU 一个，所以 `struct vgic_dist` 放在 `struct "
"kvm_arch` 里"
msgstr ""
"每个 VM 一个，而不是每个 vCPU 一个，所以 `struct vgic_dist` 放在 `struct "
"kvm_arch` 里"

#: src/architecture/irq/vgic.md:169
msgid "VM's view"
msgstr "VM's view"

#: src/architecture/irq/vgic.md:171
msgid "![img](../../assets/vgicv2/gicv2-vm-view.png)"
msgstr "![img](../../assets/vgicv2/gicv2-vm-view.png)"

#: src/architecture/irq/vgic.md:173
msgid ""
"从 device tree 获得 GICD、GICC base 物理地址（实际是 Hypervisor 伪造的地址）"
msgstr ""
"从 device tree 获得 GICD、GICC base 物理地址（实际是 Hypervisor 伪造的地址）"

#: src/architecture/irq/vgic.md:174
msgid ""
"配置 GICD 寄存器（实际上 trap 到 Hypervisor ，模拟地读写了内核某 struct 里的"
"数据）"
msgstr ""
"配置 GICD 寄存器（实际上 trap 到 Hypervisor ，模拟地读写了内核某 struct 里的"
"数据）"

#: src/architecture/irq/vgic.md:175
msgid ""
"执行直到发生中断（中断先到 Hypervisor ，Hypervisor 在 LR 中配置了一个物理 "
"IRQ 到 vIRQ 的映射，并且设置为 pending，回到 VM 之后 GIC 在 VM 的 EL1 触发中"
"断）"
msgstr ""
"执行直到发生中断（中断先到 Hypervisor ，Hypervisor 在 LR 中配置了一个物理 "
"IRQ 到 vIRQ 的映射，并且设置为 pending，回到 VM 之后 GIC 在 VM 的 EL1 触发中"
"断）"

#: src/architecture/irq/vgic.md:176
msgid ""
"读 GICC_IAR（经过 stage 2 页表翻译，实际上读了 GICV_IAR，GIC 根据 LR 返回 "
"vIRQ 的信息，vIRQ 状态从 pending 转为 active）"
msgstr ""
"读 GICC_IAR（经过 stage 2 页表翻译，实际上读了 GICV_IAR，GIC 根据 LR 返回 "
"vIRQ 的信息，vIRQ 状态从 pending 转为 active）"

#: src/architecture/irq/vgic.md:177
msgid ""
"写 GICC_EOIR、GICC_DIR（经过 stage 2 页表翻译，实际上写了 GICV_EOIR、"
"GICV_DIR，GIC EOI 并 deactivate 对应的 vIRQ，并 deactivate vIRQ 对应的物理 "
"IRQ）"
msgstr ""
"写 GICC_EOIR、GICC_DIR（经过 stage 2 页表翻译，实际上写了 GICV_EOIR、"
"GICV_DIR，GIC EOI 并 deactivate 对应的 vIRQ，并 deactivate vIRQ 对应的物理 "
"IRQ）"

#: src/architecture/irq/vgic.md:181
msgid "VGIC设计"
msgstr "VGIC设计"

#: src/architecture/irq/vgic.md:183
msgid "主要以以下4中case进行讨论，其中case4涉及vCPU调度，其他情况不涉及调度："
msgstr "主要以以下4中case进行讨论，其中case4涉及vCPU调度，其他情况不涉及调度："

#: src/architecture/irq/vgic.md:185
msgid "![](../../assets/vgicv2/vgicv2_4case.png)"
msgstr "![](../../assets/vgicv2/vgicv2_4case.png)"

#: src/architecture/irq/vgic.md:187
msgid "VGIC Distributor设计"
msgstr "VGIC Distributor设计"

#: src/architecture/irq/vgic.md:192
msgid "// num of SPIs\n"
msgstr "// num of SPIs\n"

#: src/architecture/irq/vgic.md:193
msgid "// store SPI\n"
msgstr "// store SPI\n"

#: src/architecture/irq/vgic.md:194
msgid "// Distributor I/O设备描述符\n"
msgstr "// Distributor I/O设备描述符\n"

#: src/architecture/irq/vgic.md:203
msgid "// init SPI interrupt\n"
msgstr "// init SPI interrupt\n"

#: src/architecture/irq/vgic.md:227
msgid "VGIC Distributor 主要模拟 nr_spis 个 spis 中断"
msgstr "VGIC Distributor 主要模拟 nr_spis 个 spis 中断"

#: src/architecture/irq/vgic.md:232
msgid ""
"/// A linked list header for managing interrupts.\n"
"    /// This is used for managing the list of interrupts associated with a "
"VCPU.\n"
msgstr ""
"/// A linked list header for managing interrupts.\n"
"    /// This is used for managing the list of interrupts associated with a "
"VCPU.\n"

#: src/architecture/irq/vgic.md:236
msgid ""
"/// For SGIs and PPIs: The VCPU that generated the interrupt.\n"
"    /// For SPIs: The VCPU whose `ap_list` this is queued on.\n"
msgstr ""
"/// For SGIs and PPIs: The VCPU that generated the interrupt.\n"
"    /// For SPIs: The VCPU whose `ap_list` this is queued on.\n"

#: src/architecture/irq/vgic.md:240
msgid ""
"/// The VCPU that this interrupt should be sent to, based on the targets "
"register (v2)\n"
msgstr ""
"/// The VCPU that this interrupt should be sent to, based on the targets "
"register (v2)\n"

#: src/architecture/irq/vgic.md:243
msgid "/// The guest-visible interrupt ID.\n"
msgstr "/// The guest-visible interrupt ID.\n"

#: src/architecture/irq/vgic.md:246
msgid "/// Indicates if the interrupt is level-triggered only.\n"
msgstr "/// Indicates if the interrupt is level-triggered only.\n"

#: src/architecture/irq/vgic.md:249
msgid "/// Not used for LPIs.\n"
msgstr "/// Not used for LPIs.\n"

#: src/architecture/irq/vgic.md:252
msgid "/// Indicates if the interrupt is enabled.\n"
msgstr "/// Indicates if the interrupt is enabled.\n"

#: src/architecture/irq/vgic.md:257
msgid ""
"GIC所以只处理SPI类型的中断，原因是其它两类中断的输入就是针对特定一个CPU的，不"
"需要Distributor控制其中断信号的deliver行为；而SPI的目标CPU，是可以用户配置"
"的，因此需要模拟一个Distributor来控制中断deliver的目标，并将Distributor的控制"
"接口暴露给用户。"
msgstr ""
"GIC所以只处理SPI类型的中断，原因是其它两类中断的输入就是针对特定一个CPU的，不"
"需要Distributor控制其中断信号的deliver行为；而SPI的目标CPU，是可以用户配置"
"的，因此需要模拟一个Distributor来控制中断deliver的目标，并将Distributor的控制"
"接口暴露给用户。"

#: src/architecture/irq/vgic.md:258
msgid ""
"target_vcpu结构用来存放用户设置的GIC中断路由信息，如果用户没有设置，那"
"target_vcpu就使用默认的CPU0，后续GIC可能会根据负载均衡策略将中断分发到其它目"
"标CPU上。换句话说，target_vcpu可能不是中断最终投递的CPU，只是一个初始值，而"
"vcpu才是中断最终投递的CPU"
msgstr ""
"target_vcpu结构用来存放用户设置的GIC中断路由信息，如果用户没有设置，那"
"target_vcpu就使用默认的CPU0，后续GIC可能会根据负载均衡策略将中断分发到其它目"
"标CPU上。换句话说，target_vcpu可能不是中断最终投递的CPU，只是一个初始值，而"
"vcpu才是中断最终投递的CPU"

#: src/architecture/irq/vgic.md:260
msgid "VGIC初始化"
msgstr "VGIC初始化"

#: src/architecture/irq/vgic.md:262
msgid "vgicd-ctrl 寄存器："
msgstr "vgicd-ctrl 寄存器："

#: src/architecture/irq/vgic.md:264
msgid "​\t - 对于case 1、2 和 3，不需要 IPI 通信。case 4 需要 IPI 通信。"
msgstr "​\t - 对于case 1、2 和 3，不需要 IPI 通信。case 4 需要 IPI 通信。"

#: src/architecture/irq/vgic.md:266
msgid "vgicd-iid 寄存器，vgicd-type 寄存器："
msgstr "vgicd-iid 寄存器，vgicd-type 寄存器："

#: src/architecture/irq/vgic.md:268
msgid "​\t - 这些寄存器保存 GIC 的一些属性和处理元素（PE）的数量。"
msgstr "​\t - 这些寄存器保存 GIC 的一些属性和处理元素（PE）的数量。"

#: src/architecture/irq/vgic.md:272
msgid "vgicd-isenable 寄存器："
msgstr "vgicd-isenable 寄存器："

#: src/architecture/irq/vgic.md:274
msgid "​\t - getenable：直接从结构中读取内容。"
msgstr "​\t - getenable：直接从结构中读取内容。"

#: src/architecture/irq/vgic.md:276
msgid ""
"​\t - setenable：根据 vtop 和 ptov 设置配置 GIC。对于情况 1、2 和 3，不需要 "
"IPI 通信。情况 4 需要 IPI 通信。"
msgstr ""
"​\t - setenable：根据 vtop 和 ptov 设置配置 GIC。对于情况 1、2 和 3，不需要 "
"IPI 通信。情况 4 需要 IPI 通信。"

#: src/architecture/irq/vgic.md:278
msgid "其他 emu 寄存器："
msgstr "其他 emu 寄存器："

#: src/architecture/irq/vgic.md:280
msgid "​\t - 其他 vgicd-emu 寄存器与 isenabler 类似。"
msgstr "​\t - 其他 vgicd-emu 寄存器与 isenabler 类似。"

#: src/architecture/irq/vgic.md:282
msgid "SGI软件生成中断"
msgstr "SGI软件生成中断"

#: src/architecture/irq/vgic.md:284
msgid ""
"SGI是一种特殊的中断，由软件生成，通常用于在多核系统中实现CPU间通信。SGI的目标"
"CPU由发送者指定，并且SGI可以被路由到一个或多个核上。"
msgstr ""
"SGI是一种特殊的中断，由软件生成，通常用于在多核系统中实现CPU间通信。SGI的目标"
"CPU由发送者指定，并且SGI可以被路由到一个或多个核上。"

#: src/architecture/irq/vgic.md:286
msgid ""
"在虚拟化环境下，由于多个vCPU可能共享同一个物理CPU，hypervisor需要对SGI进行虚"
"拟化，以确保VM之间的隔离性和透明性。"
msgstr ""
"在虚拟化环境下，由于多个vCPU可能共享同一个物理CPU，hypervisor需要对SGI进行虚"
"拟化，以确保VM之间的隔离性和透明性。"

#: src/architecture/irq/vgic.md:288
msgid "Hypervisor对SGI的拦截"
msgstr "Hypervisor对SGI的拦截"

#: src/architecture/irq/vgic.md:290
msgid ""
"在虚拟化环境中，当VM试图发送SGI时，通常通过修改guest的GIC相关寄存器来触发。VM"
"本身无法直接访问物理的GIC Distributor（GICD）寄存器，因此这些写操作会被"
"hypervisor拦截。"
msgstr ""
"在虚拟化环境中，当VM试图发送SGI时，通常通过修改guest的GIC相关寄存器来触发。VM"
"本身无法直接访问物理的GIC Distributor（GICD）寄存器，因此这些写操作会被"
"hypervisor拦截。"

#: src/architecture/irq/vgic.md:292
msgid "**vCPU到vCPU的SGI**：VM发送SGI给自己的vCPU或同一个VM中的其他vCPU。"
msgstr "**vCPU到vCPU的SGI**：VM发送SGI给自己的vCPU或同一个VM中的其他vCPU。"

#: src/architecture/irq/vgic.md:294
msgid "SGI的处理与路由"
msgstr "SGI的处理与路由"

#: src/architecture/irq/vgic.md:296
msgid "在SGI虚拟化中，hypervisor负责以下操作："
msgstr "在SGI虚拟化中，hypervisor负责以下操作："

#: src/architecture/irq/vgic.md:298
msgid ""
"**拦截和解析SGI**：当VM写入GICD_SGIR寄存器（用于触发SGI），hypervisor会拦截该"
"写操作。它解析出目标vCPU以及SGI的ID。"
msgstr ""
"**拦截和解析SGI**：当VM写入GICD_SGIR寄存器（用于触发SGI），hypervisor会拦截该"
"写操作。它解析出目标vCPU以及SGI的ID。"

#: src/architecture/irq/vgic.md:299
msgid ""
"**SGI的重定向**：hypervisor根据解析出的SGI信息，将SGI重新路由到目标vCPU，这里"
"应该有有一个接口能够根据vcpu_id注入指定的中断。"
msgstr ""
"**SGI的重定向**：hypervisor根据解析出的SGI信息，将SGI重新路由到目标vCPU，这里"
"应该有有一个接口能够根据vcpu_id注入指定的中断。"

#: src/architecture/irq/vgic.md:300
msgid "vCPU活跃：直接发送到指定的vCPU"
msgstr "vCPU活跃：直接发送到指定的vCPU"

#: src/architecture/irq/vgic.md:301
msgid "vCPU休眠：唤醒vCPU后，再发送到指定vCPU"
msgstr "vCPU休眠：唤醒vCPU后，再发送到指定vCPU"

#: src/architecture/irq/vgic.md:302
msgid ""
"**中断优先级和状态管理**：hypervisor需要维护虚拟中断的优先级和状态（如等待、"
"激活等），以确保VM感知到的中断行为与物理硬件一致。"
msgstr ""
"**中断优先级和状态管理**：hypervisor需要维护虚拟中断的优先级和状态（如等待、"
"激活等），以确保VM感知到的中断行为与物理硬件一致。"

#: src/architecture/irq/vgic.md:304
msgid "虚拟GIC的支持"
msgstr "虚拟GIC的支持"

#: src/architecture/irq/vgic.md:306
msgid ""
"为了让VM能够像使用物理GIC一样处理中断，hypervisor会提供虚拟的GIC接口"
"（vGIC）。vGIC负责模拟GICD和GICC（CPU接口）的寄存器操作，并将这些寄存器映射到"
"VM的地址空间。"
msgstr ""
"为了让VM能够像使用物理GIC一样处理中断，hypervisor会提供虚拟的GIC接口"
"（vGIC）。vGIC负责模拟GICD和GICC（CPU接口）的寄存器操作，并将这些寄存器映射到"
"VM的地址空间。"

#: src/architecture/irq/vgic.md:308
msgid "虚拟GIC支持VM的SGI管理，包括："
msgstr "虚拟GIC支持VM的SGI管理，包括："

#: src/architecture/irq/vgic.md:310
msgid ""
"**虚拟GICD_SGIR寄存器**：VM通过这个寄存器触发SGI，hypervisor在接收到写操作后"
"进行中断重定向。"
msgstr ""
"**虚拟GICD_SGIR寄存器**：VM通过这个寄存器触发SGI，hypervisor在接收到写操作后"
"进行中断重定向。"

#: src/architecture/irq/vgic.md:311
msgid ""
"**虚拟中断路由表**：hypervisor维护一个虚拟的中断路由表List Registers，用来追"
"踪SGI应该被路由到哪个vCPU。"
msgstr ""
"**虚拟中断路由表**：hypervisor维护一个虚拟的中断路由表List Registers，用来追"
"踪SGI应该被路由到哪个vCPU。"

#: src/architecture/irq/vgic.md:313
msgid "![](../../assets/vgicv2/case1.png)"
msgstr "![](../../assets/vgicv2/case1.png)"

#: src/architecture/irq/vgic.md:315
msgid "PPI 私有外设中断"
msgstr "PPI 私有外设中断"

#: src/architecture/irq/vgic.md:317
msgid ""
"PPI通常用于管理特定于处理器的外设中断。在GICv2中，每个核心都有其专属的PPI，通"
"常包括定时器中断和其他本地外设中断。在虚拟化环境中，hypervisor需要虚拟化这些"
"中断，以便每个VM能够透明地访问和使用它们。"
msgstr ""
"PPI通常用于管理特定于处理器的外设中断。在GICv2中，每个核心都有其专属的PPI，通"
"常包括定时器中断和其他本地外设中断。在虚拟化环境中，hypervisor需要虚拟化这些"
"中断，以便每个VM能够透明地访问和使用它们。"

#: src/architecture/irq/vgic.md:319
msgid "VM发起PPI请求"
msgstr "VM发起PPI请求"

#: src/architecture/irq/vgic.md:321
msgid ""
"当VM中的vCPU需要处理PPI时，通常是通过对GIC的寄存器进行操作。例如，vCPU可能会"
"读取或清除某个PPI的状态，这一操作需要经过hypervisor的拦截。"
msgstr ""
"当VM中的vCPU需要处理PPI时，通常是通过对GIC的寄存器进行操作。例如，vCPU可能会"
"读取或清除某个PPI的状态，这一操作需要经过hypervisor的拦截。"

#: src/architecture/irq/vgic.md:323
msgid "Hypervisor拦截请求"
msgstr "Hypervisor拦截请求"

#: src/architecture/irq/vgic.md:325
msgid ""
"**拦截操作**：Hypervisor监测对PPI相关寄存器的访问请求，特别是GIC的PPI寄存器。"
msgstr ""
"**拦截操作**：Hypervisor监测对PPI相关寄存器的访问请求，特别是GIC的PPI寄存器。"

#: src/architecture/irq/vgic.md:326
msgid ""
"**解析请求**：Hypervisor解析该请求以确定哪个vCPU或VM正在进行操作，并根据需要"
"处理这些请求。"
msgstr ""
"**解析请求**：Hypervisor解析该请求以确定哪个vCPU或VM正在进行操作，并根据需要"
"处理这些请求。"

#: src/architecture/irq/vgic.md:328
msgid "PPI的路由和分发"
msgstr "PPI的路由和分发"

#: src/architecture/irq/vgic.md:330
msgid ""
"**管理PPI状态**：Hypervisor需要维护每个VM的PPI状态，确保在VM运行时，PPI的状态"
"能够正确反映在对应的vCPU上。"
msgstr ""
"**管理PPI状态**：Hypervisor需要维护每个VM的PPI状态，确保在VM运行时，PPI的状态"
"能够正确反映在对应的vCPU上。"

#: src/architecture/irq/vgic.md:331
msgid ""
"**中断注入**：当PPI中断发生时，hypervisor负责将中断注入到对应的vCPU中。对于"
"PPI，hypervisor可以直接向目标vCPU发送中断请求，而不需要重定向。"
msgstr ""
"**中断注入**：当PPI中断发生时，hypervisor负责将中断注入到对应的vCPU中。对于"
"PPI，hypervisor可以直接向目标vCPU发送中断请求，而不需要重定向。"

#: src/architecture/irq/vgic.md:333 src/architecture/irq/vgic.md:363
msgid "目标vCPU处理中断"
msgstr "目标vCPU处理中断"

#: src/architecture/irq/vgic.md:335
msgid ""
"**vCPU处理PPI**：一旦PPI被触发，目标vCPU会进入中断处理程序，执行相应的处理逻"
"辑。"
msgstr ""
"**vCPU处理PPI**：一旦PPI被触发，目标vCPU会进入中断处理程序，执行相应的处理逻"
"辑。"

#: src/architecture/irq/vgic.md:336
msgid "**状态恢复**：处理完成后，vCPU会清除PPI中断状态，并恢复执行状态。"
msgstr "**状态恢复**：处理完成后，vCPU会清除PPI中断状态，并恢复执行状态。"

#: src/architecture/irq/vgic.md:338 src/architecture/irq/vgic.md:368
msgid "Hypervisor的清理工作"
msgstr "Hypervisor的清理工作"

#: src/architecture/irq/vgic.md:340
msgid ""
"**状态管理**：Hypervisor在处理完PPI中断后，负责清理中断状态和相关的寄存器，确"
"保后续中断请求的正确性。"
msgstr ""
"**状态管理**：Hypervisor在处理完PPI中断后，负责清理中断状态和相关的寄存器，确"
"保后续中断请求的正确性。"

#: src/architecture/irq/vgic.md:341
msgid "![](../../assets/vgicv2/case_ppi.png)"
msgstr "![](../../assets/vgicv2/case_ppi.png)"

#: src/architecture/irq/vgic.md:343
msgid "SPI 共享外设中断"
msgstr "SPI 共享外设中断"

#: src/architecture/irq/vgic.md:345
msgid ""
"在虚拟化环境中，SPI（Shared Peripheral Interrupt，共享外设中断）是一种用于处"
"理多个处理器核心共享外设的中断。与SGI和PPI不同，SPI是针对共享设备的中断，允许"
"多个CPU响应同一外设生成的中断。hypervisor在虚拟化SPI时需要确保VM之间的隔离，"
"同时提供对共享外设的正确中断管理。"
msgstr ""
"在虚拟化环境中，SPI（Shared Peripheral Interrupt，共享外设中断）是一种用于处"
"理多个处理器核心共享外设的中断。与SGI和PPI不同，SPI是针对共享设备的中断，允许"
"多个CPU响应同一外设生成的中断。hypervisor在虚拟化SPI时需要确保VM之间的隔离，"
"同时提供对共享外设的正确中断管理。"

#: src/architecture/irq/vgic.md:347
msgid ""
"SPI通常用于系统中那些可以被多个处理器访问的外设，例如网络适配器、存储控制器"
"等。在GICv2中，SPI由GIC的Distributor（GICD）管理，允许多个处理器核接收来自同"
"一外设的中断。在虚拟化环境中，hypervisor需要将SPI虚拟化为适合多个VM使用的形"
"式。"
msgstr ""
"SPI通常用于系统中那些可以被多个处理器访问的外设，例如网络适配器、存储控制器"
"等。在GICv2中，SPI由GIC的Distributor（GICD）管理，允许多个处理器核接收来自同"
"一外设的中断。在虚拟化环境中，hypervisor需要将SPI虚拟化为适合多个VM使用的形"
"式。"

#: src/architecture/irq/vgic.md:349
msgid "VM发起SPI请求"
msgstr "VM发起SPI请求"

#: src/architecture/irq/vgic.md:351
msgid ""
"当外设生成中断时，它将通过物理GIC将SPI传递给相应的处理器核心。在虚拟化环境"
"中，物理中断首先会传递到hypervisor。"
msgstr ""
"当外设生成中断时，它将通过物理GIC将SPI传递给相应的处理器核心。在虚拟化环境"
"中，物理中断首先会传递到hypervisor。"

#: src/architecture/irq/vgic.md:353
msgid "Hypervisor的拦截和管理"
msgstr "Hypervisor的拦截和管理"

#: src/architecture/irq/vgic.md:355
msgid ""
"**拦截中断**：Hypervisor拦截来自外设的SPI请求，并识别该中断的目标VM（如果已映"
"射）。"
msgstr ""
"**拦截中断**：Hypervisor拦截来自外设的SPI请求，并识别该中断的目标VM（如果已映"
"射）。"

#: src/architecture/irq/vgic.md:356
msgid ""
"**中断映射**：Hypervisor维护一个中断映射表，将物理中断与VM中的虚拟中断进行关"
"联。"
msgstr ""
"**中断映射**：Hypervisor维护一个中断映射表，将物理中断与VM中的虚拟中断进行关"
"联。"

#: src/architecture/irq/vgic.md:358
msgid "SPI的路由和重定向"
msgstr "SPI的路由和重定向"

#: src/architecture/irq/vgic.md:360
msgid "**目标VM识别**：Hypervisor通过中断映射表确定SPI应该路由到哪个VM的vCPU。"
msgstr ""
"**目标VM识别**：Hypervisor通过中断映射表确定SPI应该路由到哪个VM的vCPU。"

#: src/architecture/irq/vgic.md:361
msgid "**中断注入**：Hypervisor将SPI注入到目标VM的对应vCPU中，以触发中断处理。"
msgstr ""
"**中断注入**：Hypervisor将SPI注入到目标VM的对应vCPU中，以触发中断处理。"

#: src/architecture/irq/vgic.md:365
msgid ""
"**处理SPI中断**：目标vCPU接收到中断请求后，执行相应的中断处理程序。此过程包括"
"保存上下文、执行处理逻辑以及清除中断状态。"
msgstr ""
"**处理SPI中断**：目标vCPU接收到中断请求后，执行相应的中断处理程序。此过程包括"
"保存上下文、执行处理逻辑以及清除中断状态。"

#: src/architecture/irq/vgic.md:366
msgid "**状态恢复**：处理完成后，vCPU需要恢复到正常执行状态，并清除中断标志。"
msgstr "**状态恢复**：处理完成后，vCPU需要恢复到正常执行状态，并清除中断标志。"

#: src/architecture/irq/vgic.md:370
msgid ""
"**状态更新**：Hypervisor在处理完SPI中断后，更新中断的状态，以反映当前的处理中"
"断情况。"
msgstr ""
"**状态更新**：Hypervisor在处理完SPI中断后，更新中断的状态，以反映当前的处理中"
"断情况。"

#: src/architecture/irq/vgic.md:372
msgid "![](../../assets/vgicv2/case4.png)"
msgstr "![](../../assets/vgicv2/case4.png)"

#: src/architecture/irq/vgic.md:374
msgid "List Register"
msgstr "List Register"

#: src/architecture/irq/vgic.md:376
msgid "![img](../../assets/vgicv2/lr.png)"
msgstr "![img](../../assets/vgicv2/lr.png)"

#: src/architecture/irq/vgic.md:378
msgid ""
"对于有虚拟化扩展的 GIC，Hypervisor使用 List Registers 来维护高优先级虚拟中断"
"的一些上下文信息。"
msgstr ""
"对于有虚拟化扩展的 GIC，Hypervisor使用 List Registers 来维护高优先级虚拟中断"
"的一些上下文信息。"

#: src/architecture/irq/vgic.md:382
msgid "// virq 中断号\n"
msgstr "// virq 中断号\n"

#: src/architecture/irq/vgic.md:383
msgid ""
"// 此 field 根据 hw 值不同而不同\n"
"                        // hw=1，表示此虚拟中断关联了一个物理中断，此 pid 为"
"实际的 physical irq 中断号\n"
"                        // hw=0，bit19表示是否 signal eoi，给 maintenance "
"interrupt 使用，不做讨论\n"
"                                 //bit12-10，如果这是一个 sgi 中断，即 "
"virtual interrupt id < 15，那么此位域表示 requesting cpu id\n"
msgstr ""
"// 此 field 根据 hw 值不同而不同\n"
"                        // hw=1，表示此虚拟中断关联了一个物理中断，此 pid 为"
"实际的 physical irq 中断号\n"
"                        // hw=0，bit19表示是否 signal eoi，给 maintenance "
"interrupt 使用，不做讨论\n"
"                                 //bit12-10，如果这是一个 sgi 中断，即 "
"virtual interrupt id < 15，那么此位域表示 requesting cpu id\n"

#: src/architecture/irq/vgic.md:388
msgid "// 保留\n"
msgstr "// 保留\n"

#: src/architecture/irq/vgic.md:389
msgid "// 该virtual integrrupt 的优先级\n"
msgstr "// 该virtual integrrupt 的优先级\n"

#: src/architecture/irq/vgic.md:390
msgid "// 指示该中断的状态，invalid、pending、active、pending and active\n"
msgstr "// 指示该中断的状态，invalid、pending、active、pending and active\n"

#: src/architecture/irq/vgic.md:391
msgid ""
"// 表示该 virtual integrrupt 是否是 group 1 virtual integrrupt\n"
"                        // 0 表示这是一个 group 0 virtual interrupt，表示安全"
"虚拟中断，可配置是按照 virq 还是 vfiq 发送给 vcpu\n"
"                        // 1 表示这是一个 group 1 virtual interrupt，表示非安"
"全虚拟中断，该中断以 virq 的形式触发，而不是 vfiq\n"
msgstr ""
"// 表示该 virtual integrrupt 是否是 group 1 virtual integrrupt\n"
"                        // 0 表示这是一个 group 0 virtual interrupt，表示安全"
"虚拟中断，可配置是按照 virq 还是 vfiq 发送给 vcpu\n"
"                        // 1 表示这是一个 group 1 virtual interrupt，表示非安"
"全虚拟中断，该中断以 virq 的形式触发，而不是 vfiq\n"

#: src/architecture/irq/vgic.md:395
msgid ""
"// 该虚拟中断是否关联了一个硬件物理中断\n"
"                        // 0 表示否，这是 triggered in software，当 "
"deactivated 的时候不会通知 distributor\n"
"                        // 1 表示是，那么 deactivate 这个虚拟中断也会向对应的"
"物理中断也执行 deactivate 操作\n"
"                        // 而具体的 deactivate 操作，如果 gicv_ctlr."
"eoimode=0，写 gicv_eoir 寄存器表示 drop priority 和 deactive 操作同时进行 \n"
"                        // 如果 gicv_ctlr.eoimode=1，写 gicv_eoir 寄存器表示 "
"drop priority，写 GICV_DIR 表示 deactive\n"
msgstr ""
"// 该虚拟中断是否关联了一个硬件物理中断\n"
"                        // 0 表示否，这是 triggered in software，当 "
"deactivated 的时候不会通知 distributor\n"
"                        // 1 表示是，那么 deactivate 这个虚拟中断也会向对应的"
"物理中断也执行 deactivate 操作\n"
"                        // 而具体的 deactivate 操作，如果 gicv_ctlr."
"eoimode=0，写 gicv_eoir 寄存器表示 drop priority 和 deactive 操作同时进行 \n"
"                        // 如果 gicv_ctlr.eoimode=1，写 gicv_eoir 寄存器表示 "
"drop priority，写 GICV_DIR 表示 deactive\n"

#: src/architecture/irq/vgic.md:403
msgid "VGIC 寄存器虚拟化"
msgstr "VGIC 寄存器虚拟化"

#: src/architecture/irq/vgic.md:405
msgid ""
"有的寄存器是单个32位长，有的寄存器是多个32位长，所以使用宏来定义各个寄存器，"
"提供直观的访问方式"
msgstr ""
"有的寄存器是单个32位长，有的寄存器是多个32位长，所以使用宏来定义各个寄存器，"
"提供直观的访问方式"

#: src/architecture/irq/vgic.md:408
msgid "// Macro to define GIC register enums\n"
msgstr "// Macro to define GIC register enums\n"

#: src/architecture/irq/vgic.md:435
msgid "// Range register variant with index\n"
msgstr "// Range register variant with index\n"

#: src/architecture/irq/vgic.md:441
msgid "// Convert address to register enum\n"
msgstr "// Convert address to register enum\n"

#: src/architecture/irq/vgic.md:444
msgid "// Match single registers\n"
msgstr "// Match single registers\n"

#: src/architecture/irq/vgic.md:446
msgid "// Single register match\n"
msgstr "// Single register match\n"

#: src/architecture/irq/vgic.md:448
msgid "// Match range registers\n"
msgstr "// Match range registers\n"

#: src/architecture/irq/vgic.md:451
msgid "// Calculate index\n"
msgstr "// Calculate index\n"

#: src/architecture/irq/vgic.md:453
msgid "// Range register match\n"
msgstr "// Range register match\n"

#: src/architecture/irq/vgic.md:459
msgid "// No match\n"
msgstr "// No match\n"

#: src/architecture/irq/vgic.md:465
msgid "// Use the macro to generate specific register definitions\n"
msgstr "// Use the macro to generate specific register definitions\n"

#: src/architecture/irq/vgic.md:469
msgid "// Distributor Control Register\n"
msgstr "// Distributor Control Register\n"

#: src/architecture/irq/vgic.md:471
msgid "// Distributor Type Register\n"
msgstr "// Distributor Type Register\n"

#: src/architecture/irq/vgic.md:473
msgid "// Distributor Implementer Identification Register\n"
msgstr "// Distributor Implementer Identification Register\n"

#: src/architecture/irq/vgic.md:475
msgid "// Distributor Status Register\n"
msgstr "// Distributor Status Register\n"

#: src/architecture/irq/vgic.md:479
msgid "// Interrupt Group Register\n"
msgstr "// Interrupt Group Register\n"

#: src/architecture/irq/vgic.md:484
msgid "// Interrupt Enable Set Register\n"
msgstr "// Interrupt Enable Set Register\n"

#: src/architecture/irq/vgic.md:489
msgid "// Interrupt Enable Clear Register\n"
msgstr "// Interrupt Enable Clear Register\n"

#: src/architecture/irq/vgic.md:494
msgid "// Interrupt Pending Set Register\n"
msgstr "// Interrupt Pending Set Register\n"

#: src/architecture/irq/vgic.md:503
msgid "// Interrupt Active Set Register\n"
msgstr "// Interrupt Active Set Register\n"

#: src/architecture/irq/vgic.md:508
msgid "// Interrupt Active Clear Register\n"
msgstr "// Interrupt Active Clear Register\n"

#: src/architecture/irq/vgic.md:513
msgid "// Interrupt Priority Register\n"
msgstr "// Interrupt Priority Register\n"

#: src/architecture/irq/vgic.md:518
msgid "// Interrupt Target Register\n"
msgstr "// Interrupt Target Register\n"

#: src/architecture/irq/vgic.md:523
msgid "// Interrupt Configuration Register\n"
msgstr "// Interrupt Configuration Register\n"

#: src/architecture/irq/vgic.md:528
msgid "// PPI Status Register\n"
msgstr "// PPI Status Register\n"

#: src/architecture/irq/vgic.md:533
msgid "// SPI Status Register\n"
msgstr "// SPI Status Register\n"

#: src/architecture/irq/vgic.md:538
msgid "// Non-Secure Access Control Register\n"
msgstr "// Non-Secure Access Control Register\n"

#: src/architecture/irq/vgic.md:543
msgid "// Software Generated Interrupt Register\n"
msgstr "// Software Generated Interrupt Register\n"

#: src/architecture/irq/vgic.md:548
msgid "// Pending Software Generated Interrupt Register\n"
msgstr "// Pending Software Generated Interrupt Register\n"

#: src/architecture/irq/vgic.md:553
msgid "// Software Generated Interrupt Pending Register\n"
msgstr "// Software Generated Interrupt Pending Register\n"

#: src/architecture/irq/vgic.md:560
msgid "// 访问寄存器的方法\n"
msgstr "// 访问寄存器的方法\n"

#: src/architecture/irq/vgic.md:573
msgid "\"Read register address: {addr:#x}\""
msgstr "\"Read register address: {addr:#x}\""

#: src/architecture/irq/vgic.md:577
msgid "\"Invalid read register address: {addr:#x}\""
msgstr "\"Invalid read register address: {addr:#x}\""

#: src/architecture/irq/vgic.md:583
msgid "KVM关于VGIC的设计"
msgstr "KVM关于VGIC的设计"

#: src/architecture/irq/vgic.md:588
msgid "/* SPI 类型 */"
msgstr "/* SPI 类型 */"

#: src/architecture/irq/vgic.md:589
msgid "/* vcpu_idx: 0*/"
msgstr "/* vcpu_idx: 0*/"

#: src/architecture/irq/vgic.md:590
msgid "/* 中断号：32+7 = 39 */"
msgstr "/* 中断号：32+7 = 39 */"

#: src/architecture/irq/vgic.md:592
msgid "/* 发往特定CPU上的快速中断 */"
msgstr "/* 发往特定CPU上的快速中断 */"

#: src/architecture/irq/vgic.md:599
msgid "/* 根据cpuid取出vcpu结构体*/"
msgstr "/* 根据cpuid取出vcpu结构体*/"

#: src/architecture/irq/vgic.md:605
msgid ""
"/* 立即投递到cpu的中断状态字段，然后kick cpu进行处理\n"
"\t\t * 由于是快速中断，KVM直接更新的irq_lines字段，没有将中断信号放到vgic_cpu"
"的ap_list上排队\n"
"\t\t */"
msgstr ""
"/* 立即投递到cpu的中断状态字段，然后kick cpu进行处理\n"
"\t\t * 由于是快速中断，KVM直接更新的irq_lines字段，没有将中断信号放到vgic_cpu"
"的ap_list上排队\n"
"\t\t */"

#: src/architecture/irq/vgic.md:609
msgid "/* CPU私有类型的中断 */"
msgstr "/* CPU私有类型的中断 */"

#: src/architecture/irq/vgic.md:616
msgid "/* 根据cpuid取出vcpu结构体 */"
msgstr "/* 根据cpuid取出vcpu结构体 */"

#: src/architecture/irq/vgic.md:622
msgid ""
"/* 非快速中断，取出目的vcpu后，将中断信号放到vcpu的ap_list字段排队，等待vcpu"
"处理 */"
msgstr ""
"/* 非快速中断，取出目的vcpu后，将中断信号放到vcpu的ap_list字段排队，等待vcpu"
"处理 */"

#: src/architecture/irq/vgic.md:630
msgid ""
"/* 非快速中断，SPI默认发送vcpu 0上，同样将中断信号放到vcpu的ap_list字段排队，"
"等待vcpu处理 */"
msgstr ""
"/* 非快速中断，SPI默认发送vcpu 0上，同样将中断信号放到vcpu的ap_list字段排队，"
"等待vcpu处理 */"

#: src/architecture/irq/vlapic.md:1
msgid "虚拟 Local APIC"
msgstr "虚拟 Local APIC"

#: src/architecture/irq/vlapic.md:3
msgid "本节描述了虚拟 Local APIC 的实现。"
msgstr "本节描述了虚拟 Local APIC 的实现。"

#: src/architecture/irq/vlapic.md:5
msgid "全虚拟化"
msgstr "全虚拟化"

#: src/architecture/irq/vlapic.md:7
msgid "寄存器虚拟化："
msgstr "寄存器虚拟化："

#: src/architecture/irq/vlapic.md:9
msgid ""
"Local APIC 的寄存器通过内存映射（MMIO）访问。虚拟机对 APIC 寄存器的读写会触"
"发 VM-exit，由虚拟化层（如 VMM/Hypervisor）模拟这些操作，维护每个虚拟 CPU"
"（vCPU）的虚拟寄存器状态。"
msgstr ""
"Local APIC 的寄存器通过内存映射（MMIO）访问。虚拟机对 APIC 寄存器的读写会触"
"发 VM-exit，由虚拟化层（如 VMM/Hypervisor）模拟这些操作，维护每个虚拟 CPU"
"（vCPU）的虚拟寄存器状态。"

#: src/architecture/irq/vlapic.md:11
msgid "中断注入："
msgstr "中断注入："

#: src/architecture/irq/vlapic.md:13
msgid ""
"当物理中断需要传递给虚拟机时，虚拟化层将其转换为虚拟中断（如虚拟 IRQ），并通"
"过修改虚拟 APIC 的状态（如 IRR/ISR 寄存器）或直接注入中断（如 Intel 的 vmcs "
"VM_ENTRY_INTR_INFO）通知虚拟机。"
msgstr ""
"当物理中断需要传递给虚拟机时，虚拟化层将其转换为虚拟中断（如虚拟 IRQ），并通"
"过修改虚拟 APIC 的状态（如 IRR/ISR 寄存器）或直接注入中断（如 Intel 的 vmcs "
"VM_ENTRY_INTR_INFO）通知虚拟机。"

#: src/architecture/irq/vlapic.md:15
msgid "定时器虚拟化："
msgstr "定时器虚拟化："

#: src/architecture/irq/vlapic.md:17
msgid ""
"虚拟 APIC 定时器需根据虚拟机的配置（如周期和计数）模拟中断。Hypervisor 可能使"
"用物理定时器（如 host 的 hrtimer）或时间偏移技术来触发虚拟中断。"
msgstr ""
"虚拟 APIC 定时器需根据虚拟机的配置（如周期和计数）模拟中断。Hypervisor 可能使"
"用物理定时器（如 host 的 hrtimer）或时间偏移技术来触发虚拟中断。"

#: src/architecture/irq/vlapic.md:19
msgid "硬件辅助虚拟化"
msgstr "硬件辅助虚拟化"

#: src/architecture/irq/vlapic.md:21
msgid "现代 CPU（如 Intel VT-x 和 AMD-V）提供了硬件加速特性，显著优化性能："
msgstr "现代 CPU（如 Intel VT-x 和 AMD-V）提供了硬件加速特性，显著优化性能："

#: src/architecture/irq/vlapic.md:23
msgid "APICv（Intel） / AVIC（AMD）："
msgstr "APICv（Intel） / AVIC（AMD）："

#: src/architecture/irq/vlapic.md:25
msgid "硬件直接支持虚拟 APIC 状态维护，减少 VM-exit。例如："
msgstr "硬件直接支持虚拟 APIC 状态维护，减少 VM-exit。例如："

#: src/architecture/irq/vlapic.md:27
msgid ""
"Virtual APIC Page：在 VMCS 中维护虚拟 APIC 的寄存器，允许虚拟机直接访问，无需"
"陷入。"
msgstr ""
"Virtual APIC Page：在 VMCS 中维护虚拟 APIC 的寄存器，允许虚拟机直接访问，无需"
"陷入。"

#: src/architecture/irq/vlapic.md:29
msgid "中断投递优化：硬件自动将中断路由到目标 vCPU 的虚拟 APIC。"
msgstr "中断投递优化：硬件自动将中断路由到目标 vCPU 的虚拟 APIC。"

#: src/architecture/irq/vlapic.md:31
msgid "自动处理 EOI：某些中断的确认（EOI）由硬件处理，避免 VM-exit。"
msgstr "自动处理 EOI：某些中断的确认（EOI）由硬件处理，避免 VM-exit。"

#: src/architecture/irq/vlapic.md:33
msgid "Posted Interrupts（Intel）："
msgstr "Posted Interrupts（Intel）："

#: src/architecture/irq/vlapic.md:35
msgid ""
"物理中断可直接“投递”到虚拟机的虚拟 APIC，绕过 Hypervisor 干预，极大降低延迟。"
msgstr ""
"物理中断可直接“投递”到虚拟机的虚拟 APIC，绕过 Hypervisor 干预，极大降低延迟。"

#: src/architecture/irq/vlapic.md:37
msgid "具体实现"
msgstr "具体实现"

#: src/architecture/irq/vlapic.md:39
msgid "代码位于 [x86-vlapic](https://github.com/arceos-hypervisor/x86_vlapic)"
msgstr "代码位于 [x86-vlapic](https://github.com/arceos-hypervisor/x86_vlapic)"

#: src/architecture/irq/vlapic.md:41
msgid ""
"`EmulatedLocalApic` 实现了虚拟中断的基本方法，通过 `handle_read` "
"`handle_write` 实现读写虚拟中断寄存器的功能。"
msgstr ""
"`EmulatedLocalApic` 实现了虚拟中断的基本方法，通过 `handle_read` "
"`handle_write` 实现读写虚拟中断寄存器的功能。"

#: src/architecture/irq/vlapic.md:43
msgid ""
"`VirtualApicRegs` 包含了 `APIC` 所有寄存器，保存客户机虚拟中断的寄存器状态"
msgstr ""
"`VirtualApicRegs` 包含了 `APIC` 所有寄存器，保存客户机虚拟中断的寄存器状态"

#: src/architecture/irq/vlapic.md:45
msgid "Local APIC 寄存器"
msgstr "Local APIC 寄存器"

#: src/architecture/irq/vlapic.md:47
msgid ""
"本地APIC寄存器被内存映射到MP/MADT表中可找到的地址。若使用分页，请确保将这些寄"
"存器映射到虚拟内存。每个寄存器均为32位长，并期望以32位整数形式进行读写。尽管"
"每个寄存器占用4个字节，但它们都按16字节边界对齐。 本地APIC寄存器列表（待办事"
"项：为所有寄存器添加描述）："
msgstr ""
"本地APIC寄存器被内存映射到MP/MADT表中可找到的地址。若使用分页，请确保将这些寄"
"存器映射到虚拟内存。每个寄存器均为32位长，并期望以32位整数形式进行读写。尽管"
"每个寄存器占用4个字节，但它们都按16字节边界对齐。 本地APIC寄存器列表（待办事"
"项：为所有寄存器添加描述）："

#: src/architecture/irq/vlapic.md:55
msgid ""
"/// Local APIC ID register (VID): the 32-bit field located at offset 000H on "
"the virtual-APIC page.\n"
msgstr ""
"/// Local APIC ID register (VID): the 32-bit field located at offset 000H on "
"the virtual-APIC page.\n"

#: src/architecture/irq/vlapic.md:58
msgid ""
"/// Local APIC Version register (VVER): the 32-bit field located at offset "
"030H on the virtual-APIC page.\n"
msgstr ""
"/// Local APIC Version register (VVER): the 32-bit field located at offset "
"030H on the virtual-APIC page.\n"

#: src/architecture/irq/vlapic.md:61
msgid ""
"/// Virtual task-priority register (VTPR): the 32-bit field located at "
"offset 080H on the virtual-APIC page.\n"
msgstr ""
"/// Virtual task-priority register (VTPR): the 32-bit field located at "
"offset 080H on the virtual-APIC page.\n"

#: src/architecture/irq/vlapic.md:64
msgid ""
"/// Virtual APIC-priority register (VAPR): the 32-bit field located at "
"offset 090H on the virtual-APIC page.\n"
msgstr ""
"/// Virtual APIC-priority register (VAPR): the 32-bit field located at "
"offset 090H on the virtual-APIC page.\n"

#: src/architecture/irq/vlapic.md:67
msgid ""
"/// Virtual processor-priority register (VPPR): the 32-bit field located at "
"offset 0A0H on the virtual-APIC page.\n"
msgstr ""
"/// Virtual processor-priority register (VPPR): the 32-bit field located at "
"offset 0A0H on the virtual-APIC page.\n"

#: src/architecture/irq/vlapic.md:70
msgid ""
"/// Virtual end-of-interrupt register (VEOI): the 32-bit field located at "
"offset 0B0H on the virtual-APIC page.\n"
msgstr ""
"/// Virtual end-of-interrupt register (VEOI): the 32-bit field located at "
"offset 0B0H on the virtual-APIC page.\n"

#: src/architecture/irq/vlapic.md:73
msgid ""
"/// Virtual Remote Read Register (RRD): the 32-bit field located at offset "
"0C0H on the virtual-APIC page.\n"
msgstr ""
"/// Virtual Remote Read Register (RRD): the 32-bit field located at offset "
"0C0H on the virtual-APIC page.\n"

#: src/architecture/irq/vlapic.md:76
msgid ""
"/// Virtual Logical Destination Register (LDR): the 32-bit field located at "
"offset 0D0H on the virtual-APIC page.\n"
msgstr ""
"/// Virtual Logical Destination Register (LDR): the 32-bit field located at "
"offset 0D0H on the virtual-APIC page.\n"

#: src/architecture/irq/vlapic.md:79
msgid ""
"/// Virtual Destination Format Register (DFR): the 32-bit field located at "
"offset 0E0H on the virtual-APIC page.\n"
msgstr ""
"/// Virtual Destination Format Register (DFR): the 32-bit field located at "
"offset 0E0H on the virtual-APIC page.\n"

#: src/architecture/irq/vlapic.md:82
msgid ""
"/// Virtual Spurious Interrupt Vector Register (SVR): the 32-bit field "
"located at offset 0F0H on the virtual-APIC page.\n"
msgstr ""
"/// Virtual Spurious Interrupt Vector Register (SVR): the 32-bit field "
"located at offset 0F0H on the virtual-APIC page.\n"

#: src/architecture/irq/vlapic.md:85
msgid ""
"/// Virtual interrupt-service register (VISR):\n"
"        /// the 256-bit value comprising eight non-contiguous 32-bit fields "
"at offsets\n"
"        /// 100H, 110H, 120H, 130H, 140H, 150H, 160H, and 170H on the "
"virtual-APIC page.\n"
msgstr ""
"/// Virtual interrupt-service register (VISR):\n"
"        /// the 256-bit value comprising eight non-contiguous 32-bit fields "
"at offsets\n"
"        /// 100H, 110H, 120H, 130H, 140H, 150H, 160H, and 170H on the "
"virtual-APIC page.\n"

#: src/architecture/irq/vlapic.md:89
msgid ""
"/// Virtual trigger-mode register (VTMR):\n"
"        /// the 256-bit value comprising eight non-contiguous 32-bit fields "
"at offsets\n"
"        /// 180H, 190H, 1A0H, 1B0H, 1C0H, 1D0H, 1E0H, and 1F0H on the "
"virtual-APIC page.\n"
msgstr ""
"/// Virtual trigger-mode register (VTMR):\n"
"        /// the 256-bit value comprising eight non-contiguous 32-bit fields "
"at offsets\n"
"        /// 180H, 190H, 1A0H, 1B0H, 1C0H, 1D0H, 1E0H, and 1F0H on the "
"virtual-APIC page.\n"

#: src/architecture/irq/vlapic.md:93
msgid ""
"/// Virtual interrupt-request register (VIRR):\n"
"        /// the 256-bit value comprising eight non-contiguous 32-bit fields "
"at offsets\n"
"        /// 200H, 210H, 220H, 230H, 240H, 250H, 260H, and 270H on the "
"virtual-APIC page.\n"
"        /// Bit x of the VIRR is at bit position (x & 1FH) at offset (200H | "
"((x & E0H) » 1)).\n"
"        /// The processor uses only the low 4 bytes of each of the 16-Byte "
"fields at offsets 200H, 210H, 220H, 230H, 240H, 250H, 260H, and 270H.\n"
msgstr ""
"/// Virtual interrupt-request register (VIRR):\n"
"        /// the 256-bit value comprising eight non-contiguous 32-bit fields "
"at offsets\n"
"        /// 200H, 210H, 220H, 230H, 240H, 250H, 260H, and 270H on the "
"virtual-APIC page.\n"
"        /// Bit x of the VIRR is at bit position (x & 1FH) at offset (200H | "
"((x & E0H) » 1)).\n"
"        /// The processor uses only the low 4 bytes of each of the 16-Byte "
"fields at offsets 200H, 210H, 220H, 230H, 240H, 250H, 260H, and 270H.\n"

#: src/architecture/irq/vlapic.md:99
msgid ""
"/// Virtual error-status register (VESR): the 32-bit field located at offset "
"280H on the virtual-APIC page.\n"
msgstr ""
"/// Virtual error-status register (VESR): the 32-bit field located at offset "
"280H on the virtual-APIC page.\n"

#: src/architecture/irq/vlapic.md:102
msgid "/// Virtual LVT Corrected Machine Check Interrupt (CMCI) Register\n"
msgstr "/// Virtual LVT Corrected Machine Check Interrupt (CMCI) Register\n"

#: src/architecture/irq/vlapic.md:105
msgid ""
"/// Virtual Interrupt Command Register (ICR): the 64-bit field located at "
"offset 300H on the virtual-APIC page.\n"
msgstr ""
"/// Virtual Interrupt Command Register (ICR): the 64-bit field located at "
"offset 300H on the virtual-APIC page.\n"

#: src/architecture/irq/vlapic.md:110
msgid ""
"/// Virtual LVT Timer Register: the 32-bit field located at offset 320H on "
"the virtual-APIC page.\n"
msgstr ""
"/// Virtual LVT Timer Register: the 32-bit field located at offset 320H on "
"the virtual-APIC page.\n"

#: src/architecture/irq/vlapic.md:113
msgid ""
"/// Virtual LVT Thermal Sensor register: the 32-bit field located at offset "
"330H on the virtual-APIC page.\n"
msgstr ""
"/// Virtual LVT Thermal Sensor register: the 32-bit field located at offset "
"330H on the virtual-APIC page.\n"

#: src/architecture/irq/vlapic.md:116
msgid ""
"/// Virtual LVT Performance Monitoring Counters register: the 32-bit field "
"located at offset 340H on the virtual-APIC page.\n"
msgstr ""
"/// Virtual LVT Performance Monitoring Counters register: the 32-bit field "
"located at offset 340H on the virtual-APIC page.\n"

#: src/architecture/irq/vlapic.md:119
msgid ""
"/// Virtual LVT LINT0 register: the 32-bit field located at offset 350H on "
"the virtual-APIC page.\n"
msgstr ""
"/// Virtual LVT LINT0 register: the 32-bit field located at offset 350H on "
"the virtual-APIC page.\n"

#: src/architecture/irq/vlapic.md:122
msgid ""
"/// Virtual LVT LINT1 register: the 32-bit field located at offset 360H on "
"the virtual-APIC page.\n"
msgstr ""
"/// Virtual LVT LINT1 register: the 32-bit field located at offset 360H on "
"the virtual-APIC page.\n"

#: src/architecture/irq/vlapic.md:125
msgid ""
"/// Virtual LVT Error register: the 32-bit field located at offset 370H on "
"the virtual-APIC page.\n"
msgstr ""
"/// Virtual LVT Error register: the 32-bit field located at offset 370H on "
"the virtual-APIC page.\n"

#: src/architecture/irq/vlapic.md:128
msgid ""
"/// Virtual Initial Count Register (for Timer): the 32-bit field located at "
"offset 380H on the virtual-APIC page.\n"
msgstr ""
"/// Virtual Initial Count Register (for Timer): the 32-bit field located at "
"offset 380H on the virtual-APIC page.\n"

#: src/architecture/irq/vlapic.md:131
msgid ""
"/// Virtual Current Count Register (for Timer): the 32-bit field located at "
"offset 390H on the virtual-APIC page.\n"
msgstr ""
"/// Virtual Current Count Register (for Timer): the 32-bit field located at "
"offset 390H on the virtual-APIC page.\n"

#: src/architecture/irq/vlapic.md:134
msgid ""
"/// Virtual Divide Configuration Register (for Timer): the 32-bit field "
"located at offset 3E0H on the virtual-APIC page.\n"
msgstr ""
"/// Virtual Divide Configuration Register (for Timer): the 32-bit field "
"located at offset 3E0H on the virtual-APIC page.\n"

#: src/architecture/irq/vlapic.md:137
msgid ""
"/// Virtual SELF IPI Register: the 32-bit field located at offset 3F0H on "
"the virtual-APIC page.\n"
msgstr ""
"/// Virtual SELF IPI Register: the 32-bit field located at offset 3F0H on "
"the virtual-APIC page.\n"

#: src/architecture/irq/vlapic.md:145
msgid "EOI 寄存器"
msgstr "EOI 寄存器"

#: src/architecture/irq/vlapic.md:147
msgid ""
"使用值0向偏移量为0xB0的寄存器写入，以信号通知中断结束。使用非零值可能会导致通"
"用保护故障。"
msgstr ""
"使用值0向偏移量为0xB0的寄存器写入，以信号通知中断结束。使用非零值可能会导致通"
"用保护故障。"

#: src/architecture/irq/vlapic.md:149
msgid "Local Vector Table 寄存器"
msgstr "Local Vector Table 寄存器"

#: src/architecture/irq/vlapic.md:151
msgid ""
"处理器和LAPIC自身可以生成一些特殊的中断。虽然外部中断是在I/O APIC中配置的，但"
"这些中断必须使用LAPIC中的寄存器进行配置。最有趣的寄存器包括：0x320 = LAPIC定"
"时器，0x350 = LINT0，0x360 = LINT1。更多详情请参见 `Intel SDM vol 3`。"
msgstr ""
"处理器和LAPIC自身可以生成一些特殊的中断。虽然外部中断是在I/O APIC中配置的，但"
"这些中断必须使用LAPIC中的寄存器进行配置。最有趣的寄存器包括：0x320 = LAPIC定"
"时器，0x350 = LINT0，0x360 = LINT1。更多详情请参见 `Intel SDM vol 3`。"

#: src/architecture/irq/vlapic.md:153
msgid "寄存器格式："
msgstr "寄存器格式："

#: src/architecture/irq/vlapic.md:155 src/architecture/irq/vlapic.md:175
msgid "位范围"
msgstr "位范围"

#: src/architecture/irq/vlapic.md:155 src/architecture/irq/vlapic.md:175
msgid "描述"
msgstr "描述"

#: src/architecture/irq/vlapic.md:157 src/architecture/irq/vlapic.md:177
msgid "0-7"
msgstr "0-7"

#: src/architecture/irq/vlapic.md:157
msgid "向量编号"
msgstr "向量编号"

#: src/architecture/irq/vlapic.md:158
msgid "8-10（定时器保留）"
msgstr "8-10（定时器保留）"

#: src/architecture/irq/vlapic.md:158
msgid "如果是NMI则为100b"
msgstr "如果是NMI则为100b"

#: src/architecture/irq/vlapic.md:159 src/architecture/irq/vlapic.md:179
msgid "11"
msgstr "11"

#: src/architecture/irq/vlapic.md:159 src/architecture/irq/vlapic.md:165
#: src/architecture/irq/vlapic.md:181 src/architecture/irq/vlapic.md:185
msgid "保留"
msgstr "保留"

#: src/architecture/irq/vlapic.md:160 src/architecture/irq/vlapic.md:180
msgid "12"
msgstr "12"

#: src/architecture/irq/vlapic.md:160
msgid "如果中断挂起则设置"
msgstr "如果中断挂起则设置"

#: src/architecture/irq/vlapic.md:161
msgid "13（定时器保留）"
msgstr "13（定时器保留）"

#: src/architecture/irq/vlapic.md:161
msgid "极性，设置为低电平触发"
msgstr "极性，设置为低电平触发"

#: src/architecture/irq/vlapic.md:162
msgid "14（定时器保留）"
msgstr "14（定时器保留）"

#: src/architecture/irq/vlapic.md:162
msgid "远程IRR"
msgstr "远程IRR"

#: src/architecture/irq/vlapic.md:163
msgid "15（定时器保留）"
msgstr "15（定时器保留）"

#: src/architecture/irq/vlapic.md:163
msgid "触发模式，设置为电平触发"
msgstr "触发模式，设置为电平触发"

#: src/architecture/irq/vlapic.md:164
msgid "16"
msgstr "16"

#: src/architecture/irq/vlapic.md:164
msgid "设置以屏蔽"
msgstr "设置以屏蔽"

#: src/architecture/irq/vlapic.md:165
msgid "17-31"
msgstr "17-31"

#: src/architecture/irq/vlapic.md:167
msgid "Spurious Interrupt Vector 寄存器"
msgstr "Spurious Interrupt Vector 寄存器"

#: src/architecture/irq/vlapic.md:169
msgid ""
"偏移量是0xF0。低字节包含伪中断的编号。如上所述，您应该将此设置为0xFF。要启用"
"APIC，请设置此寄存器的第8位（或0x100）。如果设置了第12位，则EOI消息不会被广"
"播。其余的所有位目前都是保留的。"
msgstr ""
"偏移量是0xF0。低字节包含伪中断的编号。如上所述，您应该将此设置为0xFF。要启用"
"APIC，请设置此寄存器的第8位（或0x100）。如果设置了第12位，则EOI消息不会被广"
"播。其余的所有位目前都是保留的。"

#: src/architecture/irq/vlapic.md:171
msgid "Interrupt Command 寄存器 (ICR)"
msgstr "Interrupt Command 寄存器 (ICR)"

#: src/architecture/irq/vlapic.md:173
msgid ""
"中断命令寄存器由两个32位寄存器组成；一个位于0x300，另一个位于0x310。它用于向"
"不同的处理器发送中断。中断是在0x300被写入时发出的，而不是在0x310被写入时发出"
"的。因此，要发送中断命令，应该首先写入0x310，然后写入0x300。在0x310处有一个位"
"于位24-27的字段，它是目标处理器的本地APIC ID（针对物理目的地模式）。这里是"
"0x300的结构："
msgstr ""
"中断命令寄存器由两个32位寄存器组成；一个位于0x300，另一个位于0x310。它用于向"
"不同的处理器发送中断。中断是在0x300被写入时发出的，而不是在0x310被写入时发出"
"的。因此，要发送中断命令，应该首先写入0x310，然后写入0x300。在0x310处有一个位"
"于位24-27的字段，它是目标处理器的本地APIC ID（针对物理目的地模式）。这里是"
"0x300的结构："

#: src/architecture/irq/vlapic.md:177
msgid "向量编号，或SIPI的起始页号"
msgstr "向量编号，或SIPI的起始页号"

#: src/architecture/irq/vlapic.md:178
msgid "8-10"
msgstr "8-10"

#: src/architecture/irq/vlapic.md:178
msgid ""
"交付模式。0表示正常，1表示最低优先级，2表示SMI，4表示NMI，5可以是INIT或INIT级"
"别解除，6表示SIPI"
msgstr ""
"交付模式。0表示正常，1表示最低优先级，2表示SMI，4表示NMI，5可以是INIT或INIT级"
"别解除，6表示SIPI"

#: src/architecture/irq/vlapic.md:179
msgid ""
"目的地模式。清除表示物理目的地，或者设置表示逻辑目的地。如果该位被清除，则"
"0x310中的目的地字段被视为正常处理"
msgstr ""
"目的地模式。清除表示物理目的地，或者设置表示逻辑目的地。如果该位被清除，则"
"0x310中的目的地字段被视为正常处理"

#: src/architecture/irq/vlapic.md:180
msgid "交付状态。当中断被目标接受时清除。通常应在发送中断后等待此位清除"
msgstr "交付状态。当中断被目标接受时清除。通常应在发送中断后等待此位清除"

#: src/architecture/irq/vlapic.md:181
msgid "13"
msgstr "13"

#: src/architecture/irq/vlapic.md:182
msgid "14"
msgstr "14"

#: src/architecture/irq/vlapic.md:182
msgid "清除表示INIT级别解除，否则设置"
msgstr "清除表示INIT级别解除，否则设置"

#: src/architecture/irq/vlapic.md:183
msgid "15"
msgstr "15"

#: src/architecture/irq/vlapic.md:183
msgid "设置表示INIT级别解除，否则清除"
msgstr "设置表示INIT级别解除，否则清除"

#: src/architecture/irq/vlapic.md:184
msgid "18-19"
msgstr "18-19"

#: src/architecture/irq/vlapic.md:184
msgid ""
"目的地类型。如果>0，则忽略0x310中的目的地字段。1总是发送中断给自己，2发送给所"
"有处理器，3发送给除当前处理器外的所有处理器。最好避免使用模式1、2和3，并坚持"
"使用0"
msgstr ""
"目的地类型。如果>0，则忽略0x310中的目的地字段。1总是发送中断给自己，2发送给所"
"有处理器，3发送给除当前处理器外的所有处理器。最好避免使用模式1、2和3，并坚持"
"使用0"

#: src/architecture/irq/vlapic.md:185
msgid "20-31"
msgstr "20-31"

#: src/architecture/device/passthrough_device.md:1
msgid "设备直通（Device Passthrough）"
msgstr "设备直通（Device Passthrough）"

#: src/architecture/device/passthrough_device.md:3
msgid ""
"设备直通是一种高级虚拟化技术，允许虚拟机（VM）直接访问和控制物理硬件设备。它"
"本质上是一种特殊的设备模拟方式，其特点是将物理设备完全隔离并独占分配给特定虚"
"拟机使用。这种技术绕过了虚拟化层的常规设备模拟过程，提供了接近原生硬件的性能"
"表现。"
msgstr ""
"设备直通是一种高级虚拟化技术，允许虚拟机（VM）直接访问和控制物理硬件设备。它"
"本质上是一种特殊的设备模拟方式，其特点是将物理设备完全隔离并独占分配给特定虚"
"拟机使用。这种技术绕过了虚拟化层的常规设备模拟过程，提供了接近原生硬件的性能"
"表现。"

#: src/architecture/device/passthrough_device.md:5
msgid "核心优势"
msgstr "核心优势"

#: src/architecture/device/passthrough_device.md:7
msgid ""
"接近原生性能：直通设备几乎能提供与裸机系统相同的性能表现，尤其适用于I/O密集型"
"设备"
msgstr ""
"接近原生性能：直通设备几乎能提供与裸机系统相同的性能表现，尤其适用于I/O密集型"
"设备"

#: src/architecture/device/passthrough_device.md:8
msgid ""
"低延迟响应：最小化了虚拟化层引入的额外延迟，关键应用场景如高性能计算、实时数"
"据处理等尤为重要"
msgstr ""
"低延迟响应：最小化了虚拟化层引入的额外延迟，关键应用场景如高性能计算、实时数"
"据处理等尤为重要"

#: src/architecture/device/passthrough_device.md:9
msgid "功能完整性：虚拟机可访问设备的全部功能集，不受虚拟化层功能模拟的限制"
msgstr "功能完整性：虚拟机可访问设备的全部功能集，不受虚拟化层功能模拟的限制"

#: src/architecture/device/passthrough_device.md:10
msgid "硬件加速：允许使用特定硬件的加速功能（如GPU计算、网卡卸载等）"
msgstr "硬件加速：允许使用特定硬件的加速功能（如GPU计算、网卡卸载等）"

#: src/architecture/device/passthrough_device.md:12
msgid "技术实现机制"
msgstr "技术实现机制"

#: src/architecture/device/passthrough_device.md:14
msgid "设备直通技术主要依赖于以下关键技术："
msgstr "设备直通技术主要依赖于以下关键技术："

#: src/architecture/device/passthrough_device.md:16
msgid ""
"IOMMU（I/O内存管理单元）：负责虚拟机I/O地址到物理地址的转换，保障安全隔离"
msgstr ""
"IOMMU（I/O内存管理单元）：负责虚拟机I/O地址到物理地址的转换，保障安全隔离"

#: src/architecture/device/passthrough_device.md:17
msgid "中断重映射：将设备中断正确路由到对应的虚拟机"
msgstr "中断重映射：将设备中断正确路由到对应的虚拟机"

#: src/architecture/device/passthrough_device.md:18
msgid "DMA重映射：确保设备的直接内存访问操作被正确限制在虚拟机的内存空间内"
msgstr "DMA重映射：确保设备的直接内存访问操作被正确限制在虚拟机的内存空间内"

#: src/architecture/device/passthrough_device.md:20
msgid "axvisor设备直通配置解析"
msgstr "axvisor设备直通配置解析"

#: src/architecture/device/passthrough_device.md:22
msgid ""
"以下是[Axvisor](https://github.com/arceos-hypervisor/axvisor)在ARM平台上基于"
"QEMU架构实现的设备直通配置示例："
msgstr ""
"以下是[Axvisor](https://github.com/arceos-hypervisor/axvisor)在ARM平台上基于"
"QEMU架构实现的设备直通配置示例："

#: src/architecture/device/passthrough_device.md:24
msgid ""
"```\n"
"Pass-through devices.\n"
"# Name Base-Ipa Base-Pa Length Alloc-Irq.\n"
"passthrough_devices = [\n"
"    [\"intc@8000000\", 0x800_0000, 0x800_0000, 0x50_000, 0x1],\n"
"    [\"pl011@9000000\", 0x900_0000, 0x904_0000, 0x1000, 0x1],\n"
"    [\"pl031@9010000\", 0x901_0000, 0x901_0000, 0x1000, 0x1],\n"
"    [\"pl061@9030000\", 0x903_0000, 0x903_0000, 0x1000, 0x1],\n"
"    [\"virtio_mmio\", 0xa00_0000, 0xa00_0000, 0x4000, 0x1],\n"
"]\n"
"```"
msgstr ""
"```\n"
"Pass-through devices.\n"
"# Name Base-Ipa Base-Pa Length Alloc-Irq.\n"
"passthrough_devices = [\n"
"    [\"intc@8000000\", 0x800_0000, 0x800_0000, 0x50_000, 0x1],\n"
"    [\"pl011@9000000\", 0x900_0000, 0x904_0000, 0x1000, 0x1],\n"
"    [\"pl031@9010000\", 0x901_0000, 0x901_0000, 0x1000, 0x1],\n"
"    [\"pl061@9030000\", 0x903_0000, 0x903_0000, 0x1000, 0x1],\n"
"    [\"virtio_mmio\", 0xa00_0000, 0xa00_0000, 0x4000, 0x1],\n"
"]\n"
"```"

#: src/architecture/device/passthrough_device.md:36
msgid "**配置参数详解**"
msgstr "**配置参数详解**"

#: src/architecture/device/passthrough_device.md:38
msgid "每个设备条目包含5个关键参数："
msgstr "每个设备条目包含5个关键参数："

#: src/architecture/device/passthrough_device.md:40
msgid "设备标识符（Name）：唯一标识直通设备，通常包含设备类型和基址信息"
msgstr "设备标识符（Name）：唯一标识直通设备，通常包含设备类型和基址信息"

#: src/architecture/device/passthrough_device.md:41
msgid ""
"中间物理地址（Base-Ipa）：虚拟机内部看到的设备基址，用于VM内部的内存映射"
msgstr ""
"中间物理地址（Base-Ipa）：虚拟机内部看到的设备基址，用于VM内部的内存映射"

#: src/architecture/device/passthrough_device.md:42
msgid "物理地址（Base-Pa）：设备在宿主机上的实际物理内存地址"
msgstr "物理地址（Base-Pa）：设备在宿主机上的实际物理内存地址"

#: src/architecture/device/passthrough_device.md:43
msgid "映射长度（Length）：设备内存映射区域的大小，以字节为单位"
msgstr "映射长度（Length）：设备内存映射区域的大小，以字节为单位"

#: src/architecture/device/passthrough_device.md:44
msgid ""
"中断分配标志（Alloc-Irq）：控制是否为该设备分配中断资源（1=启用，0=禁用）"
msgstr ""
"中断分配标志（Alloc-Irq）：控制是否为该设备分配中断资源（1=启用，0=禁用）"

#: src/architecture/device/passthrough_device.md:46
msgid "**示例中的直通设备详情**"
msgstr "**示例中的直通设备详情**"

#: src/architecture/device/passthrough_device.md:47
msgid "设备名称"
msgstr "设备名称"

#: src/architecture/device/passthrough_device.md:47
msgid "技术特点"
msgstr "技术特点"

#: src/architecture/device/passthrough_device.md:49
msgid "`intc@8000000`"
msgstr "`intc@8000000`"

#: src/architecture/device/passthrough_device.md:49
msgid "中断控制器"
msgstr "中断控制器"

#: src/architecture/device/passthrough_device.md:49
msgid "管理系统中断，允许VM直接处理硬件中断事件"
msgstr "管理系统中断，允许VM直接处理硬件中断事件"

#: src/architecture/device/passthrough_device.md:50
msgid "`pl011@9000000`"
msgstr "`pl011@9000000`"

#: src/architecture/device/passthrough_device.md:50
msgid "PL011 UART串口控制器"
msgstr "PL011 UART串口控制器"

#: src/architecture/device/passthrough_device.md:50
msgid "提供串行通信能力，常用于调试和控制台访问"
msgstr "提供串行通信能力，常用于调试和控制台访问"

#: src/architecture/device/passthrough_device.md:51
msgid "`pl031@9010000`"
msgstr "`pl031@9010000`"

#: src/architecture/device/passthrough_device.md:51
msgid "PL031实时时钟(RTC)"
msgstr "PL031实时时钟(RTC)"

#: src/architecture/device/passthrough_device.md:51
msgid "提供精确的时间功能，确保VM时间准确性"
msgstr "提供精确的时间功能，确保VM时间准确性"

#: src/architecture/device/passthrough_device.md:52
msgid "`pl061@9030000`"
msgstr "`pl061@9030000`"

#: src/architecture/device/passthrough_device.md:52
msgid "PL061 GPIO控制器"
msgstr "PL061 GPIO控制器"

#: src/architecture/device/passthrough_device.md:52
msgid "管理通用输入/输出接口，用于控制外部设备"
msgstr "管理通用输入/输出接口，用于控制外部设备"

#: src/architecture/device/passthrough_device.md:53
msgid "`virtio_mmio`"
msgstr "`virtio_mmio`"

#: src/architecture/device/passthrough_device.md:53
msgid "VirtIO内存映射I/O设备"
msgstr "VirtIO内存映射I/O设备"

#: src/architecture/device/passthrough_device.md:53
msgid "提供高效的半虚拟化I/O接口，平衡性能与兼容性"
msgstr "提供高效的半虚拟化I/O接口，平衡性能与兼容性"

#: src/architecture/device/passthrough_device.md:55
msgid ""
"设备直通是构建高性能虚拟化环境的关键组件，可以实现在保持虚拟化灵活性的同时，"
"提供接近于物理机的性能。<style> .scroll-to-top { font-size: 2.5rem; width: "
"3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: "
"center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem "
"+ 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; "
"color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-"
"top.hidden { display: none; } .scroll-to-top i { transform: "
"translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: "
"flex; } } </style> <button type=\"button\" aria-label=\"scroll-to-top\" "
"class=\"scroll-to-top hidden\" onclick=\"scrollToTop()\"> <i class=\"fa fa-"
"angle-up\"></i> </button>"
msgstr ""
"设备直通是构建高性能虚拟化环境的关键组件，可以实现在保持虚拟化灵活性的同时，"
"提供接近于物理机的性能。<style> .scroll-to-top { font-size: 2.5rem; width: "
"3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: "
"center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem "
"+ 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; "
"color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-"
"top.hidden { display: none; } .scroll-to-top i { transform: "
"translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: "
"flex; } } </style> <button type=\"button\" aria-label=\"scroll-to-top\" "
"class=\"scroll-to-top hidden\" onclick=\"scrollToTop()\"> <i class=\"fa fa-"
"angle-up\"></i> </button>"

#: src/architecture/device/device.md:1
msgid ""
"[axdevice](https://github.com/arceos-hypervisor/axdevice) 是 ArceOS 的一个模"
"块，提供设备仿真支持"
msgstr ""
"[axdevice](https://github.com/arceos-hypervisor/axdevice) 是 ArceOS 的一个模"
"块，提供设备仿真支持"

#: src/architecture/device/device.md:2
msgid "部分架构独立"
msgstr "部分架构独立"

#: src/architecture/device/device.md:3
msgid "不同的仿真设备实现需要被分离到独立的 crate 中"
msgstr "不同的仿真设备实现需要被分离到独立的 crate 中"

#: src/architecture/device/device.md:4
msgid "[x86_vlapic](https://github.com/arceos-hypervisor/x86_vlapic)"
msgstr "[x86_vlapic](https://github.com/arceos-hypervisor/x86_vlapic)"

#: src/architecture/device/device.md:5
msgid "[arm_vgic](https://github.com/arceos-hypervisor/arm_vgic) (v2,v3,v4)"
msgstr "[arm_vgic](https://github.com/arceos-hypervisor/arm_vgic) (v2,v3,v4)"

#: src/architecture/device/device.md:6
msgid "riscv_vplic"
msgstr "riscv_vplic"

#: src/architecture/device/device.md:7
msgid "virtio-blk"
msgstr "virtio-blk"

#: src/architecture/device/device.md:8
msgid "virtio-net"
msgstr "virtio-net"

#: src/architecture/device/pci.md:1
msgid "PCI"
msgstr "PCI"

#: src/architecture/device/pci.md:3
msgid ""
"PCI（外设组件互连）是一种广泛使用的设备总线标准，用于连接计算机的外设（如网"
"卡、显卡等）与系统通信。CPU可以通过load/store指令来访问PCI设备，PCI设备有如下"
"三种不同内存："
msgstr ""
"PCI（外设组件互连）是一种广泛使用的设备总线标准，用于连接计算机的外设（如网"
"卡、显卡等）与系统通信。CPU可以通过load/store指令来访问PCI设备，PCI设备有如下"
"三种不同内存："

#: src/architecture/device/pci.md:5
msgid "MMIO"
msgstr "MMIO"

#: src/architecture/device/pci.md:6
msgid "PCI IO space"
msgstr "PCI IO space"

#: src/architecture/device/pci.md:7
msgid "PCI configuration space"
msgstr "PCI configuration space"

#: src/architecture/device/pci.md:9
msgid ""
"配置一个PCI设备通常需要对其BAR（Base Address Register）进行配置并启用设备，遍"
"历每个BAR，检查BAR的内存类型并分配地址，`root.bar_info(bdf, bar)`调用返回一个"
"关于指定设备和BAR的详细信息。从分配器申请地址，根据BAR类型（32位或64位）调用"
"`set_bar_32` 或 `set_bar_64`。"
msgstr ""
"配置一个PCI设备通常需要对其BAR（Base Address Register）进行配置并启用设备，遍"
"历每个BAR，检查BAR的内存类型并分配地址，`root.bar_info(bdf, bar)`调用返回一个"
"关于指定设备和BAR的详细信息。从分配器申请地址，根据BAR类型（32位或64位）调用"
"`set_bar_32` 或 `set_bar_64`。"

#: src/architecture/device/pci.md:12
msgid "// 获取BAR元数据\n"
msgstr "// 获取BAR元数据\n"

#: src/architecture/device/pci.md:14
msgid "// 需要分配的未初始化BAR\n"
msgstr "// 需要分配的未初始化BAR\n"

#: src/architecture/device/pci.md:17
msgid "\"No memory ranges available for PCI BARs!\""
msgstr "\"No memory ranges available for PCI BARs!\""

#: src/architecture/device/pci.md:30
msgid ""
"检查当前BAR是否占用两个条目，若当前BAR是64位类型，则需递增`bar`两次，跳过下一"
"个索引。"
msgstr ""
"检查当前BAR是否占用两个条目，若当前BAR是64位类型，则需递增`bar`两次，跳过下一"
"个索引。"

#: src/architecture/device/pci.md:39
msgid "启用设备的IO/内存访问及总线主控"
msgstr "启用设备的IO/内存访问及总线主控"

#: src/architecture/device/pci.md:49
msgid "**命令寄存器设置**："
msgstr "**命令寄存器设置**："

#: src/architecture/device/pci.md:51
msgid "**IO_SPACE**: 允许设备响应IO端口访问。"
msgstr "**IO_SPACE**: 允许设备响应IO端口访问。"

#: src/architecture/device/pci.md:52
msgid "**MEMORY_SPACE**: 允许设备响应内存映射访问。"
msgstr "**MEMORY_SPACE**: 允许设备响应内存映射访问。"

#: src/architecture/device/pci.md:53
msgid "**BUS_MASTER**: 启用设备作为总线主设备。"
msgstr "**BUS_MASTER**: 启用设备作为总线主设备。"

#: src/architecture/device/pci.md:55
msgid "Emulated PCI"
msgstr "Emulated PCI"

#: src/architecture/device/pci.md:57
msgid "设备的虚拟化是通过模拟（Emulation）和直通（Passthrough）技术来实现的。"
msgstr "设备的虚拟化是通过模拟（Emulation）和直通（Passthrough）技术来实现的。"

#: src/architecture/device/pci.md:59
msgid ""
"Emulated PCI正是通过软件模拟PCI设备实现的，这些虚拟设备与真实的硬件PCI设备类"
"似，但并非直接依赖Hardware Devices的支持，而是通过Hypervisor层来模拟和管理，"
"用于在虚拟化环境中为VM提供对物理PCI设备的访问能力。"
msgstr ""
"Emulated PCI正是通过软件模拟PCI设备实现的，这些虚拟设备与真实的硬件PCI设备类"
"似，但并非直接依赖Hardware Devices的支持，而是通过Hypervisor层来模拟和管理，"
"用于在虚拟化环境中为VM提供对物理PCI设备的访问能力。"

#: src/architecture/device/pci.md:61
msgid "![](../../assets/vpci.png)"
msgstr "![](../../assets/vpci.png)"

#: src/architecture/device/pci.md:63
msgid "**Guest VM层**"
msgstr "**Guest VM层**"

#: src/architecture/device/pci.md:65
msgid ""
"虚拟PCI设备驱动，Guest VM认为存在真实PCI设备，通过标准PCI驱动发起I/O请求。"
msgstr ""
"虚拟PCI设备驱动，Guest VM认为存在真实PCI设备，通过标准PCI驱动发起I/O请求。"

#: src/architecture/device/pci.md:67
msgid "Hypervisor层"
msgstr "Hypervisor层"

#: src/architecture/device/pci.md:69
msgid "**虚拟PCI总线（Virtual PCI Bus）**"
msgstr "**虚拟PCI总线（Virtual PCI Bus）**"

#: src/architecture/device/pci.md:70
msgid "模拟PCI总线拓扑结构，管理虚拟设备的配置空间。"
msgstr "模拟PCI总线拓扑结构，管理虚拟设备的配置空间。"

#: src/architecture/device/pci.md:71
msgid "实现PCI枚举过程，向Guest OS暴露虚拟设备列表。"
msgstr "实现PCI枚举过程，向Guest OS暴露虚拟设备列表。"

#: src/architecture/device/pci.md:72
msgid "**PCI设备模型（Device Model）**"
msgstr "**PCI设备模型（Device Model）**"

#: src/architecture/device/pci.md:73
msgid "**寄存器模拟**：对设备寄存器的读写操作进行拦截和模拟。"
msgstr "**寄存器模拟**：对设备寄存器的读写操作进行拦截和模拟。"

#: src/architecture/device/pci.md:74
msgid "**DMA模拟**：通过虚拟地址转换（GPA→HPA）处理Guest发起的DMA操作。"
msgstr "**DMA模拟**：通过虚拟地址转换（GPA→HPA）处理Guest发起的DMA操作。"

#: src/architecture/device/pci.md:75
msgid "**中断模拟**：将虚拟设备中断映射为虚拟中断。"
msgstr "**中断模拟**：将虚拟设备中断映射为虚拟中断。"

#: src/architecture/device/pci.md:77
msgid "Host OS & Hardware层"
msgstr "Host OS & Hardware层"

#: src/architecture/device/pci.md:79
msgid "物理资源交互，对于纯软件模拟设备，由Host用户态程序处理I/O请求。"
msgstr "物理资源交互，对于纯软件模拟设备，由Host用户态程序处理I/O请求。"

#: src/architecture/device/pci.md:81
msgid "核心机制"
msgstr "核心机制"

#: src/architecture/device/pci.md:83
msgid "**配置空间模拟**"
msgstr "**配置空间模拟**"

#: src/architecture/device/pci.md:85
msgid ""
"PCI设备通过配置空间定义其资源需求（如I/O端口、内存映射地址等），虚拟化时，"
"Axvisor模拟PCI总线的拓扑关系和设备的配置空间，例如，虚拟设备的BAR（基址寄存"
"器） 由Axvisor动态分配，客户机操作系统通过写入BAR来请求资源，Axvisor则映射到"
"宿主机物理地址或虚拟资源。"
msgstr ""
"PCI设备通过配置空间定义其资源需求（如I/O端口、内存映射地址等），虚拟化时，"
"Axvisor模拟PCI总线的拓扑关系和设备的配置空间，例如，虚拟设备的BAR（基址寄存"
"器） 由Axvisor动态分配，客户机操作系统通过写入BAR来请求资源，Axvisor则映射到"
"宿主机物理地址或虚拟资源。"

#: src/architecture/device/pci.md:87
msgid "**设备发现与枚举**"
msgstr "**设备发现与枚举**"

#: src/architecture/device/pci.md:89
msgid ""
"GuestOS启动时，会像物理机一样枚举PCI总线以发现设备。Axvisor模拟BIOS/UEFI固件"
"的行为，向GuestOS呈现虚拟PCI总线及挂接的设备。"
msgstr ""
"GuestOS启动时，会像物理机一样枚举PCI总线以发现设备。Axvisor模拟BIOS/UEFI固件"
"的行为，向GuestOS呈现虚拟PCI总线及挂接的设备。"

#: src/architecture/device/pci.md:91
msgid "**I/O访问与中断处理**"
msgstr "**I/O访问与中断处理**"

#: src/architecture/device/pci.md:93
msgid ""
"GuestOS对虚拟设备的I/O端口（PMIO）或内存映射（MMIO）访问会被VMM截获。中断则通"
"过虚拟APIC或注入虚拟中断信号通知GuestOS。<style> .scroll-to-top { font-size: "
"2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; "
"justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; "
"right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: "
"pointer; border: none; color: var(--bg); background: var(--fg); border-"
"radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i "
"{ transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top "
"{ display: flex; } } </style> <button type=\"button\" aria-label=\"scroll-to-"
"top\" class=\"scroll-to-top hidden\" onclick=\"scrollToTop()\"> <i "
"class=\"fa fa-angle-up\"></i> </button>"
msgstr ""
"GuestOS对虚拟设备的I/O端口（PMIO）或内存映射（MMIO）访问会被VMM截获。中断则通"
"过虚拟APIC或注入虚拟中断信号通知GuestOS。<style> .scroll-to-top { font-size: "
"2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; "
"justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; "
"right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: "
"pointer; border: none; color: var(--bg); background: var(--fg); border-"
"radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i "
"{ transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top "
"{ display: flex; } } </style> <button type=\"button\" aria-label=\"scroll-to-"
"top\" class=\"scroll-to-top hidden\" onclick=\"scrollToTop()\"> <i "
"class=\"fa fa-angle-up\"></i> </button>"

#: src/architecture/device/virtio.md:1
msgid "Virtio-Device"
msgstr "Virtio-Device"

#: src/architecture/device/virtio.md:3
msgid "![](../../assets/io.png)"
msgstr "![](../../assets/io.png)"

#: src/architecture/device/virtio.md:5
msgid "virtio设备的基本组成结构"
msgstr "virtio设备的基本组成结构"

#: src/architecture/device/virtio.md:6
msgid ""
"virtio设备代表了一类I/O通用设备，为了让设备驱动能够管理和使用设备。在程序员的"
"眼里，I/O设备基本组成结构包括如下恩利："
msgstr ""
"virtio设备代表了一类I/O通用设备，为了让设备驱动能够管理和使用设备。在程序员的"
"眼里，I/O设备基本组成结构包括如下恩利："

#: src/architecture/device/virtio.md:7
msgid ""
"呈现模式：设备一般通过寄存器、内存或特定I/O指令等方式让设备驱动能看到和访问到"
"设备；"
msgstr ""
"呈现模式：设备一般通过寄存器、内存或特定I/O指令等方式让设备驱动能看到和访问到"
"设备；"

#: src/architecture/device/virtio.md:8
msgid ""
"特征描述：让设备驱动能够了解设备的静态特性（可通过软件修改），从而决定是否或"
"如何使用该设备；"
msgstr ""
"特征描述：让设备驱动能够了解设备的静态特性（可通过软件修改），从而决定是否或"
"如何使用该设备；"

#: src/architecture/device/virtio.md:9
msgid ""
"状态表示：让设备驱动能够了解设备的当前动态状态，从而确定如何进行设备管理或I/O"
"数据传输；"
msgstr ""
"状态表示：让设备驱动能够了解设备的当前动态状态，从而确定如何进行设备管理或I/O"
"数据传输；"

#: src/architecture/device/virtio.md:10
msgid ""
"交互机制：交互包括事件通知和数据传输；对于事件通知，让设备驱动及时获知设备的"
"状态变化的机制（可基于中断等机制），以及让设备及时获得设备驱动发出的I/O请求"
"（可基于寄存器读写等机制）；对于数据传输，让设备驱动能处理设备给出的数据，以"
"及让设备能处理设备驱动给出的数据，如（可基于DMA或virtqueue等机制）。 virtio设"
"备具体定义了设备驱动和设备之间的接口，包括设备呈现模式、设备状态域、特征位、"
"通知、设备配置空间、虚拟队列等，覆盖了上述的基本接口描述。"
msgstr ""
"交互机制：交互包括事件通知和数据传输；对于事件通知，让设备驱动及时获知设备的"
"状态变化的机制（可基于中断等机制），以及让设备及时获得设备驱动发出的I/O请求"
"（可基于寄存器读写等机制）；对于数据传输，让设备驱动能处理设备给出的数据，以"
"及让设备能处理设备驱动给出的数据，如（可基于DMA或virtqueue等机制）。 virtio设"
"备具体定义了设备驱动和设备之间的接口，包括设备呈现模式、设备状态域、特征位、"
"通知、设备配置空间、虚拟队列等，覆盖了上述的基本接口描述。"

#: src/architecture/device/virtio.md:12
msgid "virtio设备的基本组成要素"
msgstr "virtio设备的基本组成要素"

#: src/architecture/device/virtio.md:13 src/architecture/device/virtio.md:21
msgid "virtio设备的基本组成要素如下："
msgstr "virtio设备的基本组成要素如下："

#: src/architecture/device/virtio.md:14 src/architecture/device/virtio.md:22
msgid "设备状态域（Device status field）"
msgstr "设备状态域（Device status field）"

#: src/architecture/device/virtio.md:15 src/architecture/device/virtio.md:23
msgid "特征位（Feature bits）"
msgstr "特征位（Feature bits）"

#: src/architecture/device/virtio.md:16 src/architecture/device/virtio.md:24
msgid "通知（Notifications）"
msgstr "通知（Notifications）"

#: src/architecture/device/virtio.md:17 src/architecture/device/virtio.md:25
msgid "设备配置空间（Device Configuration space）"
msgstr "设备配置空间（Device Configuration space）"

#: src/architecture/device/virtio.md:18 src/architecture/device/virtio.md:26
msgid ""
"一个或多个虚拟队列（virtqueue） 其中的设备特征位和设备配置空间属于virtio设备"
"的特征描述；设备状态域属于virtio设备初始化时的状态表示；通知和虚拟队列属于"
"virtio设备的交互机制，也包含virtio设备运行时的状态表示。"
msgstr ""
"一个或多个虚拟队列（virtqueue） 其中的设备特征位和设备配置空间属于virtio设备"
"的特征描述；设备状态域属于virtio设备初始化时的状态表示；通知和虚拟队列属于"
"virtio设备的交互机制，也包含virtio设备运行时的状态表示。"

#: src/architecture/device/virtio.md:20
msgid "virtio设备的呈现模式"
msgstr "virtio设备的呈现模式"

#: src/architecture/device/virtio.md:28
msgid "virtio设备的特征描述"
msgstr "virtio设备的特征描述"

#: src/architecture/device/virtio.md:29
msgid ""
"virtio设备特征描述包括设备特征位和设备配置空间。  \n"
"**特征位**  \n"
"特征位用于表示VirtIO设备具有的各种特性和功能。其中bit0 – 23是特定设备可以使用"
"的feature bits， bit24 – 37预给队列和feature协商机制，bit38以上保留给未来其他"
"用途。驱动程序与设备对设备特性进行协商，形成一致的共识，这样才能正确的管理设"
"备。  \n"
"**设备配置空间**  \n"
"设备配置空间通常用于配置不常变动的设备参数（属性），或者初始化阶段需要设置的"
"设备参数。设备的特征位中包含表示配置空间是否存在的bit位，并可通过在特征位的末"
"尾添加新的bit位来扩展配置空间。 设备驱动程序在初始化virtio设备时，需要根据"
"virtio设备的特征位和配置空间来了解设备的特征，并对设备进行初始化。"
msgstr ""
"virtio设备特征描述包括设备特征位和设备配置空间。  \n"
"**特征位**  \n"
"特征位用于表示VirtIO设备具有的各种特性和功能。其中bit0 – 23是特定设备可以使用"
"的feature bits， bit24 – 37预给队列和feature协商机制，bit38以上保留给未来其他"
"用途。驱动程序与设备对设备特性进行协商，形成一致的共识，这样才能正确的管理设"
"备。  \n"
"**设备配置空间**  \n"
"设备配置空间通常用于配置不常变动的设备参数（属性），或者初始化阶段需要设置的"
"设备参数。设备的特征位中包含表示配置空间是否存在的bit位，并可通过在特征位的末"
"尾添加新的bit位来扩展配置空间。 设备驱动程序在初始化virtio设备时，需要根据"
"virtio设备的特征位和配置空间来了解设备的特征，并对设备进行初始化。"

#: src/architecture/device/virtio.md:35
msgid "virtio设备状态表示"
msgstr "virtio设备状态表示"

#: src/architecture/device/virtio.md:36
msgid ""
"virtio设备状态表示包括在设备初始化过程中用到的设备状态域，以及在设备进行I/O传"
"输过程中用到的I/O数据访问状态信息和I/O完成情况等。  \n"
"**设备状态域** 设备状态域包含对设备初始化过程中virtio设备的6种状态："
msgstr ""
"virtio设备状态表示包括在设备初始化过程中用到的设备状态域，以及在设备进行I/O传"
"输过程中用到的I/O数据访问状态信息和I/O完成情况等。  \n"
"**设备状态域** 设备状态域包含对设备初始化过程中virtio设备的6种状态："

#: src/architecture/device/virtio.md:39
msgid ""
"ACKNOWLEDGE（1）：驱动程序发现了这个设备，并且认为这是一个有效的virtio设备；"
msgstr ""
"ACKNOWLEDGE（1）：驱动程序发现了这个设备，并且认为这是一个有效的virtio设备；"

#: src/architecture/device/virtio.md:40
msgid "DRIVER (2) : 驱动程序知道该如何驱动这个设备；"
msgstr "DRIVER (2) : 驱动程序知道该如何驱动这个设备；"

#: src/architecture/device/virtio.md:41
msgid "FAILED (128) : 由于某种错误原因，驱动程序无法正常驱动这个设备；"
msgstr "FAILED (128) : 由于某种错误原因，驱动程序无法正常驱动这个设备；"

#: src/architecture/device/virtio.md:42
msgid ""
"FEATURES_OK (8) : 驱动程序认识设备的特征，并且与设备就设备特征协商达成一致；"
msgstr ""
"FEATURES_OK (8) : 驱动程序认识设备的特征，并且与设备就设备特征协商达成一致；"

#: src/architecture/device/virtio.md:43
msgid "DRIVER_OK (4) : 驱动程序加载完成，设备可以正常工作了；"
msgstr "DRIVER_OK (4) : 驱动程序加载完成，设备可以正常工作了；"

#: src/architecture/device/virtio.md:44
msgid ""
"DEVICE_NEEDS_RESET (64) ：设备触发了错误，需要重置才能继续工作。 在设备驱动程"
"序对virtio设备初始化的过程中，需要经历一系列的初始化阶段，这些阶段对应着设备"
"状态域的不同状态。  \n"
"**I/O传输状态**  \n"
"设备驱动程序控制virtio设备进行I/O传输过程中，会经历一系列过程和执行状态，包"
"括 I/O请求状态、 I/O处理状态、 I/O完成状态、I/O错误状态、 I/O后续处理状态等。"
"设备驱动程序在执行过程中，需要对上述状态进行不同的处理。 virtio设备进行I/O传"
"输过程中，设备驱动会指出 I/O请求队列的当前位置状态信息，这样设备能查到I/O请求"
"的信息，并根据 I/O请求进行I/O传输；而设备会指出 I/O完成队列的当前位置状态信"
"息，这样设备驱动通过读取 I/O完成数据结构中的状态信息，就知道设备是否完成I/O请"
"求的相应操作，并进行后续事务处理。 比如，virtio_blk设备驱动发出一个读设备块的"
"I/O请求，并在某确定位置给出这个I/O请求的地址，然后给设备发出’kick’通知(读或写"
"相关I/O寄存器映射的内存地址)，此时处于I/O请求状态；设备在得到通知后，此时处"
"于 I/O处理状态，它解析这个I/O请求，完成这个I/O请求的处理，即把磁盘块内容读入"
"到内存中，并给出读出的块数据的内存地址，再通过中断通知设备驱动，此时处于 I/O"
"完成状态；如果磁盘块读取发生错误，此时处于 I/O错误状态；设备驱动通过中断处理"
"例程，此时处于 I/O后续处理状态，设备驱动知道设备已经完成读磁盘块操作，会根据"
"磁盘块数据所在内存地址，把数据传递给文件系统进行进一步处理；如果设备驱动发现"
"磁盘块读错误，则会进行错误恢复相关的后续处理。"
msgstr ""
"DEVICE_NEEDS_RESET (64) ：设备触发了错误，需要重置才能继续工作。 在设备驱动程"
"序对virtio设备初始化的过程中，需要经历一系列的初始化阶段，这些阶段对应着设备"
"状态域的不同状态。  \n"
"**I/O传输状态**  \n"
"设备驱动程序控制virtio设备进行I/O传输过程中，会经历一系列过程和执行状态，包"
"括 I/O请求状态、 I/O处理状态、 I/O完成状态、I/O错误状态、 I/O后续处理状态等。"
"设备驱动程序在执行过程中，需要对上述状态进行不同的处理。 virtio设备进行I/O传"
"输过程中，设备驱动会指出 I/O请求队列的当前位置状态信息，这样设备能查到I/O请求"
"的信息，并根据 I/O请求进行I/O传输；而设备会指出 I/O完成队列的当前位置状态信"
"息，这样设备驱动通过读取 I/O完成数据结构中的状态信息，就知道设备是否完成I/O请"
"求的相应操作，并进行后续事务处理。 比如，virtio_blk设备驱动发出一个读设备块的"
"I/O请求，并在某确定位置给出这个I/O请求的地址，然后给设备发出’kick’通知(读或写"
"相关I/O寄存器映射的内存地址)，此时处于I/O请求状态；设备在得到通知后，此时处"
"于 I/O处理状态，它解析这个I/O请求，完成这个I/O请求的处理，即把磁盘块内容读入"
"到内存中，并给出读出的块数据的内存地址，再通过中断通知设备驱动，此时处于 I/O"
"完成状态；如果磁盘块读取发生错误，此时处于 I/O错误状态；设备驱动通过中断处理"
"例程，此时处于 I/O后续处理状态，设备驱动知道设备已经完成读磁盘块操作，会根据"
"磁盘块数据所在内存地址，把数据传递给文件系统进行进一步处理；如果设备驱动发现"
"磁盘块读错误，则会进行错误恢复相关的后续处理。"

#: src/architecture/device/virtio.md:50
msgid "virtio设备交互机制"
msgstr "virtio设备交互机制"

#: src/architecture/device/virtio.md:51
msgid ""
"virtio设备交互机制包括基于Notifications的事件通知和基于virtqueue虚拟队列的数"
"据传输。事件通知是指设备和驱动程序必须通知对方，它们有数据需要对方处理。数据"
"传输是指设备和驱动程序之间进行I/O数据（如磁盘块数据、网络包）传输。  \n"
"**Notification通知**  \n"
"驱动程序和设备在交互过程中需要相互通知对方：驱动程序组织好相关命令/信息要通知"
"设备去处理I/O事务，设备处理完I/O事务后，要通知驱动程序进行后续事务，如回收内"
"存，向用户进程反馈I/O事务的处理结果等。 驱动程序通知设备可用`门铃 doorbell`机"
"制，即采用PIO或MMIO方式访问设备特定寄存器，QEMU进行拦截再通知其模拟的设备。设"
"备通知驱动程序一般用中断机制，即在QEMU中进行中断注入，让CPU响应并执行中断处理"
"例程，来完成对I/O执行结果的处理。  \n"
"**virtqueue虚拟队列**  \n"
"在virtio设备上进行批量数据传输的机制被称为虚拟队列（virtqueue），virtio设备的"
"虚拟队列（virtqueue）可以由各种数据结构（如数组、环形队列等）来具体实现。每个"
"virtio设备可以拥有零个或多个virtqueue，每个virtqueue占用多个物理页，可用于设"
"备驱动程序给设备发I/O请求命令和相关数据（如磁盘块读写请求和读写缓冲区），也可"
"用于设备给设备驱动程序发I/O数据（如接收的网络包）。"
msgstr ""
"virtio设备交互机制包括基于Notifications的事件通知和基于virtqueue虚拟队列的数"
"据传输。事件通知是指设备和驱动程序必须通知对方，它们有数据需要对方处理。数据"
"传输是指设备和驱动程序之间进行I/O数据（如磁盘块数据、网络包）传输。  \n"
"**Notification通知**  \n"
"驱动程序和设备在交互过程中需要相互通知对方：驱动程序组织好相关命令/信息要通知"
"设备去处理I/O事务，设备处理完I/O事务后，要通知驱动程序进行后续事务，如回收内"
"存，向用户进程反馈I/O事务的处理结果等。 驱动程序通知设备可用`门铃 doorbell`机"
"制，即采用PIO或MMIO方式访问设备特定寄存器，QEMU进行拦截再通知其模拟的设备。设"
"备通知驱动程序一般用中断机制，即在QEMU中进行中断注入，让CPU响应并执行中断处理"
"例程，来完成对I/O执行结果的处理。  \n"
"**virtqueue虚拟队列**  \n"
"在virtio设备上进行批量数据传输的机制被称为虚拟队列（virtqueue），virtio设备的"
"虚拟队列（virtqueue）可以由各种数据结构（如数组、环形队列等）来具体实现。每个"
"virtio设备可以拥有零个或多个virtqueue，每个virtqueue占用多个物理页，可用于设"
"备驱动程序给设备发I/O请求命令和相关数据（如磁盘块读写请求和读写缓冲区），也可"
"用于设备给设备驱动程序发I/O数据（如接收的网络包）。"

#: src/architecture/device/virtio.md:57
msgid "virtqueue虚拟队列"
msgstr "virtqueue虚拟队列"

#: src/architecture/device/virtio.md:58
msgid ""
"virtio协议中一个关键部分是virtqueue，在virtio规范中，virtqueue是virtio设备上"
"进行批量数据传输的机制和抽象表示。在设备驱动实现和Qemu中virtio设备的模拟实现"
"中，virtqueue是一种数据结构，用于设备和驱动程序中执行各种数据传输操作。 操作"
"系统在Qemu上运行时，virtqueue是 virtio 驱动程序和 virtio 设备访问的同一块内存"
"区域。 当涉及到 virtqueue 的描述时，有很多不一致的地方。有将其与vring"
"（virtio-rings或VRings）等同表示，也有将二者分别单独描述为不同的对象。我们将"
"在这里单独描述它们，因为vring是virtqueues的主要组成部分，是达成virtio设备和驱"
"动程序之间数据传输的数据结构， vring本质是virtio设备和驱动程序之间的共享内"
"存，但 virtqueue 不仅仅只有vring。 virtqueue由三部分组成（如下图所示）："
msgstr ""
"virtio协议中一个关键部分是virtqueue，在virtio规范中，virtqueue是virtio设备上"
"进行批量数据传输的机制和抽象表示。在设备驱动实现和Qemu中virtio设备的模拟实现"
"中，virtqueue是一种数据结构，用于设备和驱动程序中执行各种数据传输操作。 操作"
"系统在Qemu上运行时，virtqueue是 virtio 驱动程序和 virtio 设备访问的同一块内存"
"区域。 当涉及到 virtqueue 的描述时，有很多不一致的地方。有将其与vring"
"（virtio-rings或VRings）等同表示，也有将二者分别单独描述为不同的对象。我们将"
"在这里单独描述它们，因为vring是virtqueues的主要组成部分，是达成virtio设备和驱"
"动程序之间数据传输的数据结构， vring本质是virtio设备和驱动程序之间的共享内"
"存，但 virtqueue 不仅仅只有vring。 virtqueue由三部分组成（如下图所示）："

#: src/architecture/device/virtio.md:62
msgid ""
"描述符表 Descriptor Table：描述符表是描述符为组成元素的数组，每个描述符描述了"
"一个内存buffer 的address/length。而内存buffer中包含I/O请求的命令/数据（由"
"virtio设备驱动填写），也可包含I/O完成的返回结果（由virtio设备填写）等。"
msgstr ""
"描述符表 Descriptor Table：描述符表是描述符为组成元素的数组，每个描述符描述了"
"一个内存buffer 的address/length。而内存buffer中包含I/O请求的命令/数据（由"
"virtio设备驱动填写），也可包含I/O完成的返回结果（由virtio设备填写）等。"

#: src/architecture/device/virtio.md:63
msgid ""
"可用环 Available Ring：一种vring，记录了virtio设备驱动程序发出的I/O请求索引，"
"即被virtio设备驱动程序更新的描述符索引的集合，需要virtio设备进行读取并完成相"
"关I/O操作；"
msgstr ""
"可用环 Available Ring：一种vring，记录了virtio设备驱动程序发出的I/O请求索引，"
"即被virtio设备驱动程序更新的描述符索引的集合，需要virtio设备进行读取并完成相"
"关I/O操作；"

#: src/architecture/device/virtio.md:64
msgid ""
"已用环 Used Ring：另一种vring，记录了virtio设备发出的I/O完成索引，即被virtio"
"设备更新的描述符索引的集合，需要vrtio设备驱动程序进行读取并对I/O操作结果进行"
"进一步处理。 ![](../../assets/virtqueue.png) **描述符表 Descriptor "
"Table**  \n"
"描述符表用来指向virtio设备I/O传输请求的缓冲区（buffer）信息，由 Queue Size 个"
"Descriptor（描述符）组成。描述符中包括buffer的物理地址 – addr字段，buffer的长"
"度 – len字段，可以链接到 next Descriptor 的next指针（用于把多个描述符链接成描"
"述符链）。buffer所在物理地址空间需要设备驱动程序在初始化时分配好，并在后续由"
"设备驱动程序在其中填写IO传输相关的命令/数据，或者是设备返回I/O操作的结果。多"
"个描述符（I/O操作命令，I/O操作数据块，I/O操作的返回结果）形成的描述符链可以表"
"示一个完整的I/O操作请求。  \n"
"**可用环 Available Ring**  \n"
"可用环在结构上是一个环形队列，其中的条目（item）仅由驱动程序写入，并由设备读"
"出。可用环中的条目包含了一个描述符链的头部描述符的索引值。可用环用头指针"
"（idx）和尾指针（last_avail_idx）表示其可用条目范围。virtio设备通过读取可用环"
"中的条目可获取驱动程序发出的I/O操作请求对应的描述符链，然后virtio设备就可以进"
"行进一步的I/O处理了。描述符指向的缓冲区具有可读写属性，可读的缓冲区用于Driver"
"发送数据，可写的缓冲区用于接收数据。 比如，对于virtio-blk设备驱动发出的一个读"
"I/O操作请求包含了三部分内容，由三个buffer承载，需要用到三个描述符 ：（1） “读"
"磁盘块”，（2）I/O操作数据块 – “数据缓冲区”，（3）I/O操作的返回结果 –“结果缓冲"
"区”）。这三个描述符形成的一个完成的I/O请求链，virtio-blk从设备可通过读取第一"
"个描述符指向的缓冲区了解到是“读磁盘块”操作，这样就可把磁盘块数据通过DMA操作放"
"到第二个描述符指向的“数据缓冲区”中，然后把“OK”写入到第三个描述符指向的“结果缓"
"冲区”中。  \n"
"**已用环 Used Ring**  \n"
"已用环在结构上是一个环形队列，其中的的条目仅由virtio设备写入，并由驱动程序读"
"出。已用环中的条目也一个是描述符链的头部描述符的索引值。已用环也有头指针"
"（idx）和尾指针（last_avail_idx）表示其已用条目的范围。 比如，对于virtio-blk"
"设备驱动发出的一个读I/O操作请求（由三个描述符形成的请求链）后，virtio设备完成"
"相应I/O处理，即把磁盘块数据写入第二个描述符指向的“数据缓冲区”中，可用环中对应"
"的I/O请求条目“I/O操作的返回结果”的描述符索引值移入到已用环中，把“OK”写入到第"
"三个描述符指向的“结果缓冲区”中，再在已用环中添加一个已用条目，即I/O操作完成信"
"息；然后virtio设备通过中断机制来通知virtio驱动程序，并让virtio驱动程序读取已"
"用环中的描述符，获得I/O操作完成信息，即磁盘块内容。 上面主要说明了virqueue中"
"的各个部分的作用。对如何基于virtqueue进行I/O操作的过程还缺乏一个比较完整的描"
"述。我们把上述基于virtqueue进行I/O操作的过程小结一下，大致需要如下步骤："
msgstr ""
"已用环 Used Ring：另一种vring，记录了virtio设备发出的I/O完成索引，即被virtio"
"设备更新的描述符索引的集合，需要vrtio设备驱动程序进行读取并对I/O操作结果进行"
"进一步处理。 ![](../../assets/virtqueue.png) **描述符表 Descriptor "
"Table**  \n"
"描述符表用来指向virtio设备I/O传输请求的缓冲区（buffer）信息，由 Queue Size 个"
"Descriptor（描述符）组成。描述符中包括buffer的物理地址 – addr字段，buffer的长"
"度 – len字段，可以链接到 next Descriptor 的next指针（用于把多个描述符链接成描"
"述符链）。buffer所在物理地址空间需要设备驱动程序在初始化时分配好，并在后续由"
"设备驱动程序在其中填写IO传输相关的命令/数据，或者是设备返回I/O操作的结果。多"
"个描述符（I/O操作命令，I/O操作数据块，I/O操作的返回结果）形成的描述符链可以表"
"示一个完整的I/O操作请求。  \n"
"**可用环 Available Ring**  \n"
"可用环在结构上是一个环形队列，其中的条目（item）仅由驱动程序写入，并由设备读"
"出。可用环中的条目包含了一个描述符链的头部描述符的索引值。可用环用头指针"
"（idx）和尾指针（last_avail_idx）表示其可用条目范围。virtio设备通过读取可用环"
"中的条目可获取驱动程序发出的I/O操作请求对应的描述符链，然后virtio设备就可以进"
"行进一步的I/O处理了。描述符指向的缓冲区具有可读写属性，可读的缓冲区用于Driver"
"发送数据，可写的缓冲区用于接收数据。 比如，对于virtio-blk设备驱动发出的一个读"
"I/O操作请求包含了三部分内容，由三个buffer承载，需要用到三个描述符 ：（1） “读"
"磁盘块”，（2）I/O操作数据块 – “数据缓冲区”，（3）I/O操作的返回结果 –“结果缓冲"
"区”）。这三个描述符形成的一个完成的I/O请求链，virtio-blk从设备可通过读取第一"
"个描述符指向的缓冲区了解到是“读磁盘块”操作，这样就可把磁盘块数据通过DMA操作放"
"到第二个描述符指向的“数据缓冲区”中，然后把“OK”写入到第三个描述符指向的“结果缓"
"冲区”中。  \n"
"**已用环 Used Ring**  \n"
"已用环在结构上是一个环形队列，其中的的条目仅由virtio设备写入，并由驱动程序读"
"出。已用环中的条目也一个是描述符链的头部描述符的索引值。已用环也有头指针"
"（idx）和尾指针（last_avail_idx）表示其已用条目的范围。 比如，对于virtio-blk"
"设备驱动发出的一个读I/O操作请求（由三个描述符形成的请求链）后，virtio设备完成"
"相应I/O处理，即把磁盘块数据写入第二个描述符指向的“数据缓冲区”中，可用环中对应"
"的I/O请求条目“I/O操作的返回结果”的描述符索引值移入到已用环中，把“OK”写入到第"
"三个描述符指向的“结果缓冲区”中，再在已用环中添加一个已用条目，即I/O操作完成信"
"息；然后virtio设备通过中断机制来通知virtio驱动程序，并让virtio驱动程序读取已"
"用环中的描述符，获得I/O操作完成信息，即磁盘块内容。 上面主要说明了virqueue中"
"的各个部分的作用。对如何基于virtqueue进行I/O操作的过程还缺乏一个比较完整的描"
"述。我们把上述基于virtqueue进行I/O操作的过程小结一下，大致需要如下步骤："

#: src/architecture/device/virtio.md:75
msgid ""
"初始化过程：（驱动程序执行）  \n"
"1.1 virtio设备驱动在对设备进行初始化时，会申请virtqueue（包括描述符表、可用"
"环、已用环）的内存空间；  \n"
"1.2 并把virtqueue中的描述符、可用环、已用环三部分的物理地址分别写入到virtio设"
"备中对应的控制寄存器（即设备绑定的特定内存地址）中。至此，设备驱动和设备就共"
"享了整个virtqueue的内存空间。"
msgstr ""
"初始化过程：（驱动程序执行）  \n"
"1.1 virtio设备驱动在对设备进行初始化时，会申请virtqueue（包括描述符表、可用"
"环、已用环）的内存空间；  \n"
"1.2 并把virtqueue中的描述符、可用环、已用环三部分的物理地址分别写入到virtio设"
"备中对应的控制寄存器（即设备绑定的特定内存地址）中。至此，设备驱动和设备就共"
"享了整个virtqueue的内存空间。"

#: src/architecture/device/virtio.md:78
msgid ""
"I/O请求过程：（驱动程序执行）  \n"
"2.1 设备驱动在发出I/O请求时，首先把I/O请求的命令/数据等放到一个或多个buffer"
"中；  \n"
"2.2 然后在描述符表中分配新的描述符（或描述符链）来指向这些buffer；  \n"
"2.3 再把描述符（或描述符链的首描述符）的索引值写入到可用环中，更新可用环的idx"
"指针；  \n"
"2.4 驱动程序通过kick机制（即写virtio设备中特定的通知控制寄存器）来通知设备有"
"新请求；"
msgstr ""
"I/O请求过程：（驱动程序执行）  \n"
"2.1 设备驱动在发出I/O请求时，首先把I/O请求的命令/数据等放到一个或多个buffer"
"中；  \n"
"2.2 然后在描述符表中分配新的描述符（或描述符链）来指向这些buffer；  \n"
"2.3 再把描述符（或描述符链的首描述符）的索引值写入到可用环中，更新可用环的idx"
"指针；  \n"
"2.4 驱动程序通过kick机制（即写virtio设备中特定的通知控制寄存器）来通知设备有"
"新请求；"

#: src/architecture/device/virtio.md:83
msgid ""
"I/O完成过程：（设备执行）  \n"
"3.1 virtio设备通过kick机制（知道有新的I/O请求，通过访问可用环的idx指针，解析"
"出I/O请求；  \n"
"3.2 根据I/O请求内容完成I/O请求，并把I/O操作的结果放到I/O请求中相应的buffer"
"中；  \n"
"3.3 再把描述符（或描述符链的首描述符）的索引值写入到已用环中，更新已用环的idx"
"指针；  \n"
"3.4 设备通过再通过中断机制来通知设备驱动程序有I/O操作完成；"
msgstr ""
"I/O完成过程：（设备执行）  \n"
"3.1 virtio设备通过kick机制（知道有新的I/O请求，通过访问可用环的idx指针，解析"
"出I/O请求；  \n"
"3.2 根据I/O请求内容完成I/O请求，并把I/O操作的结果放到I/O请求中相应的buffer"
"中；  \n"
"3.3 再把描述符（或描述符链的首描述符）的索引值写入到已用环中，更新已用环的idx"
"指针；  \n"
"3.4 设备通过再通过中断机制来通知设备驱动程序有I/O操作完成；"

#: src/architecture/device/virtio.md:88
msgid ""
"I/O后处理过程：（驱动程序执行）  \n"
"4.1 设备驱动程序读取已用环的idx信息，读取已用环中的描述符索引，获得I/O操作完"
"成信息。  <style> .scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: "
"3.2rem; display: none; align-items: center; justify-content: center; "
"position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px "
"+ var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: "
"var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top."
"hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } "
"@media (min-width: 1080px) { .scroll-to-top { display: flex; } } </style> "
"<button type=\"button\" aria-label=\"scroll-to-top\" class=\"scroll-to-top "
"hidden\" onclick=\"scrollToTop()\"> <i class=\"fa fa-angle-up\"></i> </"
"button>"
msgstr ""
"I/O后处理过程：（驱动程序执行）  \n"
"4.1 设备驱动程序读取已用环的idx信息，读取已用环中的描述符索引，获得I/O操作完"
"成信息。  <style> .scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: "
"3.2rem; display: none; align-items: center; justify-content: center; "
"position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px "
"+ var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: "
"var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top."
"hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } "
"@media (min-width: 1080px) { .scroll-to-top { display: flex; } } </style> "
"<button type=\"button\" aria-label=\"scroll-to-top\" class=\"scroll-to-top "
"hidden\" onclick=\"scrollToTop()\"> <i class=\"fa fa-angle-up\"></i> </"
"button>"

#: src/architecture/multi_layer_VM-Exit.md:1
msgid ""
"[多层VM-Exit处理机制](https://github.com/orgs/arceos-hypervisor/"
"discussions/19)"
msgstr ""
"[多层VM-Exit处理机制](https://github.com/orgs/arceos-hypervisor/"
"discussions/19)"

#: src/architecture/multi_layer_VM-Exit.md:3
msgid ""
"众所周知，VM-Exit 对于获取客户虚拟机的运行状态以及与客户虚拟机进行交互至关重"
"要。"
msgstr ""
"众所周知，VM-Exit 对于获取客户虚拟机的运行状态以及与客户虚拟机进行交互至关重"
"要。"

#: src/architecture/multi_layer_VM-Exit.md:5
msgid "VM-Exit 用于设备仿真和 vCPU 调度。"
msgstr "VM-Exit 用于设备仿真和 vCPU 调度。"

#: src/architecture/multi_layer_VM-Exit.md:7
msgid ""
"在 x86_64、aarch64 和 riscv64 架构中，VM-Exit 遵循相同的设计逻辑，但实现方式"
"略有不同。"
msgstr ""
"在 x86_64、aarch64 和 riscv64 架构中，VM-Exit 遵循相同的设计逻辑，但实现方式"
"略有不同。"

#: src/architecture/multi_layer_VM-Exit.md:9
msgid "![](../assets/vmexit-handling.png)"
msgstr "![](../assets/vmexit-handling.png)"

#: src/architecture/multi_layer_VM-Exit.md:11
msgid "Inner-VCpu处理"
msgstr "Inner-VCpu处理"

#: src/architecture/multi_layer_VM-Exit.md:13
msgid ""
"在 x86_64 架构下，某些 VM-Exit 项目是特定于架构的（例如 `VmxExitReason::"
"CR_ACCESS`、`VmxExitReason::CPUID`）。在我们当前的设计中，这些 VM-Exit 由 "
"\\[`VmxVcpu`\\] 本身通过 `builtin_vmexit_handler` 处理，而其他 VM-Exit 类型则"
"由 `vcpu.run()` 返回，并由调用 `vcpu.run()` 的程序来处理。"
msgstr ""
"在 x86_64 架构下，某些 VM-Exit 项目是特定于架构的（例如 `VmxExitReason::"
"CR_ACCESS`、`VmxExitReason::CPUID`）。在我们当前的设计中，这些 VM-Exit 由 "
"\\[`VmxVcpu`\\] 本身通过 `builtin_vmexit_handler` 处理，而其他 VM-Exit 类型则"
"由 `vcpu.run()` 返回，并由调用 `vcpu.run()` 的程序来处理。"

#: src/architecture/multi_layer_VM-Exit.md:17
msgid ""
"/// Handle vm-exits than can and should be handled by [`VmxVcpu`] itself.\n"
"    ///\n"
"    /// Return the result or None if the vm-exit was not handled.\n"
msgstr ""
"/// Handle vm-exits than can and should be handled by [`VmxVcpu`] itself.\n"
"    ///\n"
"    /// Return the result or None if the vm-exit was not handled.\n"

#: src/architecture/multi_layer_VM-Exit.md:21
msgid ""
"// Following vm-exits are handled here:\n"
"        // - interrupt window: turn off interrupt window;\n"
"        // - xsetbv: set guest xcr;\n"
"        // - cr access: just panic;\n"
msgstr ""
"// Following vm-exits are handled here:\n"
"        // - interrupt window: turn off interrupt window;\n"
"        // - xsetbv: set guest xcr;\n"
"        // - cr access: just panic;\n"

#: src/architecture/multi_layer_VM-Exit.md:37
msgid ""
"此外，`VmxExitReason::IoRead/IoWrite` 和 `VmxExitReason::MsrRead/MsrWrite` 也"
"是 x86_64 特有的，但这些 VM-Exit 与端口 I/O 或 Msr 设备仿真相关，因此更适合"
"在 `vcpu.run()` 之外处理。"
msgstr ""
"此外，`VmxExitReason::IoRead/IoWrite` 和 `VmxExitReason::MsrRead/MsrWrite` 也"
"是 x86_64 特有的，但这些 VM-Exit 与端口 I/O 或 Msr 设备仿真相关，因此更适合"
"在 `vcpu.run()` 之外处理。"

#: src/architecture/multi_layer_VM-Exit.md:39
msgid "Inner-VM处理"
msgstr "Inner-VM处理"

#: src/architecture/multi_layer_VM-Exit.md:41
msgid ""
"由于 axvm 中的虚拟机结构负责虚拟机的资源管理，例如模拟设备和地址空间"
"（axaddrspace），所以更倾向于将与设备模拟相关的以及与页面错误相关的（数据中"
"止）虚拟机退出保留在 axvm 内部。"
msgstr ""
"由于 axvm 中的虚拟机结构负责虚拟机的资源管理，例如模拟设备和地址空间"
"（axaddrspace），所以更倾向于将与设备模拟相关的以及与页面错误相关的（数据中"
"止）虚拟机退出保留在 axvm 内部。"

#: src/architecture/multi_layer_VM-Exit.md:43
msgid ""
"也就是说，在虚拟机结构中提供一个 `run_vcpu()` 函数，并将与设备模拟相关的 VM "
"退出处理整合到 `vm.run_vcpu()`"
msgstr ""
"也就是说，在虚拟机结构中提供一个 `run_vcpu()` 函数，并将与设备模拟相关的 VM "
"退出处理整合到 `vm.run_vcpu()`"

#: src/architecture/multi_layer_VM-Exit.md:50
msgid "\"Invalid vcpu_id\""
msgstr "\"Invalid vcpu_id\""

#: src/architecture/multi_layer_VM-Exit.md:57
msgid "\"{exit_reason:#x?}\""
msgstr "\"{exit_reason:#x?}\""

#: src/architecture/multi_layer_VM-Exit.md:89
msgid ""
"因此，将设备模拟操作整合到 `axvm` 模块中，这样 `vmm-app` 只需要传入配置文件就"
"可以，然后根据需要创建模拟设备实例，而不必关心模拟设备的特定运行时行为以及地"
"址空间。"
msgstr ""
"因此，将设备模拟操作整合到 `axvm` 模块中，这样 `vmm-app` 只需要传入配置文件就"
"可以，然后根据需要创建模拟设备实例，而不必关心模拟设备的特定运行时行为以及地"
"址空间。"

#: src/architecture/multi_layer_VM-Exit.md:91
msgid "当然，这是在这些 VM-exit 不触发 vCPU 调度的条件下。"
msgstr "当然，这是在这些 VM-exit 不触发 vCPU 调度的条件下。"

#: src/architecture/multi_layer_VM-Exit.md:93
msgid "(Outer-VM) vmm-app处理"
msgstr "(Outer-VM) vmm-app处理"

#: src/architecture/multi_layer_VM-Exit.md:95
msgid "我们重用 task 来实现 vcpu 的运行时管理和调度。"
msgstr "我们重用 task 来实现 vcpu 的运行时管理和调度。"

#: src/architecture/multi_layer_VM-Exit.md:97
msgid ""
"这个逻辑是在 `vmm-app` 中实现的，因为 VMM 自然需要关注 vCPU 调度，并且它在 "
"`vmm-app` 中整合了对 ArceOS 的 axtask 的依赖。"
msgstr ""
"这个逻辑是在 `vmm-app` 中实现的，因为 VMM 自然需要关注 vCPU 调度，并且它在 "
"`vmm-app` 中整合了对 ArceOS 的 axtask 的依赖。"

#: src/architecture/multi_layer_VM-Exit.md:99
msgid ""
"对于前两层没有处理的 VM-Exit，它们将从 `vcpu::run()` 的返回值中获取，并在这里"
"进行处理，包括处理 hypercalls（在 VMM 中处理这个似乎也相当合理）和任何需要 "
"vcpu 调度或 vcpu 退出的 VM-Exit 类型。"
msgstr ""
"对于前两层没有处理的 VM-Exit，它们将从 `vcpu::run()` 的返回值中获取，并在这里"
"进行处理，包括处理 hypercalls（在 VMM 中处理这个似乎也相当合理）和任何需要 "
"vcpu 调度或 vcpu 退出的 VM-Exit 类型。"

#: src/architecture/multi_layer_VM-Exit.md:111
msgid "\"VM[{}] Vcpu[{}] waiting for running\""
msgstr "\"VM[{}] Vcpu[{}] waiting for running\""

#: src/architecture/multi_layer_VM-Exit.md:114
msgid "\"VM[{}] Vcpu[{}] running...\""
msgstr "\"VM[{}] Vcpu[{}] running...\""

#: src/architecture/multi_layer_VM-Exit.md:121
msgid "\"Hypercall [{}] args {:x?}\""
msgstr "\"Hypercall [{}] args {:x?}\""

#: src/architecture/multi_layer_VM-Exit.md:127
msgid "\"VM[{}] VCpu[{}] run failed with exit code {}\""
msgstr "\"VM[{}] VCpu[{}] run failed with exit code {}\""

#: src/architecture/multi_layer_VM-Exit.md:132
msgid "\"VM[{}] run VCpu[{}] get irq {}\""
msgstr "\"VM[{}] run VCpu[{}] get irq {}\""

#: src/architecture/multi_layer_VM-Exit.md:135
msgid "\"VM[{}] run VCpu[{}] Halt\""
msgstr "\"VM[{}] run VCpu[{}] Halt\""

#: src/architecture/multi_layer_VM-Exit.md:144
msgid "\"VM[{}] run VCpu[{}] get error {:?}\""
msgstr "\"VM[{}] run VCpu[{}] get error {:?}\""

#: src/architecture/multi_layer_VM-Exit.md:150
msgid "\"VCpu[{}]\""
msgstr "\"VCpu[{}]\""

#: src/architecture/test/test.md:1
msgid ""
"待添加。。。<style> .scroll-to-top { font-size: 2.5rem; width: 3.2rem; "
"height: 3.2rem; display: none; align-items: center; justify-content: center; "
"position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px "
"+ var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: "
"var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top."
"hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } "
"@media (min-width: 1080px) { .scroll-to-top { display: flex; } } </style> "
"<button type=\"button\" aria-label=\"scroll-to-top\" class=\"scroll-to-top "
"hidden\" onclick=\"scrollToTop()\"> <i class=\"fa fa-angle-up\"></i> </"
"button>"
msgstr ""
"待添加。。。<style> .scroll-to-top { font-size: 2.5rem; width: 3.2rem; "
"height: 3.2rem; display: none; align-items: center; justify-content: center; "
"position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px "
"+ var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: "
"var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top."
"hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } "
"@media (min-width: 1080px) { .scroll-to-top { display: flex; } } </style> "
"<button type=\"button\" aria-label=\"scroll-to-top\" class=\"scroll-to-top "
"hidden\" onclick=\"scrollToTop()\"> <i class=\"fa fa-angle-up\"></i> </"
"button>"

#: src/development/guest_vms/2vm_timer.md:1
msgid "在 QEMU-ARM 平台上启动两个nimbos，并分别注入 timer 中断"
msgstr "在 QEMU-ARM 平台上启动两个nimbos，并分别注入 timer 中断"

#: src/development/guest_vms/2vm_timer.md:3
msgid "Clone代码"
msgstr "Clone代码"

#: src/development/guest_vms/2vm_timer.md:5
msgid "新建创建项目的`clone.sh`，然后`bash clone.sh`自动创建项目"
msgstr "新建创建项目的`clone.sh`，然后`bash clone.sh`自动创建项目"

#: src/development/guest_vms/2vm_timer.md:8
msgid "#!/bin/bash\n"
msgstr "#!/bin/bash\n"

#: src/development/guest_vms/2vm_timer.md:10
msgid "\"-b debin/2vm_timer\""
msgstr "\"-b debin/2vm_timer\""

#: src/development/guest_vms/2vm_timer.md:17
msgid "# 克隆arceos主仓库\n"
msgstr "# 克隆arceos主仓库\n"

#: src/development/guest_vms/2vm_timer.md:20
msgid "# 克隆其他仓库到crates目录\n"
msgstr "# 克隆其他仓库到crates目录\n"

#: src/development/guest_vms/2vm_timer.md:23
msgid "\"axvm\""
msgstr "\"axvm\""

#: src/development/guest_vms/2vm_timer.md:24
msgid "\"axvcpu\""
msgstr "\"axvcpu\""

#: src/development/guest_vms/2vm_timer.md:25
msgid "\"axaddrspace\""
msgstr "\"axaddrspace\""

#: src/development/guest_vms/2vm_timer.md:26
msgid "\"arm_vcpu\""
msgstr "\"arm_vcpu\""

#: src/development/guest_vms/2vm_timer.md:27
msgid "\"axdevice\""
msgstr "\"axdevice\""

#: src/development/guest_vms/2vm_timer.md:28
msgid "\"arm_vgic\""
msgstr "\"arm_vgic\""

#: src/development/guest_vms/2vm_timer.md:29
msgid "\"arm_gicv2\""
msgstr "\"arm_gicv2\""

#: src/development/guest_vms/2vm_timer.md:30
msgid "\"axdevice_crates\""
msgstr "\"axdevice_crates\""

#: src/development/guest_vms/2vm_timer.md:33
msgid "\"${REPOS[@]}\""
msgstr "\"${REPOS[@]}\""

#: src/development/guest_vms/2vm_timer.md:34
msgid ""
"\"https://github.com/arceos-hypervisor/${repo}.git\" \"../crates/${repo}\""
msgstr ""
"\"https://github.com/arceos-hypervisor/${repo}.git\" \"../crates/${repo}\""

#: src/development/guest_vms/2vm_timer.md:37
msgid "\"所有仓库克隆完成！\""
msgstr "\"所有仓库克隆完成！\""

#: src/development/guest_vms/2vm_timer.md:38
msgid "# 创建临时文件\n"
msgstr "# 创建临时文件\n"

#: src/development/guest_vms/2vm_timer.md:41
msgid "# 要添加的新内容\n"
msgstr "# 要添加的新内容\n"

#: src/development/guest_vms/2vm_timer.md:43
msgid ""
"\"$temp_file\" << 'EOF'\n"
"[patch.\"https://github.com/arceos-hypervisor/arceos.git\".axstd]\n"
"path = \"../arceos/ulib/axstd\"\n"
"[patch.\"https://github.com/arceos-hypervisor/arceos.git\".axhal]\n"
"path = \"../arceos/modules/axhal\"\n"
"[patch.\"https://github.com/arceos-hypervisor/axvm.git\".axvm]\n"
"path = \"../crates/axvm\"\n"
"[patch.\"https://github.com/arceos-hypervisor/axvcpu.git\".axvcpu]\n"
"path = \"../crates/axvcpu\"\n"
"[patch.\"https://github.com/arceos-hypervisor/axaddrspace.git\"."
"axaddrspace]\n"
"path = \"../crates/axaddrspace\"\n"
"[patch.\"https://github.com/arceos-hypervisor/arm_vcpu.git\".arm_vcpu]\n"
"path = \"../crates/arm_vcpu\"\n"
"[patch.\"https://github.com/arceos-hypervisor/axdevice.git\".axdevice]\n"
"path = \"../crates/axdevice\"\n"
"[patch.\"https://github.com/arceos-hypervisor/arm_vgic.git\".arm_vgic]\n"
"path = \"../crates/arm_vgic\"\n"
"[patch.\"https://github.com/arceos-hypervisor/axdevice_crates.git\"."
"axdevice_base]\n"
"path = \"../crates/axdevice_crates/axdevice_base\"\n"
"[patch.\"https://github.com/arceos-hypervisor/arm_gicv2.git\".arm_gicv2]\n"
"path = \"../crates/arm_gicv2\"\n"
"\n"
"EOF\n"
"\n"
"# 将原文件内容追加到临时文件\n"
msgstr ""
"\"$temp_file\" << 'EOF'\n"
"[patch.\"https://github.com/arceos-hypervisor/arceos.git\".axstd]\n"
"path = \"../arceos/ulib/axstd\"\n"
"[patch.\"https://github.com/arceos-hypervisor/arceos.git\".axhal]\n"
"path = \"../arceos/modules/axhal\"\n"
"[patch.\"https://github.com/arceos-hypervisor/axvm.git\".axvm]\n"
"path = \"../crates/axvm\"\n"
"[patch.\"https://github.com/arceos-hypervisor/axvcpu.git\".axvcpu]\n"
"path = \"../crates/axvcpu\"\n"
"[patch.\"https://github.com/arceos-hypervisor/axaddrspace.git\"."
"axaddrspace]\n"
"path = \"../crates/axaddrspace\"\n"
"[patch.\"https://github.com/arceos-hypervisor/arm_vcpu.git\".arm_vcpu]\n"
"path = \"../crates/arm_vcpu\"\n"
"[patch.\"https://github.com/arceos-hypervisor/axdevice.git\".axdevice]\n"
"path = \"../crates/axdevice\"\n"
"[patch.\"https://github.com/arceos-hypervisor/arm_vgic.git\".arm_vgic]\n"
"path = \"../crates/arm_vgic\"\n"
"[patch.\"https://github.com/arceos-hypervisor/axdevice_crates.git\"."
"axdevice_base]\n"
"path = \"../crates/axdevice_crates/axdevice_base\"\n"
"[patch.\"https://github.com/arceos-hypervisor/arm_gicv2.git\".arm_gicv2]\n"
"path = \"../crates/arm_gicv2\"\n"
"\n"
"EOF\n"
"\n"
"# 将原文件内容追加到临时文件\n"

#: src/development/guest_vms/2vm_timer.md:68
#: src/development/guest_vms/2vm_timer.md:71
msgid "\"$temp_file\""
msgstr "\"$temp_file\""

#: src/development/guest_vms/2vm_timer.md:69
msgid "# 将临时文件移回原文件\n"
msgstr "# 将临时文件移回原文件\n"

#: src/development/guest_vms/2vm_timer.md:73
msgid "\"成功更新 Cargo.toml\""
msgstr "\"成功更新 Cargo.toml\""

#: src/development/guest_vms/2vm_timer.md:77
msgid ""
"<< 'EOF'\n"
"{\n"
"    \"rust-analyzer.cargo.target\": \"aarch64-unknown-none-softfloat\",\n"
"    \"rust-analyzer.check.allTargets\": false,\n"
"    \"rust-analyzer.cargo.features\": [\"irq\", \"hv\"],\n"
"    \"rust-analyzer.cargo.extraEnv\": {\n"
"        \"RUSTFLAGS\": \"--cfg platform_family=\\\"aarch64-qemu-virt\\\"\"\n"
"    }\n"
"}\n"
"EOF\n"
"\n"
msgstr ""
"<< 'EOF'\n"
"{\n"
"    \"rust-analyzer.cargo.target\": \"aarch64-unknown-none-softfloat\",\n"
"    \"rust-analyzer.check.allTargets\": false,\n"
"    \"rust-analyzer.cargo.features\": [\"irq\", \"hv\"],\n"
"    \"rust-analyzer.cargo.extraEnv\": {\n"
"        \"RUSTFLAGS\": \"--cfg platform_family=\\\"aarch64-qemu-virt\\\"\"\n"
"    }\n"
"}\n"
"EOF\n"
"\n"

#: src/development/guest_vms/2vm_timer.md:92
msgid "编译nimbos"
msgstr "编译nimbos"

#: src/development/guest_vms/2vm_timer.md:94
msgid ""
"因为加载到任意地址的功能还没有实现，所以只能通过硬配置来做，得单独编译两个"
"nimbos"
msgstr ""
"因为加载到任意地址的功能还没有实现，所以只能通过硬配置来做，得单独编译两个"
"nimbos"

#: src/development/guest_vms/2vm_timer.md:96
msgid "nimbos（VM1）"
msgstr "nimbos（VM1）"

#: src/development/guest_vms/2vm_timer.md:102
msgid "nimbos（VM2）"
msgstr "nimbos（VM2）"

#: src/development/guest_vms/2vm_timer.md:110
msgid "创建`disk.img`文件"
msgstr "创建`disk.img`文件"

#: src/development/guest_vms/2vm_timer.md:112
msgid "生成一个disk.img，然后将编译好的nimbos.bin重命名并放入里面"
msgstr "生成一个disk.img，然后将编译好的nimbos.bin重命名并放入里面"

#: src/development/guest_vms/2vm_timer.md:124
msgid "启动VMMS"
msgstr "启动VMMS"

#: src/development/guest_vms/2vm_timer.md:129
msgid "# 在qemu启动后，打开第二个终端使用telnet连接串口2\n"
msgstr "# 在qemu启动后，打开第二个终端使用telnet连接串口2\n"

#: src/development/guest_vms/2vm_timer.md:134
msgid "就可以正常注入timer了"
msgstr "就可以正常注入timer了"

#: src/development/guest_vms/2vm_timer.md:136
msgid "VM1"
msgstr "VM1"

#: src/development/guest_vms/2vm_timer.md:224
msgid "VM2"
msgstr "VM2"

#: src/development/guest_vms/2vm_timer.md:229
msgid "'^]'"
msgstr "'^]'"

#: src/development/guest_vms/2vm_timer.md:304
msgid "多虚拟串口支持"
msgstr "多虚拟串口支持"

#: src/development/guest_vms/2vm_timer.md:306
msgid "如果不能正常启动，考虑使用修改版的qemu"
msgstr "如果不能正常启动，考虑使用修改版的qemu"

#: src/development/guest_vms/2vm_timer.md:315
msgid "串口"
msgstr "串口"

#: src/development/guest_vms/2vm_timer.md:315
msgid "地址"
msgstr "地址"

#: src/development/guest_vms/2vm_timer.md:315
msgid "中断号offset"
msgstr "中断号offset"

#: src/development/guest_vms/2vm_timer.md:317
msgid "UART0"
msgstr "UART0"

#: src/development/guest_vms/2vm_timer.md:317
msgid "0x09000000"
msgstr "0x09000000"

#: src/development/guest_vms/2vm_timer.md:317
msgid "1"
msgstr "1"

#: src/development/guest_vms/2vm_timer.md:318
msgid "UART1"
msgstr "UART1"

#: src/development/guest_vms/2vm_timer.md:318
msgid "0x09040000"
msgstr "0x09040000"

#: src/development/guest_vms/2vm_timer.md:318
msgid "8"
msgstr "8"

#: src/development/guest_vms/2vm_timer.md:319
msgid "UART2"
msgstr "UART2"

#: src/development/guest_vms/2vm_timer.md:319
msgid "0x09100000"
msgstr "0x09100000"

#: src/development/guest_vms/2vm_timer.md:319
msgid "21"
msgstr "21"

#: src/development/guest_vms/2vm_timer.md:320
msgid "UART3"
msgstr "UART3"

#: src/development/guest_vms/2vm_timer.md:320
msgid "0x09140000"
msgstr "0x09140000"

#: src/development/guest_vms/2vm_timer.md:320
msgid "22"
msgstr "22"

#: src/roadmap/discusstions.md:1
msgid ""
"AxVisor Design [Discussions](https://github.com/orgs/arceos-hypervisor/"
"discussions)"
msgstr ""
"AxVisor Design [Discussions](https://github.com/orgs/arceos-hypervisor/"
"discussions)"
