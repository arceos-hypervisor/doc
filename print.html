<!DOCTYPE HTML>
<html lang="zh-CN" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>AxVisor Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/assets/css/custom.css">
        <link rel="stylesheet" href="theme/pagetoc.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">AxVisor Book</h1>

                    <div class="right-buttons">
                        <button id="language-toggle" class="icon-button" type="button"
                                title="Change language" aria-label="Change language"
                                aria-haspopup="true" aria-expanded="false"
                                aria-controls="language-list">
                            <i class="fa fa-globe"></i>
                        </button>
                        <ul id="language-list" class="theme-popup" aria-label="Languages" role="menu">
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="zh-CN">中文</a>
                          </button></li>
                          <li role="none"><button role="menuitem" class="theme">
                              <a id="en">English</a>
                          </button></li>
                        </ul>
                        <script>
                          let langToggle = document.getElementById("language-toggle");
                          let langList = document.getElementById("language-list");
                          langToggle.addEventListener("click", (event) => {
                              langList.style.display = langList.style.display == "block" ? "none" : "block";
                          });
                          let selectedLang = document.getElementById("zh-CN");
                          if (selectedLang) {
                              selectedLang.parentNode.classList.add("theme-selected");
                          }

                          // The path to the root, taking the current
                          // language into account.
                          let full_path_to_root = "";
                          // The page path (mdbook only gives us
                          // access to the path to the Markdown file).
                          let path = "print.md".replace(/\.md$/, ".html");
                          for (let lang of langList.querySelectorAll("a")) {
                              if (lang.id == "zh-CN") {
                                  lang.href = `${full_path_to_root}${path}`;
                              } else {
                                  lang.href = `${full_path_to_root}${lang.id}/${path}`;
                              }
                          }

                          // When the user clicks a list item, the page jump is performed, just like clicking the internal <a> tag.
                          langList.querySelectorAll("li").forEach(function(li) {
                            li.addEventListener("click", function(event) {
                              event.preventDefault();
        
                              let link = this.querySelector("a");
                              if (link && window.location.href !== link.href) {
                                window.location.href = link.href;
                              }
                            });
                          });
                        </script>

                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/arceos-hypervisor/doc" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="概述"><a class="header" href="#概述">概述</a></h2>
<p>AxVisor 是一个基于 <a href="https://github.com/arceos-org/arceos">ArceOS</a> 框架实现的 Hypervisor（也叫 Virtual Machine Manager，VMM）。其目标是利用 ArceOS 提供的基础操作系统功能作为基础实现一个统一的模块化 Hypervisor。</p>
<p><img src="overview/../assets/overview/axvisor.png" alt="AxVisor" /></p>
<p><strong>统一</strong>是指使用同一套代码同时支持 x86_64、AArch64 、RISC-V LoongArch 这四种架构，以最大化复用架构无关代码，简化代码开发和维护成本。</p>
<p><strong>模块化</strong>则是指 Hypervisor 的功能被分解为多个模块，每个模块实现一个特定的功能，模块之间通过标准接口进行通信，以实现功能的解耦和复用。</p>
<style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () => window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () => { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY <200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() => { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () => { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() => { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) => (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) => { btn.addEventListener("click", (event) => { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer><div style="break-before: page; page-break-before: always;"></div><h2 id="硬件平台"><a class="header" href="#硬件平台">硬件平台</a></h2>
<p>AxVisor 被设计为可以在 x86_64、AArch64 、RISC-V LoongArch 四大芯片架构上运行，目前，已经在如下平台进行了验证：</p>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
QEMU ARM64 virt (qemu-max)</li>
<li><input disabled="" type="checkbox" checked=""/>
Rockchip RK3568 / RK3588</li>
<li><input disabled="" type="checkbox" checked=""/>
黑芝麻华山 A1000</li>
<li>更多硬件平台逐步添加中<style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () =&gt; window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () =&gt; { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY &lt;200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() =&gt; { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () =&gt; { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() =&gt; { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) =&gt; (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) =&gt; { btn.addEventListener("click", (event) =&gt; { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="客户机系统支持"><a class="header" href="#客户机系统支持">客户机系统支持</a></h2>
<p>目前，AxVisor 已经在对如下系统作为客户机的情况进行了验证。</p>
<h3 id="arceos"><a class="header" href="#arceos">ArceOS</a></h3>
<p><a href="https://github.com/arceos-org/arceos">ArceOS</a> 是一个用 Rust 编写的专为嵌入式系统和物联网设备设计的轻量级操作系统，提供简单、高效、可定制的功能，适合需要实时响应和低资源开销的应用场景。</p>
<h3 id="starry-os"><a class="header" href="#starry-os">Starry-OS</a></h3>
<p><a href="https://github.com/Starry-OS">Starry-OS</a> 是一款轻量级、模块化且高效的操作系统，专为嵌入式系统和物联网设备设计。它具有实时性支持、跨平台能力以及灵活的定制选项，适合在资源受限的环境中运行。</p>
<h3 id="nimbos"><a class="header" href="#nimbos">NimbOS</a></h3>
<p><a href="https://github.com/equation314/nimbos">NimbOS</a> 是一款用 Rust 编写的专为资源受限环境和嵌入式设备设计的实时操作系统，具有轻量化、实时支持、低功耗、模块化架构等优点。</p>
<h3 id="linux"><a class="header" href="#linux">Linux</a></h3>
<ul>
<li>currently only Linux with passthrough device on aarch64 is tested.</li>
<li>single core: <a href="overview/configs/vms/linux-qemu-aarch64.toml">config.toml</a> | <a href="overview/configs/vms/linux-qemu.dts">dts</a></li>
<li>smp: <a href="overview/configs/vms/linux-qemu-aarch64-smp2.toml">config.toml</a> | <a href="overview/configs/vms/linux-qemu-smp2.dts">dts</a></li>
</ul>
<style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () => window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () => { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY <200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() => { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () => { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() => { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) => (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) => { btn.addEventListener("click", (event) => { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="run-axvisor-on-qemu"><a class="header" href="#run-axvisor-on-qemu">Run AxVisor on QEMU</a></h1>
<p>目前，AxVisor 支持在 <a href="quickstart/qemu/./qemu_aarch64.html">aarch64</a>、<a href="quickstart/qemu/./qemu_x86_64.html">x86_64</a> 以及 <a href="quickstart/qemu/./qemu_riscv64.html">riscv64</a> 三个体系结构下的 QEMU 上运行。</p>
<style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () => window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () => { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY <200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() => { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () => { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() => { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) => (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) => { btn.addEventListener("click", (event) => { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="run-axvisor-on-qemu-aarch64"><a class="header" href="#run-axvisor-on-qemu-aarch64">Run AxVisor on QEMU AArch64</a></h1>
<p>目前，在 QEMU AArch64 平台上已经对独立运行 ArceOS 和 Linux 以及同时运行 ArceOS + Linux 的情况进行了验证。</p>
<h2 id="arceos-1"><a class="header" href="#arceos-1">ArceOS</a></h2>
<h3 id="准备-arceos-镜像"><a class="header" href="#准备-arceos-镜像">准备 ArceOS 镜像</a></h3>
<ol>
<li>
<p>获取 ArceOS 主线代码 <code>git clone https://github.com/arceos-org/arceos.git  </code></p>
</li>
<li>
<p>在 <code>arceos</code> 源码目录中执行 <code>make PLATFORM=aarch64-qemu-virt SMP=1 A=examples/helloworld</code> 获得 <code>examples/helloworld/helloworld_aarch64-qemu-virt.bin</code></p>
</li>
</ol>
<h3 id="从文件系统加载运行"><a class="header" href="#从文件系统加载运行">从文件系统加载运行</a></h3>
<p>获取 AxVisor 主线代码 <code>git clone git@github.com:arceos-hypervisor/axvisor.git</code>，然后在 <code>axvisor</code> 源码目录中执行如下步骤：</p>
<ol>
<li>
<p>制作一个磁盘镜像文件，并将 ArceOS 客户机镜像放到磁盘镜像文件系统中</p>
<ol>
<li>
<p>使用 <code>make disk_img</code> 命令生成一个空的 FAT32 磁盘镜像文件 <code>disk.img</code></p>
</li>
<li>
<p>手动挂载 <code>disk.img</code>，然后将ArceOS 客户机镜像复制到该文件系统中即可</p>
<pre><code class="language-bash">$ mkdir -p tmp
$ sudo mount disk.img tmp
$ sudo cp /path/to/helloworld_aarch64-qemu-virt.bin tmp/
$ sudo umount tmp
</code></pre>
</li>
</ol>
</li>
<li>
<p>修改对应的 <code>./configs/vms/arceos-aarch64.toml</code> 文件中的配置项
<img src="quickstart/qemu/../../assets/quickstart/aarch64_qemu_arceos_config_fs.png" alt="" /></p>
<ul>
<li><code>image_location="fs"</code> 表示从文件系统加载</li>
<li><code>kernel_path</code> 指出内核镜像在文件系统中的路径</li>
<li><code>entry_point</code> 指出内核镜像的入口地址。必须与上面构建的 ArceOS 内核镜像的入口地址一致</li>
<li><code>kernel_load_addr</code> 指出内核镜像的加载地址。默认与 <code>entry_point</code> 一致</li>
<li>其他</li>
</ul>
</li>
<li>
<p>执行 <code>make ACCEL=n ARCH=aarch64 LOG=info VM_CONFIGS=configs/vms/arceos-aarch64.toml FEATURES=page-alloc-64g APP_FEATURES=fs run</code> 构建 AxVisor，并在 QEMU 中启动。</p>
<pre><code class="language-plaintext">       d8888                            .d88888b.   .d8888b.
      d88888                           d88P" "Y88b d88P  Y88b
     d88P888                           888     888 Y88b.
    d88P 888 888d888  .d8888b  .d88b.  888     888  "Y888b.
   d88P  888 888P"   d88P"    d8P  Y8b 888     888     "Y88b.
  d88P   888 888     888      88888888 888     888       "888
 d8888888888 888     Y88b.    Y8b.     Y88b. .d88P Y88b  d88P
d88P     888 888      "Y8888P  "Y8888   "Y88888P"   "Y8888P"

arch = aarch64
platform = aarch64-qemu-virt-hv
target = aarch64-unknown-none-softfloat
build_mode = release
log_level = info
smp = 1

[  0.026671 0 axruntime:130] Logging is enabled.
[  0.030603 0 axruntime:131] Primary CPU 0 started, dtb = 0x48000000.
[  0.032814 0 axruntime:133] Found physcial memory regions:
[  0.037037 0 axruntime:135]   [PA:0x40080000, PA:0x400f7000) .text (READ | EXECUTE | RESERVED)
[  0.042297 0 axruntime:135]   [PA:0x400f7000, PA:0x4010e000) .rodata (READ | RESERVED)
[  0.043895 0 axruntime:135]   [PA:0x4010e000, PA:0x40114000) .data .tdata .tbss .percpu (READ | WRITE | RESERVED)
[  0.045030 0 axruntime:135]   [PA:0x40114000, PA:0x40154000) boot stack (READ | WRITE | RESERVED)
[  0.045793 0 axruntime:135]   [PA:0x40154000, PA:0x4037a000) .bss (READ | WRITE | RESERVED)
[  0.046483 0 axruntime:135]   [PA:0x4037a000, PA:0xc0000000) free memory (READ | WRITE | FREE)
[  0.047186 0 axruntime:135]   [PA:0x9000000, PA:0x9001000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.047848 0 axruntime:135]   [PA:0x9040000, PA:0x9041000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.048408 0 axruntime:135]   [PA:0x9100000, PA:0x9101000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.049346 0 axruntime:135]   [PA:0x8000000, PA:0x8020000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.051424 0 axruntime:135]   [PA:0x80a0000, PA:0x9000000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.054944 0 axruntime:135]   [PA:0xa000000, PA:0xa004000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.056959 0 axruntime:135]   [PA:0x10000000, PA:0x3eff0000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.060560 0 axruntime:135]   [PA:0x4010000000, PA:0x4020000000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.061472 0 axruntime:210] Initialize global memory allocator...
[  0.062434 0 axruntime:211]   use TLSF allocator.
[  0.078002 0 axmm:72] Initialize virtual memory management...
[  0.216673 0 axruntime:150] Initialize platform devices...
[  0.218110 0 axhal::platform::aarch64_common::gic:67] Initialize GICv2...
[  0.221323 0 axtask::api:73] Initialize scheduling...
[  0.226226 0 axtask::api:79]   use FIFO scheduler.
[  0.228036 0 axdriver:152] Initialize device drivers...
[  0.229797 0 axdriver:153]   device model: static
[  0.238770 0 virtio_drivers::device::blk:59] config: 0x1000e000
[  0.241120 0 virtio_drivers::device::blk:64] found a block device of size 65536KB
[  0.244094 0 axdriver::bus::pci:104] registered a new Block device at 00:02.0: "virtio-blk"
[  0.315513 0 axfs:41] Initialize filesystems...
[  0.316784 0 axfs:44]   use block device 0: "virtio-blk"
[  0.412744 0 fatfs::dir:139] Is a directory
[  0.532571 0 fatfs::dir:139] Is a directory
[  0.678550 0 fatfs::dir:139] Is a directory
[  0.800224 0 fatfs::dir:139] Is a directory
[  0.833608 0 axruntime:176] Initialize interrupt handlers...
[  0.835091 0 axruntime:188] Primary CPU 0 init OK.


       d8888            888     888  d8b
      d88888            888     888  Y8P
     d88P888            888     888
    d88P 888  888  888  Y88b   d88P  888  .d8888b    .d88b.   888d888
   d88P  888  `Y8bd8P'   Y88b d88P   888  88K       d88""88b  888P"
  d88P   888    X88K      Y88o88P    888  "Y8888b.  888  888  888
 d8888888888  .d8""8b.     Y888P     888       X88  Y88..88P  888
d88P     888  888  888      Y8P      888   88888P'   "Y88P"   888


by AxVisor Team

[  0.844266 0:2 axvisor:21] Starting virtualization...
[  0.847236 0:2 axvisor:22] Hardware support: true
[  0.851891 0:4 axvisor::vmm::timer:101] Initing HV Timer...
[  0.853759 0:4 axvisor::hal:117] Hardware virtualization support enabled on core 0
[  0.891982 0:2 axvisor::vmm::config:33] Creating VM[1] "arceos"
[  0.895635 0:2 axvm::vm:114] Setting up memory region: [0x40000000~0x41000000] READ | WRITE | EXECUTE
[  0.915957 0:2 axvm::vm:166] Setting up passthrough device memory region: [0x8000000~0x8050000] -&gt; [0x8000000~0x8050000]
[  0.921497 0:2 axvm::vm:166] Setting up passthrough device memory region: [0x9000000~0x9001000] -&gt; [0x9000000~0x9001000]
[  0.925821 0:2 axvm::vm:166] Setting up passthrough device memory region: [0x9010000~0x9011000] -&gt; [0x9010000~0x9011000]
[  0.928866 0:2 axvm::vm:166] Setting up passthrough device memory region: [0x9030000~0x9031000] -&gt; [0x9030000~0x9031000]
[  0.931846 0:2 axvm::vm:166] Setting up passthrough device memory region: [0xa000000~0xa004000] -&gt; [0xa000000~0xa004000]
[  0.936781 0:2 axvm::vm:202] VM[1] created
[  0.938588 0:2 axvm::vm:217] VM[1] vcpus set up
[  0.940546 0:2 axvisor::vmm::config:40] VM[1] created success, loading images...
[  0.943211 0:2 axvisor::vmm::images::fs:116] Loading VM images from filesystem
[  0.997938 0:2 axvisor::vmm:35] Setting up vcpus...
[  0.999510 0:2 axvisor::vmm::vcpus:219] Initializing VM[1]'s 1 vcpus
[  1.001594 0:2 axvisor::vmm::vcpus:250] Spawning task for VM[1] VCpu[0]
[  1.004343 0:2 axvisor::vmm::vcpus:262] VCpu task Task(5, "VM[1]-VCpu[0]") created cpumask: [0, ]
[  1.009453 0:2 axvisor::vmm:43] VMM starting, booting VMs...
[  1.012226 0:2 axvm::vm:284] Booting VM[1]
[  1.013603 0:2 axvisor::vmm:49] VM[1] boot success
[  1.015686 0:2 axvisor::vmm:60] a VM exited, current running VM count: 1
[  1.018355 0:5 axvisor::vmm::vcpus:283] VM[1] VCpu[0] waiting for running
[  1.020426 0:5 axvisor::vmm::vcpus:286] VM[1] VCpu[0] running...

       d8888                            .d88888b.   .d8888b.
      d88888                           d88P" "Y88b d88P  Y88b
     d88P888                           888     888 Y88b.
    d88P 888 888d888  .d8888b  .d88b.  888     888  "Y888b.
   d88P  888 888P"   d88P"    d8P  Y8b 888     888     "Y88b.
  d88P   888 888     888      88888888 888     888       "888
 d8888888888 888     Y88b.    Y8b.     Y88b. .d88P Y88b  d88P
d88P     888 888      "Y8888P  "Y8888   "Y88888P"   "Y8888P"

arch = aarch64
platform = aarch64-qemu-virt
target = aarch64-unknown-none-softfloat
build_mode = release
log_level = warn
smp = 1

Hello, world!
[  1.042124 0:5 axvisor::vmm::vcpus:351] VM[1] run VCpu[0] SystemDown
[  1.043404 0:5 axvm::vm:306] Shutting down VM[1]
[  1.044071 0:5 axvisor::vmm::vcpus:366] VM[1] VCpu[0] shutting down because of VM shutdown
[  1.045588 0:5 axvisor::vmm::vcpus:372] VM[1] VCpu[0] last VCpu exiting, decreasing running VM count
[  1.048335 0:5 axvisor::vmm::vcpus:385] VM[1] VCpu[0] exiting...
[  1.050766 0:2 axvisor::vmm:60] a VM exited, current running VM count: 0
[  1.056315 0:2 axvisor:28] VMM shutdown
[  1.058493 0:2 axhal::platform::aarch64_common::psci:98] Shutting down...
</code></pre>
</li>
</ol>
<h3 id="从内存加载运行"><a class="header" href="#从内存加载运行">从内存加载运行</a></h3>
<p>获取 AxVisor 主线代码 <code>git clone git@github.com:arceos-hypervisor/axvisor.git</code>，然后在 <code>axvisor</code> 源码目录中执行如下步骤：</p>
<ol>
<li>
<p>修改对应的 <code>./configs/vms/arceos-aarch64.toml</code> 中的配置项
<img src="quickstart/qemu/../../assets/quickstart/aarch64_qemu_arceos_config_mem.png" alt="" /></p>
<ul>
<li><code>image_location="memory"</code> 配置项</li>
<li><code>kernel_path</code> 指定内核镜像在工作空间中的相对/绝对路径</li>
<li><code>entry_point</code> 指出内核镜像的入口地址。必须与上面构建的 ArceOS 内核镜像的入口地址一致</li>
<li><code>kernel_load_addr</code> 指出内核镜像的加载地址。默认与 <code>entry_point</code> 一致</li>
<li>其他</li>
</ul>
</li>
<li>
<p>执行 <code>make ACCEL=n ARCH=aarch64 LOG=info VM_CONFIGS=configs/vms/arceos-aarch64.toml FEATURES=page-alloc-64g run</code> 构建 AxVisor，并在 QEMU 中启动。</p>
<pre><code class="language-plaintext">       d8888                            .d88888b.   .d8888b.
      d88888                           d88P" "Y88b d88P  Y88b
     d88P888                           888     888 Y88b.
    d88P 888 888d888  .d8888b  .d88b.  888     888  "Y888b.
   d88P  888 888P"   d88P"    d8P  Y8b 888     888     "Y88b.
  d88P   888 888     888      88888888 888     888       "888
 d8888888888 888     Y88b.    Y8b.     Y88b. .d88P Y88b  d88P
d88P     888 888      "Y8888P  "Y8888   "Y88888P"   "Y8888P"

arch = aarch64
platform = aarch64-qemu-virt-hv
target = aarch64-unknown-none-softfloat
build_mode = release
log_level = info
smp = 1

[  0.021736 0 axruntime:130] Logging is enabled.
[  0.025410 0 axruntime:131] Primary CPU 0 started, dtb = 0x48000000.
[  0.027128 0 axruntime:133] Found physcial memory regions:
[  0.028879 0 axruntime:135]   [PA:0x40080000, PA:0x400d8000) .text (READ | EXECUTE | RESERVED)
[  0.031793 0 axruntime:135]   [PA:0x400d8000, PA:0x400f2000) .rodata (READ | RESERVED)
[  0.036048 0 axruntime:135]   [PA:0x400f2000, PA:0x400f8000) .data .tdata .tbss .percpu (READ | WRITE | RESERVED)
[  0.038951 0 axruntime:135]   [PA:0x400f8000, PA:0x40138000) boot stack (READ | WRITE | RESERVED)
[  0.040153 0 axruntime:135]   [PA:0x40138000, PA:0x4035e000) .bss (READ | WRITE | RESERVED)
[  0.042131 0 axruntime:135]   [PA:0x4035e000, PA:0xc0000000) free memory (READ | WRITE | FREE)
[  0.043906 0 axruntime:135]   [PA:0x9000000, PA:0x9001000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.045526 0 axruntime:135]   [PA:0x9040000, PA:0x9041000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.047555 0 axruntime:135]   [PA:0x9100000, PA:0x9101000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.051030 0 axruntime:135]   [PA:0x8000000, PA:0x8020000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.056637 0 axruntime:135]   [PA:0x80a0000, PA:0x9000000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.060144 0 axruntime:135]   [PA:0xa000000, PA:0xa004000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.062063 0 axruntime:135]   [PA:0x10000000, PA:0x3eff0000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.063681 0 axruntime:135]   [PA:0x4010000000, PA:0x4020000000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.066328 0 axruntime:210] Initialize global memory allocator...
[  0.068462 0 axruntime:211]   use TLSF allocator.
[  0.077102 0 axmm:72] Initialize virtual memory management...
[  0.226528 0 axruntime:150] Initialize platform devices...
[  0.228998 0 axhal::platform::aarch64_common::gic:67] Initialize GICv2...
[  0.234025 0 axtask::api:73] Initialize scheduling...
[  0.238040 0 axtask::api:79]   use FIFO scheduler.
[  0.239553 0 axruntime:176] Initialize interrupt handlers...
[  0.244411 0 axruntime:188] Primary CPU 0 init OK.


       d8888            888     888  d8b
      d88888            888     888  Y8P
     d88P888            888     888
    d88P 888  888  888  Y88b   d88P  888  .d8888b    .d88b.   888d888
   d88P  888  `Y8bd8P'   Y88b d88P   888  88K       d88""88b  888P"
  d88P   888    X88K      Y88o88P    888  "Y8888b.  888  888  888
 d8888888888  .d8""8b.     Y888P     888       X88  Y88..88P  888
d88P     888  888  888      Y8P      888   88888P'   "Y88P"   888


by AxVisor Team

[  0.263070 0:2 axvisor:21] Starting virtualization...
[  0.264035 0:2 axvisor:22] Hardware support: true
[  0.268266 0:4 axvisor::vmm::timer:101] Initing HV Timer...
[  0.270992 0:4 axvisor::hal:117] Hardware virtualization support enabled on core 0
[  0.324476 0:2 axvisor::vmm::config:33] Creating VM[1] "arceos"
[  0.328098 0:2 axvm::vm:114] Setting up memory region: [0x40000000~0x41000000] READ | WRITE | EXECUTE
[  0.335931 0:2 axvm::vm:166] Setting up passthrough device memory region: [0x8000000~0x8050000] -&gt; [0x8000000~0x8050000]
[  0.338925 0:2 axvm::vm:166] Setting up passthrough device memory region: [0x9000000~0x9001000] -&gt; [0x9000000~0x9001000]
[  0.341417 0:2 axvm::vm:166] Setting up passthrough device memory region: [0x9010000~0x9011000] -&gt; [0x9010000~0x9011000]
[  0.344477 0:2 axvm::vm:166] Setting up passthrough device memory region: [0x9030000~0x9031000] -&gt; [0x9030000~0x9031000]
[  0.348120 0:2 axvm::vm:166] Setting up passthrough device memory region: [0xa000000~0xa004000] -&gt; [0xa000000~0xa004000]
[  0.352530 0:2 axvm::vm:202] VM[1] created
[  0.354438 0:2 axvm::vm:217] VM[1] vcpus set up
[  0.356409 0:2 axvisor::vmm::config:40] VM[1] created success, loading images...
[  0.359031 0:2 axvisor::vmm::images:26] Loading VM[1] images from memory
[  0.376919 0:2 axvisor::vmm:35] Setting up vcpus...
[  0.380177 0:2 axvisor::vmm::vcpus:219] Initializing VM[1]'s 1 vcpus
[  0.383394 0:2 axvisor::vmm::vcpus:250] Spawning task for VM[1] VCpu[0]
[  0.388556 0:2 axvisor::vmm::vcpus:262] VCpu task Task(5, "VM[1]-VCpu[0]") created cpumask: [0, ]
[  0.394718 0:2 axvisor::vmm:43] VMM starting, booting VMs...
[  0.396902 0:2 axvm::vm:284] Booting VM[1]
[  0.398535 0:2 axvisor::vmm:49] VM[1] boot success
[  0.399462 0:2 axvisor::vmm:60] a VM exited, current running VM count: 1
[  0.402424 0:5 axvisor::vmm::vcpus:283] VM[1] VCpu[0] waiting for running
[  0.409453 0:5 axvisor::vmm::vcpus:286] VM[1] VCpu[0] running...

       d8888                            .d88888b.   .d8888b.
      d88888                           d88P" "Y88b d88P  Y88b
     d88P888                           888     888 Y88b.
    d88P 888 888d888  .d8888b  .d88b.  888     888  "Y888b.
   d88P  888 888P"   d88P"    d8P  Y8b 888     888     "Y88b.
  d88P   888 888     888      88888888 888     888       "888
 d8888888888 888     Y88b.    Y8b.     Y88b. .d88P Y88b  d88P
d88P     888 888      "Y8888P  "Y8888   "Y88888P"   "Y8888P"

arch = aarch64
platform = aarch64-qemu-virt
target = aarch64-unknown-none-softfloat
build_mode = release
log_level = warn
smp = 1

Hello, world!
[  0.432406 0:5 axvisor::vmm::vcpus:351] VM[1] run VCpu[0] SystemDown
[  0.434339 0:5 axvm::vm:306] Shutting down VM[1]
[  0.436329 0:5 axvisor::vmm::vcpus:366] VM[1] VCpu[0] shutting down because of VM shutdown
[  0.438751 0:5 axvisor::vmm::vcpus:372] VM[1] VCpu[0] last VCpu exiting, decreasing running VM count
[  0.441505 0:5 axvisor::vmm::vcpus:385] VM[1] VCpu[0] exiting...
[  0.446299 0:2 axvisor::vmm:60] a VM exited, current running VM count: 0
[  0.449252 0:2 axvisor:28] VMM shutdown
[  0.452352 0:2 axhal::platform::aarch64_common::psci:98] Shutting down...
</code></pre>
</li>
</ol>
<h2 id="nimbos-1"><a class="header" href="#nimbos-1">NimbOS</a></h2>
<h3 id="准备-nimbos-镜像"><a class="header" href="#准备-nimbos-镜像">准备 NimbOS 镜像</a></h3>
<p><a href="https://github.com/arceos-hypervisor/nimbos">NimbOS</a> 仓库的 <a href="https://github.com/arceos-hypervisor/nimbos/releases/">release</a> 页面已经编译生成了可以直接运行的 NimbOS 二进制镜像文件压缩包：</p>
<ul>
<li>不带 <code>_usertests</code> 后缀的 NimbOS 二进制镜像包中编译的 NimbOS 启动后会进入 NimbOS 的 shell，本示例启动的就是这个 NimbOS</li>
<li>带 <code>usertests</code> 后缀的 NimbOS 二进制镜像压缩包中编译的 NimbOS 启动后会自动运行用户态测例用于测试，这个镜像用于 AxVisor 的CI测试，见 <a href="https://github.com/arceos-hypervisor/axvisor/blob/master/.github/workflows/actions/setup-nimbos-guest-image/action.yml">setup-nimbos-guest-image/action.yml</a></li>
</ul>
<h3 id="从文件系统加载运行-1"><a class="header" href="#从文件系统加载运行-1">从文件系统加载运行</a></h3>
<p>获取 AxVisor 主线代码 <code>git clone git@github.com:arceos-hypervisor/axvisor.git</code>，然后在 <code>axvisor</code> 源码目录中执行如下步骤：</p>
<ol>
<li>
<p>制作一个磁盘镜像文件，并将客户机镜像放到文件系统中</p>
<ol>
<li>
<p>使用 <code>make disk_img</code> 命令生成一个空的 FAT32 磁盘镜像文件 <code>disk.img</code></p>
</li>
<li>
<p>手动挂载 <code>disk.img</code>，然后拉取并解压二进制镜像</p>
<pre><code class="language-bash">$ mkdir -p tmp
$ sudo mount disk.img tmp
$ wget https://github.com/arceos-hypervisor/nimbos/releases/download/v0.7/aarch64.zip  
$ unzip aarch64.zip # 得到 nimbos.bin
$ sudo mv nimbos.bin tmp/nimbos-aarch64.bin
$ sudo umount tmp
</code></pre>
</li>
</ol>
</li>
<li>
<p>直接使用 <a href="https://github.com/arceos-hypervisor/axvisor/blob/master/configs/vms/nimbos-aarch64.toml"><code>configs/vms/nimbos-aarch64.toml</code></a> 文件中的配置项</p>
<ul>
<li><code>image_location="fs"</code> 表示从文件系统加载</li>
<li><code>kernel_path</code> 指出内核镜像在文件系统中的路径</li>
<li><code>entry_point</code> 指出内核镜像的入口地址</li>
<li><code>kernel_load_addr</code> 指出内核镜像的加载地址</li>
</ul>
</li>
<li>
<p>执行 <code>make ACCEL=n ARCH=aarch64 LOG=info VM_CONFIGS=configs/vms/nimbos-aarch64.toml FEATURES=page-alloc-64g APP_FEATURES=fs defconfig</code> 创建 <code>.axconfig.toml</code> 配置文件</p>
</li>
<li>
<p>执行 <code>make ACCEL=n ARCH=aarch64 LOG=info VM_CONFIGS=configs/vms/nimbos-aarch64.toml FEATURES=page-alloc-64g APP_FEATURES=fs run</code> 构建 AxVisor，并在 QEMU 中启动。</p>
<pre><code class="language-plaintext">       d8888                            .d88888b.   .d8888b.
      d88888                           d88P" "Y88b d88P  Y88b
     d88P888                           888     888 Y88b.
    d88P 888 888d888  .d8888b  .d88b.  888     888  "Y888b.
   d88P  888 888P"   d88P"    d8P  Y8b 888     888     "Y88b.
  d88P   888 888     888      88888888 888     888       "888
 d8888888888 888     Y88b.    Y8b.     Y88b. .d88P Y88b  d88P
d88P     888 888      "Y8888P  "Y8888   "Y88888P"   "Y8888P"

arch = aarch64
platform = aarch64-qemu-virt-hv
target = aarch64-unknown-none-softfloat
build_mode = release
log_level = info
smp = 1

[  0.017358 0 axruntime:130] Logging is enabled.
[  0.020237 0 axruntime:131] Primary CPU 0 started, dtb = 0x48000000.
[  0.022423 0 axruntime:133] Found physcial memory regions:
[  0.024923 0 axruntime:135]   [PA:0x40080000, PA:0x400f7000) .text (READ | EXECUTE | RESERVED)
[  0.028044 0 axruntime:135]   [PA:0x400f7000, PA:0x4010e000) .rodata (READ | RESERVED)
[  0.030818 0 axruntime:135]   [PA:0x4010e000, PA:0x40114000) .data .tdata .tbss .percpu (READ | WRITE | RESERVED)
[  0.033700 0 axruntime:135]   [PA:0x40114000, PA:0x40154000) boot stack (READ | WRITE | RESERVED)
[  0.038044 0 axruntime:135]   [PA:0x40154000, PA:0x4037a000) .bss (READ | WRITE | RESERVED)
[  0.038980 0 axruntime:135]   [PA:0x4037a000, PA:0xc0000000) free memory (READ | WRITE | FREE)
[  0.039887 0 axruntime:135]   [PA:0x9000000, PA:0x9001000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.041603 0 axruntime:135]   [PA:0x9040000, PA:0x9041000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.045329 0 axruntime:135]   [PA:0x9100000, PA:0x9101000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.047721 0 axruntime:135]   [PA:0x8000000, PA:0x8020000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.050294 0 axruntime:135]   [PA:0x80a0000, PA:0x9000000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.053455 0 axruntime:135]   [PA:0xa000000, PA:0xa004000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.055847 0 axruntime:135]   [PA:0x10000000, PA:0x3eff0000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.058813 0 axruntime:135]   [PA:0x4010000000, PA:0x4020000000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.061287 0 axruntime:210] Initialize global memory allocator...
[  0.062252 0 axruntime:211]   use TLSF allocator.
[  0.067413 0 axmm:72] Initialize virtual memory management...
[  0.229795 0 axruntime:150] Initialize platform devices...
[  0.230852 0 axhal::platform::aarch64_common::gic:67] Initialize GICv2...
[  0.233016 0 axtask::api:73] Initialize scheduling...
[  0.235781 0 axtask::api:79]   use FIFO scheduler.
[  0.239722 0 axdriver:152] Initialize device drivers...
[  0.241492 0 axdriver:153]   device model: static
[  0.252691 0 virtio_drivers::device::blk:59] config: 0x1000e000
[  0.254267 0 virtio_drivers::device::blk:64] found a block device of size 65536KB
[  0.256890 0 axdriver::bus::pci:104] registered a new Block device at 00:02.0: "virtio-blk"
[  0.351956 0 axfs:41] Initialize filesystems...
[  0.353143 0 axfs:44]   use block device 0: "virtio-blk"
[  0.452998 0 fatfs::dir:139] Is a directory
[  0.557418 0 fatfs::dir:139] Is a directory
[  0.677986 0 fatfs::dir:139] Is a directory
[  0.911611 0 fatfs::dir:139] Is a directory
[  0.967468 0 axruntime:176] Initialize interrupt handlers...
[  0.970658 0 axruntime:188] Primary CPU 0 init OK.


       d8888            888     888  d8b
      d88888            888     888  Y8P
     d88P888            888     888
    d88P 888  888  888  Y88b   d88P  888  .d8888b    .d88b.   888d888
   d88P  888  `Y8bd8P'   Y88b d88P   888  88K       d88""88b  888P"
  d88P   888    X88K      Y88o88P    888  "Y8888b.  888  888  888
 d8888888888  .d8""8b.     Y888P     888       X88  Y88..88P  888
d88P     888  888  888      Y8P      888   88888P'   "Y88P"   888


by AxVisor Team

[  0.990150 0:2 axvisor:21] Starting virtualization...
[  0.992917 0:2 axvisor:22] Hardware support: true
[  0.999955 0:4 axvisor::vmm::timer:101] Initing HV Timer...
[  1.005799 0:4 axvisor::hal:117] Hardware virtualization support enabled on core 0
[  1.081310 0:2 axvisor::vmm::config:33] Creating VM[1] "nimbos"
[  1.087214 0:2 axvm::vm:114] Setting up memory region: [0x40000000~0x41000000] READ | WRITE | EXECUTE
[  1.102990 0:2 axvm::vm:166] Setting up passthrough device memory region: [0x8000000~0x8050000] -&gt; [0x8000000~0x8050000]
[  1.107111 0:2 axvm::vm:166] Setting up passthrough device memory region: [0x9000000~0x9001000] -&gt; [0x9000000~0x9001000]
[  1.111516 0:2 axvm::vm:166] Setting up passthrough device memory region: [0x9010000~0x9011000] -&gt; [0x9010000~0x9011000]
[  1.112354 0:2 axvm::vm:166] Setting up passthrough device memory region: [0x9030000~0x9031000] -&gt; [0x9030000~0x9031000]
[  1.113297 0:2 axvm::vm:166] Setting up passthrough device memory region: [0xa000000~0xa004000] -&gt; [0xa000000~0xa004000]
[  1.114584 0:2 axvm::vm:202] VM[1] created
[  1.115408 0:2 axvm::vm:217] VM[1] vcpus set up
[  1.116129 0:2 axvisor::vmm::config:40] VM[1] created success, loading images...
[  1.116955 0:2 axvisor::vmm::images::fs:116] Loading VM images from filesystem
[  1.591307 0:2 axvisor::vmm:35] Setting up vcpus...
[  1.593441 0:2 axvisor::vmm::vcpus:219] Initializing VM[1]'s 1 vcpus
[  1.595262 0:2 axvisor::vmm::vcpus:250] Spawning task for VM[1] VCpu[0]
[  1.597567 0:2 axvisor::vmm::vcpus:262] VCpu task Task(5, "VM[1]-VCpu[0]") created cpumask: [0, ]
[  1.600783 0:2 axvisor::vmm:43] VMM starting, booting VMs...
[  1.603577 0:2 axvm::vm:284] Booting VM[1]
[  1.604905 0:2 axvisor::vmm:49] VM[1] boot success
[  1.606867 0:2 axvisor::vmm:60] a VM exited, current running VM count: 1
[  1.610160 0:5 axvisor::vmm::vcpus:283] VM[1] VCpu[0] waiting for running
[  1.615593 0:5 axvisor::vmm::vcpus:286] VM[1] VCpu[0] running...

NN   NN  iii               bb        OOOOO    SSSSS
NNN  NN       mm mm mmmm   bb       OO   OO  SS
NN N NN  iii  mmm  mm  mm  bbbbbb   OO   OO   SSSSS
NN  NNN  iii  mmm  mm  mm  bb   bb  OO   OO       SS
NN   NN  iii  mmm  mm  mm  bbbbbb    OOOO0    SSSSS
              ___    ____    ___    ___
             |__ \  / __ \  |__ \  |__ \
             __/ / / / / /  __/ /  __/ /
            / __/ / /_/ /  / __/  / __/
           /____/ \____/  /____/ /____/

arch = aarch64
platform = qemu-virt-arm
build_mode = release
log_level = warn

Initializing kernel heap at: [0xffff0000401100e0, 0xffff0000405100e0)
Initializing frame allocator at: [PA:0x40511000, PA:0x48000000)
Mapping .text: [0xffff000040080000, 0xffff000040094000)
Mapping .rodata: [0xffff000040094000, 0xffff00004009b000)
Mapping .data: [0xffff00004009b000, 0xffff00004010a000)
Mapping .bss: [0xffff00004010e000, 0xffff000040511000)
Mapping boot stack: [0xffff00004010a000, 0xffff00004010e000)
Mapping physical memory: [0xffff000040511000, 0xffff000048000000)
Mapping MMIO: [0xffff000009000000, 0xffff000009001000)
Mapping MMIO: [0xffff000008000000, 0xffff000008020000)
Initializing drivers...
Initializing task manager...
/**** APPS ****
cyclictest
exit
fantastic_text
forktest
forktest2
forktest_simple
forktest_simple_c
forktree
hello_c
hello_world
matrix
poweroff
sleep
sleep_simple
stack_overflow
thread_simple
user_shell
usertests
yield
**************/
Running tasks...
test kernel task: pid = TaskId(2), arg = 0xdead
test kernel task: pid = TaskId(3), arg = 0xbeef
Rust user shell
&gt;&gt; 
</code></pre>
</li>
</ol>
<h3 id="从内存中加载运行"><a class="header" href="#从内存中加载运行">从内存中加载运行</a></h3>
<p>参考别的 guest VM 的运行指导，修改对应的 <code>./configs/vms/nimbos-aarch64.toml</code> 中的配置项即可：</p>
<ul>
<li>将 <code>image_location</code> 配置项修改为 <code>image_location="memory"</code></li>
<li>并设置 <code>kernel_path</code> 为 nimbos 二进制内核镜像在工作空间中的相对/绝对路径</li>
</ul>
<h2 id="linux-1"><a class="header" href="#linux-1">Linux</a></h2>
<h3 id="准备-linux-镜像"><a class="header" href="#准备-linux-镜像">准备 Linux 镜像</a></h3>
<ol>
<li>
<p>获取 Linux 主线代码 <code>git clone git@github.com:arceos-hypervisor/linux-6.2.0.git</code></p>
</li>
<li>
<p>在 Linux 源码目录中执行 <code>make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- defconfig</code>，再执行 <code>make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- -j$(nproc)</code> 以获取 <code>Image</code></p>
</li>
</ol>
<h3 id="从文件系统加载运行-2"><a class="header" href="#从文件系统加载运行-2">从文件系统加载运行</a></h3>
<p>获取 AxVisor 主线代码 <code>git clone git@github.com:arceos-hypervisor/axvisor.git</code>，<strong>（axvisor通过fs启动linux暂未合并主线，若想尝试可切换至dev/dyn分支）</strong>，然后在 <code>axvisor</code> 源码目录中执行如下步骤：</p>
<ol>
<li>
<p>执行 <code>dtc -I dts -O dtb -o linux-qemu.dtb configs/vms/linux-qemu.dts</code> 编译 Linux 客户机需要使用的设备树文件 <code>linux-qemu.dtb</code></p>
</li>
<li>
<p>执行 <code>make ubuntu_img ARCH=aarch64</code> 制作一个简单的根文件系统镜像 <code>disk.img</code> 作为 Linux 客户机启动之后的文件系统，然后手动挂载 <code>disk.img</code>，然后将 Image 和 linux-qemu.dtb 复制到该文件系统中</p>
<pre><code class="language-bash">$ mkdir -p tmp
$ sudo mount disk.img tmp
$ sudo cp /path/to/Image tmp/boot/
$ sudo cp linux-qemu.dtb tmp/boot/
$ sudo umount tmp
</code></pre>
</li>
<li>
<p>修改对应的 <code>./configs/vms/linux-qemu-aarch64.toml</code> 文件中的配置项
<img src="quickstart/qemu/../../assets/quickstart/aarch64_qemu_linux_config_fs.png" alt="" /></p>
<ul>
<li><code>image_location="fs"</code> 表示从文件系统加载</li>
<li><code>kernel_path</code> 指出内核镜像在文件系统中的路径</li>
<li><code>entry_point</code> 指出内核镜像的入口地址</li>
<li><code>kernel_load_addr</code> 指出内核镜像的加载地址</li>
<li>其他</li>
</ul>
</li>
<li>
<p>执行 <code>make ARCH=aarch64 VM_CONFIGS=configs/vms/linux-qemu-aarch64.toml LOG=info NET=y FEATURES=page-alloc-64g,bus-mmio,ext4fs BUS=mmio APP_FEATURES=fs MEM=8g BLK=y run</code> 构建 AxVisor，并在 QEMU 中启动。</p>
<pre><code class="language-palintext">       d8888                            .d88888b.   .d8888b.
      d88888                           d88P" "Y88b d88P  Y88b
     d88P888                           888     888 Y88b.
    d88P 888 888d888  .d8888b  .d88b.  888     888  "Y888b.
   d88P  888 888P"   d88P"    d8P  Y8b 888     888     "Y88b.
  d88P   888 888     888      88888888 888     888       "888
 d8888888888 888     Y88b.    Y8b.     Y88b. .d88P Y88b  d88P
d88P     888 888      "Y8888P  "Y8888   "Y88888P"   "Y8888P"

arch = aarch64
platform = aarch64-qemu-virt-hv
target = aarch64-unknown-none-softfloat
build_mode = release
log_level = info
smp = 1

[  0.013162 0 axruntime:138] Logging is enabled.
[  0.015679 0 axruntime:139] Primary CPU 0 started, dtb = 0x0.
[  0.016604 0 axruntime:141] Found physcial memory regions:
[  0.017544 0 axruntime:143]   [PA:0x40080000, PA:0x40106000) .text (READ | EXECUTE | RESERVED)
[  0.018877 0 axruntime:143]   [PA:0x40106000, PA:0x4011b000) .rodata (READ | RESERVED)
[  0.019466 0 axruntime:143]   [PA:0x4011b000, PA:0x40121000) .data .tdata .tbss .percpu (READ | WRITE | RESERVED)
[  0.020087 0 axruntime:143]   [PA:0x40121000, PA:0x40161000) boot stack (READ | WRITE | RESERVED)
[  0.020666 0 axruntime:143]   [PA:0x40161000, PA:0x40389000) .bss (READ | WRITE | RESERVED)
[  0.021225 0 axruntime:143]   [PA:0x40389000, PA:0xc0000000) free memory (READ | WRITE | FREE)
[  0.021842 0 axruntime:143]   [PA:0x9000000, PA:0x9001000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.022416 0 axruntime:143]   [PA:0x9040000, PA:0x9041000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.022988 0 axruntime:143]   [PA:0x9100000, PA:0x9101000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.023525 0 axruntime:143]   [PA:0x8000000, PA:0x8020000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.024022 0 axruntime:143]   [PA:0x80a0000, PA:0x9000000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.024570 0 axruntime:143]   [PA:0xa000000, PA:0xa004000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.025100 0 axruntime:143]   [PA:0x10000000, PA:0x3eff0000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.025616 0 axruntime:143]   [PA:0x4010000000, PA:0x4020000000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.026345 0 axruntime:224] Initialize global memory allocator...
[  0.026857 0 axruntime:225]   use TLSF allocator.
[  0.033519 0 axmm:72] Initialize virtual memory management...
[  0.504984 0 axruntime:158] Initialize platform devices...
[  0.505498 0 axhal::platform::aarch64_common::gic:67] Initialize GICv2...
[  0.507939 0 axtask::api:73] Initialize scheduling...
[  0.510938 0:2 axtask::api:79]   use FIFO scheduler.
[  0.511810 0:2 axdriver:172] Initialize device drivers...
[  0.512378 0:2 axdriver:173]   device model: static
[  0.514269 0:2 virtio_drivers::device::blk:59] config: 0xa003f00
[  0.515180 0:2 virtio_drivers::device::blk:64] found a block device of size 131072KB
[  0.517593 0:2 axdriver::bus::mmio:12] registered a new Block device at [PA:0xa003e00, PA:0xa004000): "virtio-blk"
[  0.520378 0:2 axfs:41] Initialize filesystems...
[  0.521220 0:2 axfs:44]   use block device 0: "virtio-blk"
[  0.522481 0:2 axfs::fs::ext4fs:32] Got Disk size:134217728, position:0
[  0.524183 0:2 lwext4_rust::blockdev:92] New an Ext4 Block Device
[  0.529566 0:2 lwext4_rust::ulibc:30] [lwext4] "%s"
[  0.530555 0:2 lwext4_rust::ulibc:30] [lwext4] "l: %d   "
[  0.530947 0:2 lwext4_rust::ulibc:30] [lwext4] "[info]  sblock features_incompatible:\n"
[  0.531805 0:2 lwext4_rust::ulibc:30] [lwext4] "%s"
[  0.532208 0:2 lwext4_rust::ulibc:30] [lwext4] "l: %d   "
[  0.532594 0:2 lwext4_rust::ulibc:30] [lwext4] "filetype\n"
[  0.533054 0:2 lwext4_rust::ulibc:30] [lwext4] "%s"
[  0.533502 0:2 lwext4_rust::ulibc:30] [lwext4] "l: %d   "
[  0.533893 0:2 lwext4_rust::ulibc:30] [lwext4] "recover\n"
[  0.534400 0:2 lwext4_rust::ulibc:30] [lwext4] "%s"
[  0.534766 0:2 lwext4_rust::ulibc:30] [lwext4] "l: %d   "
[  0.535195 0:2 lwext4_rust::ulibc:30] [lwext4] "extents\n"
[  0.535701 0:2 lwext4_rust::ulibc:30] [lwext4] "%s"
[  0.536078 0:2 lwext4_rust::ulibc:30] [lwext4] "l: %d   "
[  0.536482 0:2 lwext4_rust::ulibc:30] [lwext4] "64bit\n"
[  0.536939 0:2 lwext4_rust::ulibc:30] [lwext4] "%s"
[  0.537339 0:2 lwext4_rust::ulibc:30] [lwext4] "l: %d   "
[  0.537759 0:2 lwext4_rust::ulibc:30] [lwext4] "flex_bg\n"
[  0.538313 0:2 lwext4_rust::ulibc:30] [lwext4] "%s"
[  0.538675 0:2 lwext4_rust::ulibc:30] [lwext4] "l: %d   "
[  0.539085 0:2 lwext4_rust::ulibc:30] [lwext4] "[info]  sblock features_compatible:\n"
[  0.539713 0:2 lwext4_rust::ulibc:30] [lwext4] "%s"
[  0.540078 0:2 lwext4_rust::ulibc:30] [lwext4] "l: %d   "
[  0.540551 0:2 lwext4_rust::ulibc:30] [lwext4] "has_journal\n"
[  0.541104 0:2 lwext4_rust::ulibc:30] [lwext4] "%s"
[  0.541483 0:2 lwext4_rust::ulibc:30] [lwext4] "l: %d   "
[  0.541868 0:2 lwext4_rust::ulibc:30] [lwext4] "ext_attr\n"
[  0.542354 0:2 lwext4_rust::ulibc:30] [lwext4] "%s"
[  0.542734 0:2 lwext4_rust::ulibc:30] [lwext4] "l: %d   "
[  0.543156 0:2 lwext4_rust::ulibc:30] [lwext4] "resize_inode\n"
[  0.543627 0:2 lwext4_rust::ulibc:30] [lwext4] "%s"
[  0.543992 0:2 lwext4_rust::ulibc:30] [lwext4] "l: %d   "
[  0.544421 0:2 lwext4_rust::ulibc:30] [lwext4] "dir_index\n"
[  0.544877 0:2 lwext4_rust::ulibc:30] [lwext4] "%s"
[  0.545281 0:2 lwext4_rust::ulibc:30] [lwext4] "l: %d   "
[  0.545705 0:2 lwext4_rust::ulibc:30] [lwext4] "[info]  sblock features_read_only:\n"
[  0.546335 0:2 lwext4_rust::ulibc:30] [lwext4] "%s"
[  0.546702 0:2 lwext4_rust::ulibc:30] [lwext4] "l: %d   "
[  0.547112 0:2 lwext4_rust::ulibc:30] [lwext4] "sparse_super\n"
[  0.547605 0:2 lwext4_rust::ulibc:30] [lwext4] "%s"
[  0.547969 0:2 lwext4_rust::ulibc:30] [lwext4] "l: %d   "
[  0.548393 0:2 lwext4_rust::ulibc:30] [lwext4] "large_file\n"
[  0.548872 0:2 lwext4_rust::ulibc:30] [lwext4] "%s"
[  0.549274 0:2 lwext4_rust::ulibc:30] [lwext4] "l: %d   "
[  0.549665 0:2 lwext4_rust::ulibc:30] [lwext4] "huge_file\n"
[  0.550143 0:2 lwext4_rust::ulibc:30] [lwext4] "%s"
[  0.550545 0:2 lwext4_rust::ulibc:30] [lwext4] "l: %d   "
[  0.550946 0:2 lwext4_rust::ulibc:30] [lwext4] "dir_nlink\n"
[  0.551426 0:2 lwext4_rust::ulibc:30] [lwext4] "%s"
[  0.551799 0:2 lwext4_rust::ulibc:30] [lwext4] "l: %d   "
[  0.552222 0:2 lwext4_rust::ulibc:30] [lwext4] "extra_isize\n"
[  0.552715 0:2 lwext4_rust::ulibc:30] [lwext4] "%s"
[  0.553102 0:2 lwext4_rust::ulibc:30] [lwext4] "l: %d   "
[  0.553508 0:2 lwext4_rust::ulibc:30] [lwext4] "metadata_csum\n"
[  0.554162 0:2 lwext4_rust::ulibc:30] [lwext4] "%s"
[  0.554529 0:2 lwext4_rust::ulibc:30] [lwext4] "l: %d   "
[  0.554920 0:2 lwext4_rust::ulibc:30] [lwext4] "[warn]  last umount error: superblock fs_error flag\n"
[  0.566532 0:2 lwext4_rust::blockdev:253] lwext4 mount Okay
[  0.567385 0:2 lwext4_rust::blockdev:305] ls /
[  0.571443 0:2 lwext4_rust::blockdev:314]   [dir] .
[  0.573053 0:2 lwext4_rust::blockdev:314]   [dir] ..
[  0.574654 0:2 lwext4_rust::blockdev:314]   [dir] lost+found
[  0.576296 0:2 lwext4_rust::blockdev:314]   [sym] bin
[  0.577923 0:2 lwext4_rust::blockdev:314]   [dir] boot
[  0.579488 0:2 lwext4_rust::blockdev:314]   [dir] dev
[  0.581040 0:2 lwext4_rust::blockdev:314]   [dir] etc
[  0.582666 0:2 lwext4_rust::blockdev:314]   [dir] home
[  0.584204 0:2 lwext4_rust::blockdev:314]   [sym] lib
[  0.585737 0:2 lwext4_rust::blockdev:314]   [dir] media
[  0.587274 0:2 lwext4_rust::blockdev:314]   [dir] mnt
[  0.588833 0:2 lwext4_rust::blockdev:314]   [dir] opt
[  0.590387 0:2 lwext4_rust::blockdev:314]   [dir] proc
[  0.591939 0:2 lwext4_rust::blockdev:314]   [dir] root
[  0.593504 0:2 lwext4_rust::blockdev:314]   [dir] run
[  0.595051 0:2 lwext4_rust::blockdev:314]   [sym] sbin
[  0.596602 0:2 lwext4_rust::blockdev:314]   [dir] srv
[  0.598166 0:2 lwext4_rust::blockdev:314]   [dir] sys
[  0.599712 0:2 lwext4_rust::blockdev:314]   [dir] tmp
[  0.601248 0:2 lwext4_rust::blockdev:314]   [dir] usr
[  0.602790 0:2 lwext4_rust::blockdev:314]   [dir] var
[  0.604414 0:2 lwext4_rust::blockdev:314]   [fil] Image
[  0.606103 0:2 lwext4_rust::blockdev:314]   [fil] linux-qemu.dtb
[  0.607868 0:2 lwext4_rust::blockdev:323] 
[  0.608619 0:2 lwext4_rust::blockdev:342] ********************
[  0.609150 0:2 lwext4_rust::blockdev:343] ext4_mount_point_stats
[  0.609745 0:2 lwext4_rust::blockdev:344] inodes_count = 8000
[  0.610494 0:2 lwext4_rust::blockdev:345] free_inodes_count = 724c
[  0.611075 0:2 lwext4_rust::blockdev:346] blocks_count = 8000
[  0.611805 0:2 lwext4_rust::blockdev:347] free_blocks_count = 3eb
[  0.612380 0:2 lwext4_rust::blockdev:348] block_size = 1000
[  0.612937 0:2 lwext4_rust::blockdev:349] block_group_count = 1
[  0.613507 0:2 lwext4_rust::blockdev:350] blocks_per_group= 8000
[  0.614075 0:2 lwext4_rust::blockdev:351] inodes_per_group = 8000
[  0.614673 0:2 lwext4_rust::blockdev:354] volume_name = ""
[  0.615183 0:2 lwext4_rust::blockdev:355] ********************

[  0.615712 0:2 lwext4_rust::blockdev:362] ********************
[  0.616245 0:2 lwext4_rust::blockdev:363] ext4 blockdev stats
[  0.616805 0:2 lwext4_rust::blockdev:365] bdev-&gt;bread_ctr = 6
[  0.617524 0:2 lwext4_rust::blockdev:366] bdev-&gt;bwrite_ctr = 3
[  0.618074 0:2 lwext4_rust::blockdev:368] bcache-&gt;ref_blocks = 3
[  0.618625 0:2 lwext4_rust::blockdev:369] bcache-&gt;max_ref_blocks = 3
[  0.619189 0:2 lwext4_rust::blockdev:373] bcache-&gt;lru_ctr = 52
[  0.619769 0:2 lwext4_rust::blockdev:375] ********************

[  0.620526 0:2 axfs::fs::ext4fs:62] FileWrapper new EXT4_DE_DIR /
[  0.623755 0:2 axfs::fs::ext4fs:142] create Dir on Ext4fs: /dev
[  0.624463 0:2 axfs::fs::ext4fs:70] path_deal_with: /dev
[  0.627211 0:2 axfs::fs::ext4fs:89] dealt with full path: /dev
[  0.630473 0:2 axfs::fs::ext4fs:70] path_deal_with: /dev
[  0.630869 0:2 axfs::fs::ext4fs:89] dealt with full path: /dev
[  0.631594 0:2 axfs::fs::ext4fs:62] FileWrapper new EXT4_DE_DIR /dev
[  0.632951 0:2 axfs::fs::ext4fs:204] Get the parent dir of /dev
[  0.633702 0:2 axfs::fs::ext4fs:62] FileWrapper new EXT4_DE_DIR /
[  0.636092 0:2 axfs::fs::ext4fs:142] create Dir on Ext4fs: /tmp
[  0.636502 0:2 axfs::fs::ext4fs:70] path_deal_with: /tmp
[  0.636889 0:2 axfs::fs::ext4fs:89] dealt with full path: /tmp
[  0.638459 0:2 axfs::fs::ext4fs:70] path_deal_with: /tmp
[  0.638854 0:2 axfs::fs::ext4fs:89] dealt with full path: /tmp
[  0.639608 0:2 axfs::fs::ext4fs:62] FileWrapper new EXT4_DE_DIR /tmp
[  0.640105 0:2 axfs::fs::ext4fs:204] Get the parent dir of /tmp
[  0.640510 0:2 axfs::fs::ext4fs:62] FileWrapper new EXT4_DE_DIR /
[  0.647166 0:2 axfs::fs::ext4fs:142] create Dir on Ext4fs: /proc
[  0.647579 0:2 axfs::fs::ext4fs:70] path_deal_with: /proc
[  0.647968 0:2 axfs::fs::ext4fs:89] dealt with full path: /proc
[  0.649267 0:2 axfs::fs::ext4fs:70] path_deal_with: /proc
[  0.649664 0:2 axfs::fs::ext4fs:89] dealt with full path: /proc
[  0.650221 0:2 axfs::fs::ext4fs:62] FileWrapper new EXT4_DE_DIR /proc
[  0.650670 0:2 axfs::fs::ext4fs:204] Get the parent dir of /proc
[  0.651082 0:2 axfs::fs::ext4fs:62] FileWrapper new EXT4_DE_DIR /
[  0.652642 0:2 axfs::fs::ext4fs:142] create Dir on Ext4fs: /sys
[  0.653050 0:2 axfs::fs::ext4fs:70] path_deal_with: /sys
[  0.653437 0:2 axfs::fs::ext4fs:89] dealt with full path: /sys
[  0.654193 0:2 axfs::fs::ext4fs:70] path_deal_with: /sys
[  0.654584 0:2 axfs::fs::ext4fs:89] dealt with full path: /sys
[  0.655095 0:2 axfs::fs::ext4fs:62] FileWrapper new EXT4_DE_DIR /sys
[  0.655537 0:2 axfs::fs::ext4fs:204] Get the parent dir of /sys
[  0.655937 0:2 axfs::fs::ext4fs:62] FileWrapper new EXT4_DE_DIR /
[  0.657102 0:2 axruntime:190] Initialize interrupt handlers...
[  0.659088 0:2 axruntime:202] Primary CPU 0 init OK.


    _         __     ___
   / \   __  _\ \   / (_)___  ___  _ __
  / _ \  \ \/ /\ \ / /| / __|/ _ \| '__|
 / ___ \  &gt;  &lt;  \ V / | \__ \ (_) | |
/_/   \_\/_/\_\  \_/  |_|___/\___/|_|


by AxVisor Team

[  0.661595 0:2 axvisor:21] Starting virtualization...
[  0.662047 0:2 axvisor:22] Hardware support: true
[  0.666137 0:4 axvisor::vmm::timer:101] Initing HV Timer...
[  0.666832 0:4 axvisor::hal:122] Hardware virtualization support enabled on core 0
[  0.721331 0:2 axvisor::vmm::config:33] Creating VM[1] "linux-qemu"
[  0.723709 0:2 axvm::vm:114] Setting up memory region: [0x80000000~0xc0000000] READ | WRITE | EXECUTE
[  1.154125 0:2 axvm::vm:166] Setting up passthrough device memory region: [0x8000000~0x8050000] -&gt; [0x8000000~0x8050000]
[  1.155571 0:2 axvm::vm:166] Setting up passthrough device memory region: [0x9000000~0x9001000] -&gt; [0x9000000~0x9001000]
[  1.156470 0:2 axvm::vm:166] Setting up passthrough device memory region: [0x9010000~0x9011000] -&gt; [0x9010000~0x9011000]
[  1.157067 0:2 axvm::vm:166] Setting up passthrough device memory region: [0x9030000~0x9031000] -&gt; [0x9030000~0x9031000]
[  1.157650 0:2 axvm::vm:166] Setting up passthrough device memory region: [0xa000000~0xa004000] -&gt; [0xa000000~0xa004000]
[  1.158713 0:2 axvm::vm:202] VM[1] created
[  1.159495 0:2 axvm::vm:217] VM[1] vcpus set up
[  1.160206 0:2 axvisor::vmm::config:40] VM[1] created success, loading images...
[  1.160988 0:2 axvisor::vmm::images::fs:153] Loading VM images from filesystem
[  1.162440 0:2 axfs::fs::ext4fs:89] dealt with full path: /Image
[  1.163897 0:2 axfs::fs::ext4fs:62] FileWrapper new EXT4_DE_REG_FILE /Image
[  1.167163 0:2 axfs::fs::ext4fs:130] get_attr of File "/Image", size: 26089984, blocks: 50957
[  1.168499 0:2 axfs::fs::ext4fs:130] get_attr of File "/Image", size: 26089984, blocks: 50957
[  3.303086 0:2 axfs::fs::ext4fs:89] dealt with full path: /linux-qemu.dtb
[  3.303679 0:2 axfs::fs::ext4fs:62] FileWrapper new EXT4_DE_REG_FILE /linux-qemu.dtb
[  3.304497 0:2 axfs::fs::ext4fs:130] get_attr of File "/linux-qemu.dtb", size: 6252, blocks: 13
[  3.305357 0:2 axfs::fs::ext4fs:130] get_attr of File "/linux-qemu.dtb", size: 6252, blocks: 13
[  3.328436 0:2 axvisor::vmm:35] Setting up vcpus...
[  3.330223 0:2 axvisor::vmm::vcpus:219] Initializing VM[1]'s 1 vcpus
[  3.331181 0:2 axvisor::vmm::vcpus:250] Spawning task for VM[1] VCpu[0]
[  3.332723 0:2 axvisor::vmm::vcpus:262] VCpu task Task(5, "VM[1]-VCpu[0]") created cpumask: [0, ]
[  3.334047 0:2 axvisor::vmm:43] VMM starting, booting VMs...
[  3.334648 0:2 axvm::vm:284] Booting VM[1]
[  3.335286 0:2 axvisor::vmm:49] VM[1] boot success
[  3.335995 0:2 axvisor::vmm:60] a VM exited, current running VM count: 1
[  3.337830 0:5 axvisor::vmm::vcpus:283] VM[1] VCpu[0] waiting for running
[  3.338682 0:5 axvisor::vmm::vcpus:286] VM[1] VCpu[0] running...
[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x410fd083]
[    0.000000] Linux version 5.4.0 (root@josen) (gcc version 10.3.1 20210621 (GNU Toolchain for the A-profile Architecture 10.3-2021.07 (arm-10.29))) #1 SMP PREEMPT Fri Feb 28 06:11:15 UTC 2025
[    0.000000] Machine model: linux,dummy-virt
[    0.000000] efi: Getting EFI parameters from FDT:
[    0.000000] efi: UEFI not found.
[    0.000000] cma: Reserved 32 MiB at 0x00000000be000000
[    0.000000] earlycon: pl11 at MMIO 0x0000000009000000 (options '')
[    0.000000] printk: bootconsole [pl11] enabled
[    0.000000] NUMA: No NUMA configuration found
[    0.000000] NUMA: Faking a node at [mem 0x0000000080000000-0x00000000bfffffff]
[    0.000000] NUMA: NODE_DATA [mem 0xbddf4800-0xbddf5fff]
[    0.000000] Zone ranges:
[    0.000000]   DMA32    [mem 0x0000000080000000-0x00000000bfffffff]
[    0.000000]   Normal   empty
[    0.000000] Movable zone start for each node
[    0.000000] Early memory node ranges
[    0.000000]   node   0: [mem 0x0000000080000000-0x00000000bfffffff]
[    0.000000] Initmem setup node 0 [mem 0x0000000080000000-0x00000000bfffffff]
[    0.000000] psci: probing for conduit method from DT.
[    0.000000] psci: PSCIv1.1 detected in firmware.
[    0.000000] psci: Using standard PSCI v0.2 function IDs
[    0.000000] psci: Trusted OS migration not required
[    0.000000] psci: SMC Calling Convention v1.0
[    0.000000] percpu: Embedded 22 pages/cpu s52952 r8192 d28968 u90112
[    0.000000] Detected PIPT I-cache on CPU0
[    0.000000] CPU features: detected: EL2 vector hardening
[    0.000000] CPU features: kernel page table isolation forced ON by KASLR
[    0.000000] CPU features: detected: Kernel page table isolation (KPTI)
[    0.000000] ARM_SMCCC_ARCH_WORKAROUND_1 missing from firmware
[    0.000000] Built 1 zonelists, mobility grouping on.  Total pages: 258048
[    0.000000] Policy zone: DMA32
[    0.000000] Kernel command line: earlycon console=ttyAMA0 root=/dev/vda rw audit=0 default_hugepagesz=32M hugepagesz=32M hugepages=4
[    0.000000] audit: disabled (until reboot)
[    0.000000] Dentry cache hash table entries: 131072 (order: 8, 1048576 bytes, linear)
[    0.000000] Inode-cache hash table entries: 65536 (order: 7, 524288 bytes, linear)
[    0.000000] mem auto-init: stack:off, heap alloc:off, heap free:off
[    0.000000] Memory: 838672K/1048576K available (12092K kernel code, 1862K rwdata, 6384K rodata, 5056K init, 448K bss, 177136K reserved, 32768K cma-reserved)
[    0.000000] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1
[    0.000000] rcu: Preemptible hierarchical RCU implementation.
[    0.000000] rcu:     RCU restricting CPUs from NR_CPUS=256 to nr_cpu_ids=1.
[    0.000000]  Tasks RCU enabled.
[    0.000000] rcu: RCU calculated value of scheduler-enlistment delay is 25 jiffies.
[    0.000000] rcu: Adjusting geometry for rcu_fanout_leaf=16, nr_cpu_ids=1
[    0.000000] NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0
[    0.000000] GICv2m: range[mem 0x08020000-0x08020fff], SPI[80:143]
[    0.000000] random: get_random_bytes called from start_kernel+0x2b4/0x448 with crng_init=0
[    0.000000] arch_timer: cp15 timer(s) running at 62.50MHz (virt).
[    0.000000] clocksource: arch_sys_counter: mask: 0xffffffffffffff max_cycles: 0x1cd42e208c, max_idle_ns: 881590405314 ns
[    0.000300] sched_clock: 56 bits at 62MHz, resolution 16ns, wraps every 4398046511096ns
[    0.021052] Console: colour dummy device 80x25
[    0.027704] Calibrating delay loop (skipped), value calculated using timer frequency.. 125.00 BogoMIPS (lpj=250000)
[    0.028753] pid_max: default: 32768 minimum: 301
[    0.033091] LSM: Security Framework initializing
[    0.037810] Mount-cache hash table entries: 2048 (order: 2, 16384 bytes, linear)
[    0.038382] Mountpoint-cache hash table entries: 2048 (order: 2, 16384 bytes, linear)
[    0.126936] /cpus/cpu-map: empty cluster
[    0.175247] ASID allocator initialised with 32768 entries
[    0.178531] rcu: Hierarchical SRCU implementation.
[    0.207613] EFI services will not be available.
[    0.216053] smp: Bringing up secondary CPUs ...
[    0.216566] smp: Brought up 1 node, 1 CPU
[    0.216887] SMP: Total of 1 processors activated.
[    0.217445] CPU features: detected: 32-bit EL0 Support
[    0.218031] CPU features: detected: CRC32 instructions
[    0.337766] CPU: All CPU(s) started at EL1
[    0.338642] alternatives: patching kernel code
[    0.383895] devtmpfs: initialized
[    0.428672] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 7645041785100000 ns
[    0.430105] futex hash table entries: 256 (order: 2, 16384 bytes, linear)
[    0.453873] pinctrl core: initialized pinctrl subsystem
[    0.491373] DMI not present or invalid.
[    0.506983] NET: Registered protocol family 16
[    0.568658] DMA: preallocated 256 KiB pool for atomic allocations
[    0.586994] cpuidle: using governor menu
[    0.591402] hw-breakpoint: found 6 breakpoint and 4 watchpoint registers.
[    0.609434] Serial: AMBA PL011 UART driver
[    0.780453] 9000000.pl011: ttyAMA0 at MMIO 0x9000000 (irq = 40, base_baud = 0) is a PL011 rev1
[    0.784598] printk: console [ttyAMA0] enabled
[    0.784598] printk: console [ttyAMA0] enabled
[    0.786117] printk: bootconsole [pl11] disabled
[    0.786117] printk: bootconsole [pl11] disabled
[    0.949795] HugeTLB registered 32.0 MiB page size, pre-allocated 4 pages
[    0.950394] HugeTLB registered 1.00 GiB page size, pre-allocated 0 pages
[    0.950796] HugeTLB registered 2.00 MiB page size, pre-allocated 0 pages
[    0.951229] HugeTLB registered 64.0 KiB page size, pre-allocated 0 pages
[    1.021972] cryptd: max_cpu_qlen set to 1000
[    1.081779] ACPI: Interpreter disabled.
[    1.105114] iommu: Default domain type: Translated
[    1.109153] vgaarb: loaded
[    1.114725] SCSI subsystem initialized
[    1.123869] usbcore: registered new interface driver usbfs
[    1.125137] usbcore: registered new interface driver hub
[    1.126425] usbcore: registered new device driver usb
[    1.137681] pps_core: LinuxPPS API ver. 1 registered
[    1.138017] pps_core: Software ver. 5.3.6 - Copyright 2005-2007 Rodolfo Giometti &lt;giometti@linux.it&gt;
[    1.139026] PTP clock support registered
[    1.141246] EDAC MC: Ver: 3.0.0
[    1.161700] FPGA manager framework
[    1.164657] Advanced Linux Sound Architecture Driver Initialized.
[    1.199184] clocksource: Switched to clocksource arch_sys_counter
[    1.201943] VFS: Disk quotas dquot_6.6.0
[    1.202861] VFS: Dquot-cache hash table entries: 512 (order 0, 4096 bytes)
[    1.212083] pnp: PnP ACPI: disabled
[    1.285909] thermal_sys: Registered thermal governor 'step_wise'
[    1.286158] thermal_sys: Registered thermal governor 'power_allocator'
[    1.291579] NET: Registered protocol family 2
[    1.307057] tcp_listen_portaddr_hash hash table entries: 512 (order: 1, 8192 bytes, linear)
[    1.307806] TCP established hash table entries: 8192 (order: 4, 65536 bytes, linear)
[    1.308700] TCP bind hash table entries: 8192 (order: 5, 131072 bytes, linear)
[    1.309512] TCP: Hash tables configured (established 8192 bind 8192)
[    1.313826] UDP hash table entries: 512 (order: 2, 16384 bytes, linear)
[    1.315233] UDP-Lite hash table entries: 512 (order: 2, 16384 bytes, linear)
[    1.319902] NET: Registered protocol family 1
[    1.343529] RPC: Registered named UNIX socket transport module.
[    1.344043] RPC: Registered udp transport module.
[    1.344355] RPC: Registered tcp transport module.
[    1.344661] RPC: Registered tcp NFSv4.1 backchannel transport module.
[    1.345358] PCI: CLS 0 bytes, default 64
[    1.367728] hw perfevents: enabled with armv8_pmuv3 PMU driver, 7 counters available
[    1.369056] kvm [1]: HYP mode not available
[    1.457584] Initialise system trusted keyrings
[    1.462239] workingset: timestamp_bits=44 max_order=18 bucket_order=0
[    1.558147] squashfs: version 4.0 (2009/01/31) Phillip Lougher
[    1.574739] NFS: Registering the id_resolver key type
[    1.575637] Key type id_resolver registered
[    1.575997] Key type id_legacy registered
[    1.576655] nfs4filelayout_init: NFSv4 File Layout Driver Registering...
[    1.579327] 9p: Installing v9fs 9p2000 file system support
[    1.597384] Key type asymmetric registered
[    1.597846] Asymmetric key parser 'x509' registered
[    1.599071] Block layer SCSI generic (bsg) driver version 0.4 loaded (major 245)
[    1.599795] io scheduler mq-deadline registered
[    1.600306] io scheduler kyber registered
[    1.716763] pl061_gpio 9030000.pl061: PL061 GPIO chip registered
[    1.769773] EINJ: ACPI disabled.
[    1.962778] Serial: 8250/16550 driver, 4 ports, IRQ sharing enabled
[    1.994268] SuperH (H)SCI(F) driver initialized
[    2.003719] msm_serial: driver initialized
[    2.022026] cacheinfo: Unable to detect cache hierarchy for CPU 0
[    2.117351] loop: module loaded
[    2.173781] virtio_blk virtio1: [vda] 262144 512-byte logical blocks (134 MB/128 MiB)
[    2.325276] libphy: Fixed MDIO Bus: probed
[    2.329558] tun: Universal TUN/TAP device driver, 1.6
[    2.364261] thunder_xcv, ver 1.0
[    2.365020] thunder_bgx, ver 1.0
[    2.365715] nicpf, ver 1.0
[    2.375371] hclge is initializing
[    2.375887] hns3: Hisilicon Ethernet Network Driver for Hip08 Family - version
[    2.376364] hns3: Copyright (c) 2017 Huawei Corporation.
[    2.377736] e1000e: Intel(R) PRO/1000 Network Driver - 3.2.6-k
[    2.378149] e1000e: Copyright(c) 1999 - 2015 Intel Corporation.
[    2.379336] igb: Intel(R) Gigabit Ethernet Network Driver - version 5.6.0-k
[    2.379753] igb: Copyright (c) 2007-2014 Intel Corporation.
[    2.380674] igbvf: Intel(R) Gigabit Virtual Function Network Driver - version 2.4.0-k
[    2.381168] igbvf: Copyright (c) 2009 - 2012 Intel Corporation.
[    2.386928] sky2: driver version 1.30
[    2.397403] VFIO - User Level meta-driver version: 0.3
[    2.424701] ehci_hcd: USB 2.0 'Enhanced' Host Controller (EHCI) Driver
[    2.425364] ehci-pci: EHCI PCI platform driver
[    2.426358] ehci-platform: EHCI generic platform driver
[    2.428872] ehci-orion: EHCI orion driver
[    2.430791] ehci-exynos: EHCI EXYNOS driver
[    2.432318] ohci_hcd: USB 1.1 'Open' Host Controller (OHCI) Driver
[    2.432951] ohci-pci: OHCI PCI platform driver
[    2.433945] ohci-platform: OHCI generic platform driver
[    2.436296] ohci-exynos: OHCI EXYNOS driver
[    2.444692] usbcore: registered new interface driver usb-storage
[    2.491526] rtc-pl031 9010000.pl031: registered as rtc0
[    2.501170] i2c /dev entries driver
[    2.578984] sdhci: Secure Digital Host Controller Interface driver
[    2.579379] sdhci: Copyright(c) Pierre Ossman
[    2.585633] Synopsys Designware Multimedia Card Interface Driver
[    2.600244] sdhci-pltfm: SDHCI platform and OF driver helper
[    2.623755] ledtrig-cpu: registered to indicate activity on CPUs
[    2.643316] usbcore: registered new interface driver usbhid
[    2.643701] usbhid: USB HID core driver
[    2.704460] NET: Registered protocol family 17
[    2.709162] 9pnet: Installing 9P2000 support
[    2.710284] Key type dns_resolver registered
[    2.713927] registered taskstats version 1
[    2.714326] Loading compiled-in X.509 certificates
[    2.747078] input: gpio-keys as /devices/platform/gpio-keys/input/input0
[    2.756507] rtc-pl031 9010000.pl031: setting system clock to 2025-06-05T05:41:40 UTC (1749102100)
[    2.760300] ALSA device list:
[    2.760773]   No soundcards found.
[    2.773089] uart-pl011 9000000.pl011: no DMA platform data
[    2.867179] EXT4-fs (vda): warning: mounting unchecked fs, running e2fsck is recommended
[    2.911981] EXT4-fs (vda): recovery complete
[    2.919232] EXT4-fs (vda): mounted filesystem with ordered data mode. Opts: (null)
[    2.920639] VFS: Mounted root (ext4 filesystem) on device 254:0.
[    2.926848] devtmpfs: mounted
[    3.032764] Freeing unused kernel memory: 5056K
[    3.035219] Run /sbin/init as init process
[    3.049432] Run /etc/init as init process
[    3.051160] Run /bin/init as init process
[    3.057535] Run /bin/sh as init process
/bin/sh: 0: can't access tty; job control turned off
# 
</code></pre>
</li>
</ol>
<h3 id="从内存加载运行-1"><a class="header" href="#从内存加载运行-1">从内存加载运行</a></h3>
<p>获取 AxVisor 主线代码 <code>git clone git@github.com:arceos-hypervisor/axvisor.git</code>，然后在 <code>axvisor</code> 源码目录中执行如下步骤：</p>
<ol>
<li>
<p>执行 <code>make ubuntu_img ARCH=aarch64</code> 制作一个简单的根文件系统镜像 <code>disk.img</code> 作为 Linux 客户机启动之后的文件系统</p>
</li>
<li>
<p>修改对应的 <code>./configs/vms/linux-qemu-aarch64.toml</code> 中的配置项
<img src="quickstart/qemu/../../assets/quickstart/aarch64_qemu_linux_config_mem.png" alt="" /></p>
<ul>
<li><code>image_location="memory"</code> 配置项</li>
<li><code>kernel_path</code> 指定内核镜像在工作空间中的相对/绝对路径</li>
<li><code>entry_point</code> 指出内核镜像的入口地址</li>
<li><code>kernel_load_addr</code> 指出内核镜像的加载地址</li>
<li>其他</li>
</ul>
</li>
<li>
<p>执行 <code>make ARCH=aarch64 VM_CONFIGS=configs/vms/linux-qemu-aarch64.toml LOG=debug BUS=mmio NET=y FEATURES=page-alloc-64g MEM=8g run</code> 构建 AxVisor，并在 QEMU 中启动。</p>
<pre><code class="language-palintext">       d8888                            .d88888b.   .d8888b.
      d88888                           d88P" "Y88b d88P  Y88b
     d88P888                           888     888 Y88b.
    d88P 888 888d888  .d8888b  .d88b.  888     888  "Y888b.
   d88P  888 888P"   d88P"    d8P  Y8b 888     888     "Y88b.
  d88P   888 888     888      88888888 888     888       "888
 d8888888888 888     Y88b.    Y8b.     Y88b. .d88P Y88b  d88P
d88P     888 888      "Y8888P  "Y8888   "Y88888P"   "Y8888P"

arch = aarch64
platform = aarch64-qemu-virt-hv
target = aarch64-unknown-none-softfloat
build_mode = release
log_level = debug
smp = 1

[  0.024658 0 axruntime:130] Logging is enabled.
[  0.027968 0 axruntime:131] Primary CPU 0 started, dtb = 0x48000000.
[  0.030231 0 axruntime:133] Found physcial memory regions:
[  0.032289 0 axruntime:135]   [PA:0x40080000, PA:0x400dc000) .text (READ | EXECUTE | RESERVED)
[  0.038819 0 axruntime:135]   [PA:0x400dc000, PA:0x42b3b000) .rodata (READ | RESERVED)
[  0.042203 0 axruntime:135]   [PA:0x42b3b000, PA:0x42b41000) .data .tdata .tbss .percpu (READ | WRITE | RESERVED)
[  0.045085 0 axruntime:135]   [PA:0x42b41000, PA:0x42b81000) boot stack (READ | WRITE | RESERVED)
[  0.046080 0 axruntime:135]   [PA:0x42b81000, PA:0x42da7000) .bss (READ | WRITE | RESERVED)
[  0.047326 0 axruntime:135]   [PA:0x42da7000, PA:0xc0000000) free memory (READ | WRITE | FREE)
[  0.049258 0 axruntime:135]   [PA:0x9000000, PA:0x9001000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.051752 0 axruntime:135]   [PA:0x9040000, PA:0x9041000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.054645 0 axruntime:135]   [PA:0x9100000, PA:0x9101000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.058006 0 axruntime:135]   [PA:0x8000000, PA:0x8020000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.059283 0 axruntime:135]   [PA:0x80a0000, PA:0x9000000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.060944 0 axruntime:135]   [PA:0xa000000, PA:0xa004000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.063520 0 axruntime:135]   [PA:0x10000000, PA:0x3eff0000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.066812 0 axruntime:135]   [PA:0x4010000000, PA:0x4020000000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.073354 0 axruntime:210] Initialize global memory allocator...
[  0.077250 0 axruntime:211]   use TLSF allocator.
[  0.080529 0 axalloc:230] initialize global allocator at: [0x42da7000, 0xc0000000)
[  0.093509 0 axmm:72] Initialize virtual memory management...
[  0.101142 0 axmm::backend::linear:21] map_linear: [VA:0x40080000, VA:0x400dc000) -&gt; [PA:0x40080000, PA:0x400dc000) READ | EXECUTE
[  0.113382 0 axmm::backend::linear:21] map_linear: [VA:0x400dc000, VA:0x42b3b000) -&gt; [PA:0x400dc000, PA:0x42b3b000) READ
[  0.117719 0 axmm::backend::linear:21] map_linear: [VA:0x42b3b000, VA:0x42b41000) -&gt; [PA:0x42b3b000, PA:0x42b41000) READ | WRITE
[  0.119533 0 axmm::backend::linear:21] map_linear: [VA:0x42b41000, VA:0x42b81000) -&gt; [PA:0x42b41000, PA:0x42b81000) READ | WRITE
[  0.128172 0 axmm::backend::linear:21] map_linear: [VA:0x42b81000, VA:0x42da7000) -&gt; [PA:0x42b81000, PA:0x42da7000) READ | WRITE
[  0.130208 0 axmm::backend::linear:21] map_linear: [VA:0x42da7000, VA:0xc0000000) -&gt; [PA:0x42da7000, PA:0xc0000000) READ | WRITE
[  0.253629 0 axmm::backend::linear:21] map_linear: [VA:0x9000000, VA:0x9001000) -&gt; [PA:0x9000000, PA:0x9001000) READ | WRITE | DEVICE
[  0.258641 0 axmm::backend::linear:21] map_linear: [VA:0x9040000, VA:0x9041000) -&gt; [PA:0x9040000, PA:0x9041000) READ | WRITE | DEVICE
[  0.261747 0 axmm::backend::linear:21] map_linear: [VA:0x9100000, VA:0x9101000) -&gt; [PA:0x9100000, PA:0x9101000) READ | WRITE | DEVICE
[  0.265539 0 axmm::backend::linear:21] map_linear: [VA:0x8000000, VA:0x8020000) -&gt; [PA:0x8000000, PA:0x8020000) READ | WRITE | DEVICE
[  0.268191 0 axmm::backend::linear:21] map_linear: [VA:0x80a0000, VA:0x9000000) -&gt; [PA:0x80a0000, PA:0x9000000) READ | WRITE | DEVICE
[  0.272345 0 axmm::backend::linear:21] map_linear: [VA:0xa000000, VA:0xa004000) -&gt; [PA:0xa000000, PA:0xa004000) READ | WRITE | DEVICE
[  0.278256 0 axmm::backend::linear:21] map_linear: [VA:0x10000000, VA:0x3eff0000) -&gt; [PA:0x10000000, PA:0x3eff0000) READ | WRITE | DEVICE
[  0.323020 0 axmm::backend::linear:21] map_linear: [VA:0x4010000000, VA:0x4020000000) -&gt; [PA:0x4010000000, PA:0x4020000000) READ | WRITE | DEVICE
[  0.340421 0 axmm:75] kernel address space init OK: AddrSpace {
   va_range: VA:0x0..VA:0xfffffffff000,
   page_table_root: PA:0x42daf000,
   areas: [
      MemoryArea {
            va_range: VA:0x8000000..VA:0x8020000,
            flags: READ | WRITE | DEVICE,
      },
      MemoryArea {
            va_range: VA:0x80a0000..VA:0x9000000,
            flags: READ | WRITE | DEVICE,
      },
      MemoryArea {
            va_range: VA:0x9000000..VA:0x9001000,
            flags: READ | WRITE | DEVICE,
      },
      MemoryArea {
            va_range: VA:0x9040000..VA:0x9041000,
            flags: READ | WRITE | DEVICE,
      },
      MemoryArea {
            va_range: VA:0x9100000..VA:0x9101000,
            flags: READ | WRITE | DEVICE,
      },
      MemoryArea {
            va_range: VA:0xa000000..VA:0xa004000,
            flags: READ | WRITE | DEVICE,
      },
      MemoryArea {
            va_range: VA:0x10000000..VA:0x3eff0000,
            flags: READ | WRITE | DEVICE,
      },
      MemoryArea {
            va_range: VA:0x40080000..VA:0x400dc000,
            flags: READ | EXECUTE,
      },
      MemoryArea {
            va_range: VA:0x400dc000..VA:0x42b3b000,
            flags: READ,
      },
      MemoryArea {
            va_range: VA:0x42b3b000..VA:0x42b41000,
            flags: READ | WRITE,
      },
      MemoryArea {
            va_range: VA:0x42b41000..VA:0x42b81000,
            flags: READ | WRITE,
      },
      MemoryArea {
            va_range: VA:0x42b81000..VA:0x42da7000,
            flags: READ | WRITE,
      },
      MemoryArea {
            va_range: VA:0x42da7000..VA:0xc0000000,
            flags: READ | WRITE,
      },
      MemoryArea {
            va_range: VA:0x4010000000..VA:0x4020000000,
            flags: READ | WRITE | DEVICE,
      },
   ],
}
[  0.383032 0 axruntime:150] Initialize platform devices...
[  0.385115 0 axhal::platform::aarch64_common::gic:67] Initialize GICv2...
[  0.390165 0 axtask::api:73] Initialize scheduling...
[  0.394143 0 axtask::task:115] new task: Task(1, "idle")
[  0.400799 0 axtask::task:115] new task: Task(3, "gc")
[  0.404098 0 axalloc:118] expand heap memory: [0x433b7000, 0x433f7000)
[  0.407590 0 axalloc:118] expand heap memory: [0x433f7000, 0x43477000)
[  0.416918 0 axtask::api:79]   use FIFO scheduler.
[  0.418770 0 axruntime:176] Initialize interrupt handlers...
[  0.421411 0 axruntime:188] Primary CPU 0 init OK.


    _         __     ___
   / \   __  _\ \   / (_)___  ___  _ __
  / _ \  \ \/ /\ \ / /| / __|/ _ \| '__|
 / ___ \  &gt;  &lt;  \ V / | \__ \ (_) | |
/_/   \_\/_/\_\  \_/  |_|___/\___/|_|


by AxVisor Team

[  0.430988 0:2 axvisor:21] Starting virtualization...
[  0.433801 0:2 axvisor:22] Hardware support: true
[  0.436319 0:2 axtask::task:115] new task: Task(4, "")
[  0.440202 0:2 axalloc:118] expand heap memory: [0x43477000, 0x43577000)
[  0.443736 0:2 axtask::run_queue:234] task add: Task(4, "") on run_queue 0
[  0.446782 0:3 axtask::run_queue:418] task block: Task(3, "gc")
[  0.448008 0:4 axvisor::vmm::timer:101] Initing HV Timer...
[  0.449013 0:4 axvisor::hal:117] Hardware virtualization support enabled on core 0
[  0.450795 0:4 axtask::run_queue:357] task exit: Task(4, ""), exit_code=0
[  0.454390 0:4 axtask::run_queue:260] task unblock: Task(3, "gc") on run_queue 0
[  0.459048 0:2 axvisor::hal:78] IRQ handler 26
[  0.471186 0:2 axvisor::hal:78] IRQ handler 26
[  0.481779 0:2 axvisor::hal:78] IRQ handler 26
[  0.491580 0:2 axvisor::hal:78] IRQ handler 26
[  0.501333 0:2 axvisor::hal:78] IRQ handler 26
[  0.511238 0:2 axvisor::hal:78] IRQ handler 26
[  0.521212 0:2 axvisor::hal:78] IRQ handler 26
[  0.531414 0:2 axvisor::hal:78] IRQ handler 26
[  0.547459 0:2 axvisor::hal:78] IRQ handler 26
[  0.550403 0:2 axvisor::vmm::config:33] Creating VM[1] "linux-qemu"
[  0.553529 0:2 axvisor::hal:78] IRQ handler 26
[  0.558630 0:2 axvm::vm:114] Setting up memory region: [0x80000000~0xc0000000] READ | WRITE | EXECUTE
[  0.563846 0:2 axvisor::hal:78] IRQ handler 26
[  0.787704 0:2 axvisor::hal:78] IRQ handler 26
[  0.791000 0:2 axaddrspace::address_space::backend::linear:22] map_linear: [GPA:0x80000000, GPA:0xc0000000) -&gt; [PA:0x80000000, PA:0xc0000000) READ | WRITE | EXECUTE
[  0.802518 0:2 axvisor::hal:78] IRQ handler 26
[  0.822543 0:2 axvisor::hal:78] IRQ handler 26
[  0.833460 0:2 axvisor::hal:78] IRQ handler 26
[  0.843554 0:2 axvisor::hal:78] IRQ handler 26
[  0.853436 0:2 axvisor::hal:78] IRQ handler 26
[  0.863518 0:2 axvisor::hal:78] IRQ handler 26
[  0.873439 0:2 axvisor::hal:78] IRQ handler 26
[  0.883879 0:2 axvisor::hal:78] IRQ handler 26
[  0.893370 0:2 axvm::vm:166] Setting up passthrough device memory region: [0x8000000~0x8050000] -&gt; [0x8000000~0x8050000]
[  0.897995 0:2 axvisor::hal:78] IRQ handler 26
[  0.900224 0:2 axaddrspace::address_space::backend::linear:22] map_linear: [GPA:0x8000000, GPA:0x8050000) -&gt; [PA:0x8000000, PA:0x8050000) READ | WRITE | DEVICE
[  0.905709 0:2 axvisor::hal:78] IRQ handler 26
[  0.908392 0:2 axvm::vm:166] Setting up passthrough device memory region: [0x9000000~0x9001000] -&gt; [0x9000000~0x9001000]
[  0.919770 0:2 axvisor::hal:78] IRQ handler 26
[  0.925226 0:2 axaddrspace::address_space::backend::linear:22] map_linear: [GPA:0x9000000, GPA:0x9001000) -&gt; [PA:0x9000000, PA:0x9001000) READ | WRITE | DEVICE
[  0.929037 0:2 axvm::vm:166] Setting up passthrough device memory region: [0x9010000~0x9011000] -&gt; [0x9010000~0x9011000]
[  0.930383 0:2 axaddrspace::address_space::backend::linear:22] map_linear: [GPA:0x9010000, GPA:0x9011000) -&gt; [PA:0x9010000, PA:0x9011000) READ | WRITE | DEVICE
[  0.932103 0:2 axvm::vm:166] Setting up passthrough device memory region: [0x9030000~0x9031000] -&gt; [0x9030000~0x9031000]
[  0.933706 0:2 axaddrspace::address_space::backend::linear:22] map_linear: [GPA:0x9030000, GPA:0x9031000) -&gt; [PA:0x9030000, PA:0x9031000) READ | WRITE | DEVICE
[  0.937738 0:2 axvisor::hal:78] IRQ handler 26
[  0.940254 0:2 axvm::vm:166] Setting up passthrough device memory region: [0xa000000~0xa004000] -&gt; [0xa000000~0xa004000]
[  0.942638 0:2 axaddrspace::address_space::backend::linear:22] map_linear: [GPA:0xa000000, GPA:0xa004000) -&gt; [PA:0xa000000, PA:0xa004000) READ | WRITE | DEVICE
[  0.947337 0:2 axvisor::hal:78] IRQ handler 26
[  0.948568 0:2 axvm::vm:202] VM[1] created
[  0.949359 0:2 arm_vcpu::vcpu:88] set vcpu entry:GPA:0x80080000
[  0.950551 0:2 arm_vcpu::vcpu:94] set vcpu ept root:PA:0x43577000
[  0.951965 0:2 axvm::vm:217] VM[1] vcpus set up
[  0.953451 0:2 axvisor::vmm::config:40] VM[1] created success, loading images...
[  0.956000 0:2 axvisor::hal:78] IRQ handler 26
[  0.958032 0:2 axvisor::vmm::images:26] Loading VM[1] images from memory
[  0.961079 0:2 axvisor::vmm::images:69] loading VM image from memory GPA:0x80080000 44362240
[  0.964095 0:2 axvisor::hal:78] IRQ handler 26
[  0.965790 0:2 axaddrspace::address_space:203] start GPA:0x80080000 end GPA:0x82acea00 area size 0x40000000
[  0.979090 0:2 axvisor::hal:78] IRQ handler 26
[  0.984148 0:2 axvisor::hal:78] IRQ handler 26
[  0.995832 0:2 axvisor::hal:78] IRQ handler 26
[  1.004134 0:2 axvisor::hal:78] IRQ handler 26
[  1.014091 0:2 axvisor::hal:78] IRQ handler 26
[  1.028138 0:2 axvisor::hal:78] IRQ handler 26
[  1.034181 0:2 axvisor::hal:78] IRQ handler 26
[  1.044131 0:2 axvisor::hal:78] IRQ handler 26
[  1.056503 0:2 axvisor::hal:78] IRQ handler 26
[  1.064184 0:2 axvisor::hal:78] IRQ handler 26
[  1.074054 0:2 axvisor::hal:78] IRQ handler 26
[  1.130314 0:2 axvisor::hal:78] IRQ handler 26
[  1.146054 0:2 axvisor::hal:78] IRQ handler 26
[  1.170146 0:2 axvisor::hal:78] IRQ handler 26
[  1.188947 0:2 axvisor::hal:78] IRQ handler 26
[  1.192258 0:2 axvisor::hal:78] IRQ handler 26
[  1.208340 0:2 axvisor::hal:78] IRQ handler 26
[  1.212236 0:2 axvisor::hal:78] IRQ handler 26
[  1.223048 0:2 axvisor::hal:78] IRQ handler 26
[  1.250578 0:2 axvisor::hal:78] IRQ handler 26
[  1.263557 0:2 axvisor::hal:78] IRQ handler 26
[  1.274722 0:2 axvisor::hal:78] IRQ handler 26
[  1.285095 0:2 axvisor::hal:78] IRQ handler 26
[  1.295244 0:2 axvisor::hal:78] IRQ handler 26
[  1.303902 0:2 axvisor::hal:78] IRQ handler 26
[  1.317920 0:2 axvisor::hal:78] IRQ handler 26
[  1.322611 0:2 axvisor::hal:78] IRQ handler 26
[  1.333696 0:2 axvisor::hal:78] IRQ handler 26
[  1.342463 0:2 axvisor::hal:78] IRQ handler 26
[  1.352325 0:2 axvisor::hal:78] IRQ handler 26
[  1.363464 0:2 axvisor::hal:78] IRQ handler 26
[  1.376637 0:2 axvisor::hal:78] IRQ handler 26
[  1.382304 0:2 axvisor::hal:78] IRQ handler 26
[  1.392330 0:2 axvisor::hal:78] IRQ handler 26
[  1.396300 0:2 axvisor::vmm::images:95] copy size: 2560
[  1.399115 0:2 axvisor::vmm::images:69] loading VM image from memory GPA:0x80000000 6252
[  1.402078 0:2 axaddrspace::address_space:203] start GPA:0x80000000 end GPA:0x8000186c area size 0x40000000
[  1.405650 0:2 axvisor::hal:78] IRQ handler 26
[  1.408207 0:2 axvisor::vmm::images:95] copy size: 2156
[  1.410604 0:2 axvisor::vmm::images:50] flush all guest cache GPA: 0x80000000, Size: 0x40000000
[  1.412294 0:2 axvisor::hal:78] IRQ handler 26
[  1.422579 0:2 axvisor::hal:78] IRQ handler 26
[  1.432254 0:2 axvisor::hal:78] IRQ handler 26
[  1.442329 0:2 axvisor::hal:78] IRQ handler 26
[  1.452705 0:2 axvisor::hal:78] IRQ handler 26
[  1.462295 0:2 axvisor::hal:78] IRQ handler 26
[  1.472576 0:2 axvisor::hal:78] IRQ handler 26
[  1.482326 0:2 axvisor::hal:78] IRQ handler 26
[  1.492276 0:2 axvisor::hal:78] IRQ handler 26
[  1.502376 0:2 axvisor::hal:78] IRQ handler 26
[  1.512295 0:2 axvisor::hal:78] IRQ handler 26
[  1.522501 0:2 axvisor::hal:78] IRQ handler 26
[  1.532274 0:2 axvisor::hal:78] IRQ handler 26
[  1.542290 0:2 axvisor::hal:78] IRQ handler 26
[  1.552403 0:2 axvisor::hal:78] IRQ handler 26
[  1.562312 0:2 axvisor::hal:78] IRQ handler 26
[  1.573256 0:2 axvisor::hal:78] IRQ handler 26
[  1.582282 0:2 axvisor::hal:78] IRQ handler 26
[  1.592286 0:2 axvisor::hal:78] IRQ handler 26
[  1.602324 0:2 axvisor::hal:78] IRQ handler 26
[  1.612255 0:2 axvisor::hal:78] IRQ handler 26
[  1.622471 0:2 axvisor::hal:78] IRQ handler 26
[  1.632237 0:2 axvisor::hal:78] IRQ handler 26
[  1.642318 0:2 axvisor::hal:78] IRQ handler 26
[  1.652273 0:2 axvisor::hal:78] IRQ handler 26
[  1.662257 0:2 axvisor::hal:78] IRQ handler 26
[  1.672486 0:2 axvisor::hal:78] IRQ handler 26
[  1.682490 0:2 axvisor::hal:78] IRQ handler 26
[  1.692288 0:2 axvisor::hal:78] IRQ handler 26
[  1.702294 0:2 axvisor::hal:78] IRQ handler 26
[  1.712268 0:2 axvisor::hal:78] IRQ handler 26
[  1.722517 0:2 axvisor::hal:78] IRQ handler 26
[  1.732379 0:2 axvisor::hal:78] IRQ handler 26
[  1.742271 0:2 axvisor::hal:78] IRQ handler 26
[  1.752318 0:2 axvisor::hal:78] IRQ handler 26
[  1.762322 0:2 axvisor::hal:78] IRQ handler 26
[  1.772309 0:2 axvisor::hal:78] IRQ handler 26
[  1.783235 0:2 axvisor::hal:78] IRQ handler 26
[  1.792419 0:2 axvisor::hal:78] IRQ handler 26
[  1.802408 0:2 axvisor::hal:78] IRQ handler 26
[  1.812387 0:2 axvisor::hal:78] IRQ handler 26
[  1.822310 0:2 axvisor::hal:78] IRQ handler 26
[  1.832550 0:2 axvisor::hal:78] IRQ handler 26
[  1.842300 0:2 axvisor::hal:78] IRQ handler 26
[  1.853924 0:2 axvisor::hal:78] IRQ handler 26
[  1.862307 0:2 axvisor::hal:78] IRQ handler 26
[  1.872499 0:2 axvisor::hal:78] IRQ handler 26
[  1.882307 0:2 axvisor::hal:78] IRQ handler 26
[  1.892288 0:2 axvisor::hal:78] IRQ handler 26
[  1.902895 0:2 axvisor::hal:78] IRQ handler 26
[  1.920219 0:2 axvisor::hal:78] IRQ handler 26
[  1.933921 0:2 axvisor::hal:78] IRQ handler 26
[  1.943891 0:2 axvisor::hal:78] IRQ handler 26
[  1.953868 0:2 axvisor::hal:78] IRQ handler 26
[  1.963902 0:2 axvisor::hal:78] IRQ handler 26
[  1.973886 0:2 axvisor::hal:78] IRQ handler 26
[  1.984217 0:2 axvisor::hal:78] IRQ handler 26
[  1.993874 0:2 axvisor::hal:78] IRQ handler 26
[  2.003876 0:2 axvisor::hal:78] IRQ handler 26
[  2.013922 0:2 axvisor::hal:78] IRQ handler 26
[  2.023971 0:2 axvisor::hal:78] IRQ handler 26
[  2.034016 0:2 axvisor::hal:78] IRQ handler 26
[  2.046371 0:2 axvisor::hal:78] IRQ handler 26
[  2.053980 0:2 axvisor::hal:78] IRQ handler 26
[  2.063844 0:2 axvisor::hal:78] IRQ handler 26
[  2.073897 0:2 axvisor::hal:78] IRQ handler 26
[  2.083939 0:2 axvisor::hal:78] IRQ handler 26
[  2.094031 0:2 axvisor::hal:78] IRQ handler 26
[  2.103924 0:2 axvisor::hal:78] IRQ handler 26
[  2.114030 0:2 axvisor::hal:78] IRQ handler 26
[  2.124037 0:2 axvisor::hal:78] IRQ handler 26
[  2.134311 0:2 axvisor::hal:78] IRQ handler 26
[  2.154494 0:2 axvisor::hal:78] IRQ handler 26
[  2.167466 0:2 axvisor::hal:78] IRQ handler 26
[  2.207637 0:2 axvisor::hal:78] IRQ handler 26
[  2.243856 0:2 axvisor::hal:78] IRQ handler 26
[  2.255986 0:2 axvisor::hal:78] IRQ handler 26
[  2.266915 0:2 axvisor::hal:78] IRQ handler 26
[  2.275861 0:2 axvisor::hal:78] IRQ handler 26
[  2.285810 0:2 axvisor::hal:78] IRQ handler 26
[  2.296511 0:2 axvisor::hal:78] IRQ handler 26
[  2.308572 0:2 axvisor::hal:78] IRQ handler 26
[  2.316081 0:2 axvisor::hal:78] IRQ handler 26
[  2.325763 0:2 axvisor::hal:78] IRQ handler 26
[  2.335789 0:2 axvisor::hal:78] IRQ handler 26
[  2.345793 0:2 axvisor::hal:78] IRQ handler 26
[  2.356981 0:2 axvisor::hal:78] IRQ handler 26
[  2.366927 0:2 axvisor::hal:78] IRQ handler 26
[  2.375994 0:2 axvisor::hal:78] IRQ handler 26
[  2.386022 0:2 axvisor::hal:78] IRQ handler 26
[  2.395991 0:2 axvisor::hal:78] IRQ handler 26
[  2.406099 0:2 axvisor::hal:78] IRQ handler 26
[  2.415808 0:2 axvisor::hal:78] IRQ handler 26
[  2.425765 0:2 axvisor::hal:78] IRQ handler 26
[  2.435823 0:2 axvisor::hal:78] IRQ handler 26
[  2.445775 0:2 axvisor::hal:78] IRQ handler 26
[  2.455957 0:2 axvisor::hal:78] IRQ handler 26
[  2.465897 0:2 axvisor::hal:78] IRQ handler 26
[  2.476363 0:2 axvisor::hal:78] IRQ handler 26
[  2.485853 0:2 axvisor::hal:78] IRQ handler 26
[  2.516806 0:2 axvisor::hal:78] IRQ handler 26
[  2.528687 0:2 axvisor::hal:78] IRQ handler 26
[  2.539178 0:2 axvisor::hal:78] IRQ handler 26
[  2.548977 0:2 axvisor::hal:78] IRQ handler 26
[  2.558630 0:2 axvisor::hal:78] IRQ handler 26
[  2.569108 0:2 axvisor::hal:78] IRQ handler 26
[  2.578618 0:2 axvisor::hal:78] IRQ handler 26
[  2.588597 0:2 axvisor::hal:78] IRQ handler 26
[  2.599400 0:2 axvisor::hal:78] IRQ handler 26
[  2.609120 0:2 axvisor::hal:78] IRQ handler 26
[  2.618953 0:2 axvisor::hal:78] IRQ handler 26
[  2.628645 0:2 axvisor::hal:78] IRQ handler 26
[  2.638625 0:2 axvisor::hal:78] IRQ handler 26
[  2.651867 0:2 axvisor::hal:78] IRQ handler 26
[  2.663639 0:2 axvisor::hal:78] IRQ handler 26
[  2.668788 0:2 axvisor::hal:78] IRQ handler 26
[  2.679398 0:2 axvisor::hal:78] IRQ handler 26
[  2.688802 0:2 axvisor::hal:78] IRQ handler 26
[  2.701195 0:2 axvisor::hal:78] IRQ handler 26
[  2.708636 0:2 axvisor::hal:78] IRQ handler 26
[  2.720138 0:2 axvisor::hal:78] IRQ handler 26
[  2.728949 0:2 axvisor::hal:78] IRQ handler 26
[  2.739389 0:2 axvisor::hal:78] IRQ handler 26
[  2.760549 0:2 axvisor::hal:78] IRQ handler 26
[  2.775301 0:2 axvisor::hal:78] IRQ handler 26
[  2.782955 0:2 axvisor::hal:78] IRQ handler 26
[  2.795103 0:2 axvisor::hal:78] IRQ handler 26
[  2.803442 0:2 axvisor::hal:78] IRQ handler 26
[  2.813051 0:2 axvisor::hal:78] IRQ handler 26
[  2.823109 0:2 axvisor::hal:78] IRQ handler 26
[  2.833653 0:2 axvisor::hal:78] IRQ handler 26
[  2.843040 0:2 axvisor::hal:78] IRQ handler 26
[  2.855099 0:2 axvisor::hal:78] IRQ handler 26
[  2.863076 0:2 axvisor::hal:78] IRQ handler 26
[  2.875940 0:2 axvisor::hal:78] IRQ handler 26
[  2.882971 0:2 axvisor::hal:78] IRQ handler 26
[  2.892968 0:2 axvisor::hal:78] IRQ handler 26
[  2.903169 0:2 axvisor::hal:78] IRQ handler 26
[  2.912956 0:2 axvisor::hal:78] IRQ handler 26
[  2.929439 0:2 axvisor::hal:78] IRQ handler 26
[  2.932984 0:2 axvisor::hal:78] IRQ handler 26
[  2.942985 0:2 axvisor::hal:78] IRQ handler 26
[  2.953215 0:2 axvisor::hal:78] IRQ handler 26
[  2.999136 0:2 axvisor::hal:78] IRQ handler 26
[  3.012483 0:2 axvisor::hal:78] IRQ handler 26
[  3.022362 0:2 axvisor::hal:78] IRQ handler 26
[  3.034223 0:2 axvisor::hal:78] IRQ handler 26
[  3.042966 0:2 axvisor::hal:78] IRQ handler 26
[  3.061842 0:2 axvisor::hal:78] IRQ handler 26
[  3.073718 0:2 axvisor::hal:78] IRQ handler 26
[  3.093963 0:2 axvisor::hal:78] IRQ handler 26
[  3.104872 0:2 axvisor::hal:78] IRQ handler 26
[  3.128234 0:2 axvisor::hal:78] IRQ handler 26
[  3.159999 0:2 axvisor::hal:78] IRQ handler 26
[  3.183579 0:2 axvisor::hal:78] IRQ handler 26
[  3.195749 0:2 axvisor::hal:78] IRQ handler 26
[  3.206408 0:2 axvisor::hal:78] IRQ handler 26
[  3.215949 0:2 axvisor::hal:78] IRQ handler 26
[  3.228053 0:2 axvisor::hal:78] IRQ handler 26
[  3.235758 0:2 axvisor::hal:78] IRQ handler 26
[  3.245936 0:2 axvisor::hal:78] IRQ handler 26
[  3.247931 0:2 axvisor::vmm:35] Setting up vcpus...
[  3.250101 0:2 axvisor::vmm::vcpus:219] Initializing VM[1]'s 1 vcpus
[  3.251597 0:2 axvisor::vmm::vcpus:250] Spawning task for VM[1] VCpu[0]
[  3.253122 0:2 axtask::task:115] new task: Task(5, "VM[1]-VCpu[0]")
[  3.255918 0:2 axvisor::hal:78] IRQ handler 26
[  3.260658 0:2 axvisor::vmm::vcpus:262] VCpu task Task(5, "VM[1]-VCpu[0]") created cpumask: [0, ]
[  3.263146 0:2 axtask::run_queue:234] task add: Task(5, "VM[1]-VCpu[0]") on run_queue 0
[  3.264974 0:2 axvisor::vmm:43] VMM starting, booting VMs...
[  3.265831 0:2 axvisor::hal:78] IRQ handler 26
[  3.267456 0:2 axvm::vm:284] Booting VM[1]
[  3.268241 0:2 axvisor::vmm:49] VM[1] boot success
[  3.269031 0:2 axvisor::vmm:60] a VM exited, current running VM count: 1
[  3.270219 0:2 axtask::run_queue:418] task block: Task(2, "main")
[  3.271961 0:3 axtask::task:433] task drop: Task(4, "")
[  3.273955 0:3 axtask::run_queue:418] task block: Task(3, "gc")
[  3.281727 0:5 axvisor::vmm::vcpus:283] VM[1] VCpu[0] waiting for running
[  3.282979 0:5 axvisor::vmm::vcpus:286] VM[1] VCpu[0] running...
[  3.284135 0:5 axvisor::hal:78] IRQ handler 26
[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x410fd083]
[    0.000000] Linux version 6.9.0-rc5-00159-gc942a0cd3603 (aarch64-linux-gnu-gcc (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0, GNU ld (GNU Binutils for Ubuntu) 2.42) #1 SMP PREEMPT Sat May 24 19:04:40 CST 2025
[    0.000000] KASLR enabled
[    0.000000] random: crng init done
[    0.000000] Machine model: linux,dummy-virt
[    0.000000] efi: UEFI not found.
[    0.000000] [Firmware Bug]: Kernel image misaligned at boot, please fix your bootloader!
[    0.000000] earlycon: pl11 at MMIO 0x0000000009000000 (options '')
[    0.000000] printk: legacy bootconsole [pl11] enabled
[    0.000000] NUMA: No NUMA configuration found
[    0.000000] NUMA: Faking a node at [mem 0x0000000080000000-0x00000000bfffffff]
[    0.000000] NUMA: NODE_DATA [mem 0xbfdfe9c0-0xbfe00fff]
[    0.000000] Zone ranges:
[    0.000000]   DMA      [mem 0x0000000080000000-0x00000000bfffffff]
[    0.000000]   DMA32    empty
[    0.000000]   Normal   empty
[    0.000000] Movable zone start for each node
[    0.000000] Early memory node ranges
[    0.000000]   node   0: [mem 0x0000000080000000-0x00000000bfffffff]
[    0.000000] Initmem setup node 0 [mem 0x0000000080000000-0x00000000bfffffff]
[    0.000000] cma: Reserved 32 MiB at 0x00000000bcc00000 on node -1
[    0.000000] psci: probing for conduit method from DT.
[    0.000000] psci: PSCIv1.1 detected in firmware.
[    0.000000] psci: Using standard PSCI v0.2 function IDs
[    0.000000] psci: Trusted OS migration not required
[    0.000000] psci: SMC Calling Convention v1.0
[    0.000000] percpu: Embedded 24 pages/cpu s58728 r8192 d31384 u98304
[    0.000000] Detected PIPT I-cache on CPU0
[    0.000000] CPU features: detected: Spectre-v2
[    0.000000] CPU features: detected: Spectre-v3a
[    0.000000] CPU features: detected: Spectre-v4
[    0.000000] CPU features: detected: Spectre-BHB
[    0.000000] CPU features: kernel page table isolation forced ON by KASLR
[    0.000000] CPU features: detected: Kernel page table isolation (KPTI)
[    0.000000] CPU features: detected: ARM erratum 1742098
[    0.000000] CPU features: detected: ARM errata 1165522, 1319367, or 1530923
[    0.000000] alternatives: applying boot alternatives
[    0.000000] Kernel command line: earlycon console=ttyAMA0 root=/dev/vda rw audit=0 default_hugepagesz=32M hugepagesz=32M hugepages=4
[    0.000000] audit: disabled (until reboot)
[    0.000000] Dentry cache hash table entries: 131072 (order: 8, 1048576 bytes, linear)
[    0.000000] Inode-cache hash table entries: 65536 (order: 7, 524288 bytes, linear)
[    0.000000] Fallback order for Node 0: 0 
[    0.000000] Built 1 zonelists, mobility grouping on.  Total pages: 258048
[    0.000000] Policy zone: DMA
[    0.000000] mem auto-init: stack:all(zero), heap alloc:off, heap free:off
[    0.000000] software IO TLB: SWIOTLB bounce buffer size adjusted to 1MB
[    0.000000] software IO TLB: area num 1.
[    0.000000] software IO TLB: mapped [mem 0x00000000bca00000-0x00000000bcb00000] (1MB)
[    0.000000] Memory: 818484K/1048576K available (16960K kernel code, 4794K rwdata, 11336K rodata, 10048K init, 748K bss, 197324K reserved, 32768K cma-reserved)
[    0.000000] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1
[    0.000000] rcu: Preemptible hierarchical RCU implementation.
[    0.000000] rcu:     RCU event tracing is enabled.
[    0.000000] rcu:     RCU restricting CPUs from NR_CPUS=512 to nr_cpu_ids=1.
[    0.000000]  Trampoline variant of Tasks RCU enabled.
[    0.000000]  Tracing variant of Tasks RCU enabled.
[    0.000000] rcu: RCU calculated value of scheduler-enlistment delay is 25 jiffies.
[    0.000000] rcu: Adjusting geometry for rcu_fanout_leaf=16, nr_cpu_ids=1
[    0.000000] RCU Tasks: Setting shift to 0 and lim to 1 rcu_task_cb_adjust=1.
[    0.000000] RCU Tasks Trace: Setting shift to 0 and lim to 1 rcu_task_cb_adjust=1.
[    0.000000] NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0
[    0.000000] Root IRQ handler: gic_handle_irq
[    0.000000] GICv2m: range[mem 0x08020000-0x08020fff], SPI[80:143]
[    0.000000] rcu: srcu_init: Setting srcu_struct sizes based on contention.
[    0.000000] arch_timer: cp15 timer(s) running at 62.50MHz (virt).
[    0.000000] clocksource: arch_sys_counter: mask: 0x1ffffffffffffff max_cycles: 0x1cd42e208c, max_idle_ns: 881590405314 ns
[    0.000288] sched_clock: 57 bits at 63MHz, resolution 16ns, wraps every 4398046511096ns
[    0.036442] Console: colour dummy device 80x25
[    0.050062] Calibrating delay loop (skipped), value calculated using timer frequency.. 125.00 BogoMIPS (lpj=250000)
[    0.055450] pid_max: default: 32768 minimum: 301
[    0.062206] LSM: initializing lsm=capability
[    0.073041] Mount-cache hash table entries: 2048 (order: 2, 16384 bytes, linear)
[    0.077293] Mountpoint-cache hash table entries: 2048 (order: 2, 16384 bytes, linear)
[    0.137656] spectre-v4 mitigation disabled by command-line option
[    0.153690] cacheinfo: Unable to detect cache hierarchy for CPU 0
[    0.186291] rcu: Hierarchical SRCU implementation.
[    0.188094] rcu:     Max phase no-delay instances is 1000.
[    0.209385] EFI services will not be available.
[    0.212571] smp: Bringing up secondary CPUs ...
[    0.216060] smp: Brought up 1 node, 1 CPU
[    0.219210] SMP: Total of 1 processors activated.
[    0.221045] CPU: All CPU(s) started at EL1
[    0.222827] CPU features: detected: 32-bit EL0 Support
[    0.226735] CPU features: detected: 32-bit EL1 Support
[    0.228450] CPU features: detected: CRC32 instructions
[    0.256636] alternatives: applying system-wide alternatives
[    0.356500] devtmpfs: initialized
[    0.405972] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 7645041785100000 ns
[    0.407975] futex hash table entries: 256 (order: 2, 16384 bytes, linear)
[    0.418935] pinctrl core: initialized pinctrl subsystem
[    0.437381] DMI not present or invalid.
[    0.483441] NET: Registered PF_NETLINK/PF_ROUTE protocol family
[    0.513043] DMA: preallocated 128 KiB GFP_KERNEL pool for atomic allocations
[    0.516121] DMA: preallocated 128 KiB GFP_KERNEL|GFP_DMA pool for atomic allocations
[    0.519460] DMA: preallocated 128 KiB GFP_KERNEL|GFP_DMA32 pool for atomic allocations
[    0.547127] thermal_sys: Registered thermal governor 'step_wise'
[    0.547294] thermal_sys: Registered thermal governor 'power_allocator'
[    0.550996] cpuidle: using governor menu
[    0.561851] hw-breakpoint: found 6 breakpoint and 4 watchpoint registers.
[    0.567056] ASID allocator initialised with 32768 entries
[    0.615987] Serial: AMBA PL011 UART driver
[    0.777892] 9000000.pl011: ttyAMA0 at MMIO 0x9000000 (irq = 14, base_baud = 0) is a PL011 rev1
[    0.786723] printk: legacy console [ttyAMA0] enabled
[    0.786723] printk: legacy console [ttyAMA0] enabled
[    0.791507] printk: legacy bootconsole [pl11] disabled
[    0.791507] printk: legacy bootconsole [pl11] disabled
[    0.836600] Modules: 2G module region forced by RANDOMIZE_MODULE_REGION_FULL
[    0.838688] Modules: 0 pages in range for non-PLT usage
[    0.838756] Modules: 513248 pages in range for PLT usage
[    0.861572] HugeTLB: registered 32.0 MiB page size, pre-allocated 4 pages
[    0.867374] HugeTLB: 0 KiB vmemmap can be freed for a 32.0 MiB page
[    0.869200] HugeTLB: registered 1.00 GiB page size, pre-allocated 0 pages
[    0.871909] HugeTLB: 0 KiB vmemmap can be freed for a 1.00 GiB page
[    0.873162] HugeTLB: registered 2.00 MiB page size, pre-allocated 0 pages
[    0.875112] HugeTLB: 0 KiB vmemmap can be freed for a 2.00 MiB page
[    0.878305] HugeTLB: registered 64.0 KiB page size, pre-allocated 0 pages
[    0.879520] HugeTLB: 0 KiB vmemmap can be freed for a 64.0 KiB page
[    0.900352] Demotion targets for Node 0: null
[    0.940852] ACPI: Interpreter disabled.
[    0.966729] iommu: Default domain type: Translated
[    0.967714] iommu: DMA domain TLB invalidation policy: strict mode
[    0.971561] SCSI subsystem initialized
[    0.983338] usbcore: registered new interface driver usbfs
[    0.990562] usbcore: registered new interface driver hub
[    0.992291] usbcore: registered new device driver usb
[    1.001576] pps_core: LinuxPPS API ver. 1 registered
[    1.005957] pps_core: Software ver. 5.3.6 - Copyright 2005-2007 Rodolfo Giometti &lt;giometti@linux.it&gt;
[    1.008437] PTP clock support registered
[    1.011684] EDAC MC: Ver: 3.0.0
[    1.022379] scmi_core: SCMI protocol bus registered
[    1.038454] FPGA manager framework
[    1.043061] Advanced Linux Sound Architecture Driver Initialized.
[    1.089213] vgaarb: loaded
[    1.095473] clocksource: Switched to clocksource arch_sys_counter
[    1.100861] VFS: Disk quotas dquot_6.6.0
[    1.102308] VFS: Dquot-cache hash table entries: 512 (order 0, 4096 bytes)
[    1.118674] pnp: PnP ACPI: disabled
[    1.196929] NET: Registered PF_INET protocol family
[    1.209905] IP idents hash table entries: 16384 (order: 5, 131072 bytes, linear)
[    1.233308] tcp_listen_portaddr_hash hash table entries: 512 (order: 1, 8192 bytes, linear)
[    1.237928] Table-perturb hash table entries: 65536 (order: 6, 262144 bytes, linear)
[    1.241421] TCP established hash table entries: 8192 (order: 4, 65536 bytes, linear)
[    1.248511] TCP bind hash table entries: 8192 (order: 6, 262144 bytes, linear)
[    1.253783] TCP: Hash tables configured (established 8192 bind 8192)
[    1.269590] UDP hash table entries: 512 (order: 2, 16384 bytes, linear)
[    1.274881] UDP-Lite hash table entries: 512 (order: 2, 16384 bytes, linear)
[    1.280873] NET: Registered PF_UNIX/PF_LOCAL protocol family
[    1.299068] RPC: Registered named UNIX socket transport module.
[    1.300722] RPC: Registered udp transport module.
[    1.302977] RPC: Registered tcp transport module.
[    1.303829] RPC: Registered tcp-with-tls transport module.
[    1.304620] RPC: Registered tcp NFSv4.1 backchannel transport module.
[    1.309214] PCI: CLS 0 bytes, default 64
[    1.320973] kvm [1]: HYP mode not available
[    1.343993] Initialise system trusted keyrings
[    1.349927] workingset: timestamp_bits=42 max_order=18 bucket_order=0
[    1.355432] squashfs: version 4.0 (2009/01/31) Phillip Lougher
[    1.362439] NFS: Registering the id_resolver key type
[    1.366246] Key type id_resolver registered
[    1.367900] Key type id_legacy registered
[    1.369671] nfs4filelayout_init: NFSv4 File Layout Driver Registering...
[    1.371406] nfs4flexfilelayout_init: NFSv4 Flexfile Layout Driver Registering...
[    1.375961] 9p: Installing v9fs 9p2000 file system support
[    1.548079] Key type asymmetric registered
[    1.549583] Asymmetric key parser 'x509' registered
[    1.551477] Block layer SCSI generic (bsg) driver version 0.4 loaded (major 245)
[    1.553519] io scheduler mq-deadline registered
[    1.555682] io scheduler kyber registered
[    1.557515] io scheduler bfq registered
[    1.689339] pl061_gpio 9030000.pl061: PL061 GPIO chip registered
[    1.917432] Serial: 8250/16550 driver, 4 ports, IRQ sharing enabled
[    1.939690] msm_serial: driver initialized
[    1.942655] SuperH (H)SCI(F) driver initialized
[    1.944887] STM32 USART driver initialized
[    1.994145] loop: module loaded
[    1.998003] virtio_blk virtio1: 1/0/0 default/read/poll queues
[    2.019414] virtio_blk virtio1: [vda] 262144 512-byte logical blocks (134 MB/128 MiB)
[    2.086066] megasas: 07.727.03.00-rc1
[    2.143281] tun: Universal TUN/TAP device driver, 1.6
[    2.168923] thunder_xcv, ver 1.0
[    2.171171] thunder_bgx, ver 1.0
[    2.172082] nicpf, ver 1.0
[    2.183282] hns3: Hisilicon Ethernet Network Driver for Hip08 Family - version
[    2.185407] hns3: Copyright (c) 2017 Huawei Corporation.
[    2.187833] hclge is initializing
[    2.189907] e1000: Intel(R) PRO/1000 Network Driver
[    2.194291] e1000: Copyright (c) 1999-2006 Intel Corporation.
[    2.197026] e1000e: Intel(R) PRO/1000 Network Driver
[    2.199487] e1000e: Copyright(c) 1999 - 2015 Intel Corporation.
[    2.201202] igb: Intel(R) Gigabit Ethernet Network Driver
[    2.203195] igb: Copyright (c) 2007-2014 Intel Corporation.
[    2.208414] igbvf: Intel(R) Gigabit Virtual Function Network Driver
[    2.211815] igbvf: Copyright (c) 2009 - 2012 Intel Corporation.
[    2.217703] sky2: driver version 1.30
[    2.231724] VFIO - User Level meta-driver version: 0.3
[    2.256522] usbcore: registered new interface driver usb-storage
[    2.285010] rtc-pl031 9010000.pl031: registered as rtc0
[    2.291135] rtc-pl031 9010000.pl031: setting system clock to 2025-05-24T12:12:45 UTC (1748088765)
[    2.305376] i2c_dev: i2c /dev entries driver
[    2.357740] sdhci: Secure Digital Host Controller Interface driver
[    2.360750] sdhci: Copyright(c) Pierre Ossman
[    2.369061] Synopsys Designware Multimedia Card Interface Driver
[    2.386237] sdhci-pltfm: SDHCI platform and OF driver helper
[    2.405103] ledtrig-cpu: registered to indicate activity on CPUs
[    2.423050] usbcore: registered new interface driver usbhid
[    2.429629] usbhid: USB HID core driver
[    2.457709] hw perfevents: enabled with armv8_pmuv3 PMU driver, 7 counters available
[    2.491336] NET: Registered PF_PACKET protocol family
[    2.494196] 9pnet: Installing 9P2000 support
[    2.496420] Key type dns_resolver registered
[    2.588714] registered taskstats version 1
[    2.603149] Loading compiled-in X.509 certificates
[    2.675589] input: gpio-keys as /devices/platform/gpio-keys/input/input0
[    2.687325] clk: Disabling unused clocks
[    2.688184] PM: genpd: Disabling unused power domains
[    2.690198] ALSA device list:
[    2.692659]   No soundcards found.
[    2.777634] EXT4-fs (vda): mounted filesystem 084a1df9-07a8-4252-9556-c0e5b37ac197 r/w with ordered data mode. Quota mode: none.
[    2.781437] VFS: Mounted root (ext4 filesystem) on device 254:0.
[    2.795879] devtmpfs: mounted
[    2.902895] Freeing unused kernel memory: 10048K
[    2.906033] Run /sbin/init as init process
[    2.924817] Run /etc/init as init process
[    2.927201] Run /bin/init as init process
[    2.933254] Run /bin/sh as init process
/bin/sh: 0: can't access tty; job control turned off
# 
</code></pre>
</li>
</ol>
<h2 id="arceos--linux"><a class="header" href="#arceos--linux">ArceOS + Linux</a></h2>
<h3 id="准备相关镜像"><a class="header" href="#准备相关镜像">准备相关镜像</a></h3>
<p>首先，根据以上两个章节的介绍分别制作 <code>helloworld_aarch64-qemu-virt.bin</code>、<code>Image</code> 及 <code>linux-qemu.dtb</code> 镜像文件</p>
<h3 id="从文件系统加载运行-3"><a class="header" href="#从文件系统加载运行-3">从文件系统加载运行</a></h3>
<p>获取 AxVisor 主线代码 <code>git clone git@github.com:arceos-hypervisor/axvisor.git</code>，然后在 <code>axvisor</code> 源码目录中执行如下步骤：</p>
<ol>
<li>
<p>执行 <code>make ubuntu_img ARCH=aarch64</code> 制作一个简单的根文件系统镜像 <code>disk.img</code> 作为 Linux 客户机启动之后的文件系统，然后手动挂载 <code>disk.img</code>，然后将 Image 和 linux-qemu.dtb 复制到该文件系统中</p>
<pre><code class="language-bash">$ mkdir -p tmp
$ sudo mount disk.img tmp
$ sudo cp /path/to/Image tmp/boot/
$ sudo cp linux-qemu.dtb tmp/boot/
$ sudo cp /path/to/helloworld_aarch64-qemu-virt.bin tmp/boot/
$ sudo umount tmp
</code></pre>
</li>
<li>
<p>修改对应的 <code>./configs/vms/linux-qemu-aarch64-vm2.toml</code> 和 <code>./configs/vms/arceos-aarch64.toml</code> 中的配置项</p>
<ul>
<li><code>image_location="fs"</code> 表示从文件系统加载</li>
<li><code>kernel_path</code> 指出内核镜像在文件系统中的路径</li>
<li><code>entry_point</code> 指出内核镜像的入口地址</li>
<li><code>kernel_load_addr</code> 指出内核镜像的加载地址</li>
<li>其他</li>
</ul>
</li>
<li>
<p>执行 <code>make ARCH=aarch64 VM_CONFIGS=configs/vms/arceos-aarch64.toml:configs/vms/linux-qemu-aarch64-vm2.toml LOG=info BUS=mmio NET=y FEATURES=page-alloc-64g MEM=8g SECOND_SERIAL=y SMP=2 run</code> 构建 AxVisor，并在 QEMU 中启动。此时，终端将阻等待 Telnet 命令</p>
<pre><code>qemu-system-aarch64 -m 8g -smp 2 -cpu cortex-a72 -machine virt,virtualization=on,gic-version=2 -kernel /home/zcs/WORKSPACE/arceos_hypervisor/axvisor/axvisor_aarch64-qemu-virt-hv.bin -device virtio-blk-device,drive=disk0 -drive id=disk0,if=none,format=raw,file=disk.img -device virtio-net-device,netdev=net0 -netdev user,id=net0,hostfwd=tcp::5555-:5555,hostfwd=udp::5555-:5555 -nographic -machine virtualization=on,gic-version=2 -serial mon:stdio -serial telnet:localhost:4321,server
qemu-system-aarch64: -serial telnet:localhost:4321,server: info: QEMU waiting for connection on: disconnected:telnet:127.0.0.1:4321,server=on
</code></pre>
</li>
<li>
<p>启动另一个终端，然后执行 <code>telnet localhost 4321</code>，上一个终端将继续运行，并输出第一个虚拟机启动信息，第二个虚拟机启动信息将在当前终端输出。</p>
</li>
</ol>
<h3 id="从内存加载运行-2"><a class="header" href="#从内存加载运行-2">从内存加载运行</a></h3>
<p>获取 AxVisor 主线代码 <code>git clone git@github.com:arceos-hypervisor/axvisor.git</code>，然后在 <code>axvisor</code> 源码目录中执行如下步骤：</p>
<ol>
<li>
<p>执行 <code>make ubuntu_img ARCH=aarch64</code> 制作一个简单的根文件系统镜像 <code>disk.img</code> 作为 Linux 客户机启动之后的文件系统</p>
</li>
<li>
<p>修改对应的 <code>./configs/vms/linux-qemu-aarch64-vm2.toml</code> 和 <code>./configs/vms/arceos-aarch64.toml</code> 中的配置项</p>
<ul>
<li><code>image_location="memory"</code> 配置项</li>
<li><code>kernel_path</code> 指定内核镜像在工作空间中的相对/绝对路径</li>
<li><code>entry_point</code> 指出内核镜像的入口地址</li>
<li><code>kernel_load_addr</code> 指出内核镜像的加载地址</li>
<li>其他</li>
</ul>
</li>
<li>
<p>执行 <code>make ARCH=aarch64 VM_CONFIGS=configs/vms/arceos-aarch64.toml:configs/vms/linux-qemu-aarch64-vm2.toml LOG=info BUS=mmio NET=y FEATURES=page-alloc-64g MEM=8g SECOND_SERIAL=y SMP=2 run</code> 构建 AxVisor，并在 QEMU 中启动。此时，终端将阻等待 Telnet 命令</p>
<pre><code>qemu-system-aarch64 -m 8g -smp 2 -cpu cortex-a72 -machine virt,virtualization=on,gic-version=2 -kernel /home/zcs/WORKSPACE/arceos_hypervisor/axvisor/axvisor_aarch64-qemu-virt-hv.bin -device virtio-blk-device,drive=disk0 -drive id=disk0,if=none,format=raw,file=disk.img -device virtio-net-device,netdev=net0 -netdev user,id=net0,hostfwd=tcp::5555-:5555,hostfwd=udp::5555-:5555 -nographic -machine virtualization=on,gic-version=2 -serial mon:stdio -serial telnet:localhost:4321,server
qemu-system-aarch64: -serial telnet:localhost:4321,server: info: QEMU waiting for connection on: disconnected:telnet:127.0.0.1:4321,server=on
</code></pre>
</li>
<li>
<p>启动另一个终端，然后执行 <code>telnet localhost 4321</code>，上一个终端将继续运行，并输出第一个虚拟机启动信息，第二个虚拟机启动信息将在当前终端输出。</p>
</li>
</ol>
<h2 id="注意事项"><a class="header" href="#注意事项">注意事项</a></h2>
<p>在同时启动 ArceOS 和 Linux 客户机时，若启动 axvisor 后只有一个 vm 有输出，另一个无显示，可能是 qemu 配置选项不全，需查看当前 qemu 版本，建议使用 9.2.2 版本，安装过程如下</p>
<pre><code class="language-bash"># 安装编译所需的依赖包
sudo apt install autoconf automake autotools-dev curl libmpc-dev libmpfr-dev libgmp-dev \
              gawk build-essential bison flex texinfo gperf libtool patchutils bc \
              zlib1g-dev libexpat-dev pkg-config  libglib2.0-dev libpixman-1-dev libsdl2-dev \
              git tmux python3 python3-pip ninja-build
# 下载源码
wget https://download.qemu.org/qemu-9.2.2.tar.xz  
# 解压
tar xvJf qemu-9.2.2.tar.xz
cd qemu-9.2.2
# 生成设置文件
./configure --enable-kvm --enable-slirp --enable-debug --target-list=aarch64-softmmu,x86_64-softmmu
# 编译
make -j$(nproc)
</code></pre>
<p>之后编辑 <code>~/.bashrc</code> 文件，在文件的末尾加入几行：</p>
<pre><code class="language-bash">export PATH=/path/to/qemu-9.2.2/build:$PATH
</code></pre>
<p>最后，执行 <code>source ~/.bashrc</code> 更新当前 shell 即可</p>
<h2 id="已知问题"><a class="header" href="#已知问题">已知问题</a></h2>
<ol>
<li>ArceOS 从内存中加载启动时，如果没有 disk.img 将报错</li>
<li>通过fs方式启动linux时，如果出现以下报错</li>
</ol>
<pre><code class="language-bash">error: could not find native static library `lwext4-aarch64`, perhaps an -L flag is missing?

error: could not compile `lwext4_rust` (lib) due to 1 previous error
warning: build failed, waiting for other jobs to finish...
make: *** [scripts/make/build.mk:42: _cargo_build] Error 101
</code></pre>
<p>有可能是本地缺少交叉编译环境 <code>aarch64-linux-musl-cross</code> 或 <code>cmake(version &lt; 3.5)</code></p>
<pre><code class="language-bash"># install aarch64-linux-musl-cross
wget https://musl.cc/aarch64-linux-musl-cross.tgz
sudo tar -xvf aarch64-linux-musl-cross.tgz -C /opt/
echo 'export PATH=/opt/aarch64-linux-musl-cross/bin/:$PATH' &gt;&gt; ~/.bashrc
source ~/.bashrc
# install cmake
sudo apt-get install cmake
</code></pre>
<style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () => window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () => { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY <200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() => { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () => { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() => { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) => (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) => { btn.addEventListener("click", (event) => { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="run-axvisor-on-qemu-x86_64"><a class="header" href="#run-axvisor-on-qemu-x86_64">Run AxVisor on QEMU x86_64</a></h1>
<p>目前，在 QEMU x86_64 平台上已经对独立运行 ArceOS 和 nimbos 进行了验证。</p>
<blockquote>
<p>前提条件：</p>
<ul>
<li>CPU 虚拟化已启用</li>
<li>KVM 内核模块正常</li>
<li>当前用户在 <code>kvm</code> 组中</li>
<li><code>/dev/kvm</code> 权限正常</li>
</ul>
</blockquote>
<h2 id="arceos-2"><a class="header" href="#arceos-2">ArceOS</a></h2>
<h3 id="准备-arceos-镜像-1"><a class="header" href="#准备-arceos-镜像-1">准备 ArceOS 镜像</a></h3>
<ol>
<li>
<p>获取 ArceOS 主线代码 <code>git clone https://github.com/arceos-org/arceos.git</code></p>
</li>
<li>
<p>在 <code>arceos</code> 源码目录中执行 <code>make ARCH=x86_64 SMP=1 A=examples/helloworld</code> 获得 <code>examples/helloworld/helloworld_x86_64-qemu-q35.bin</code></p>
</li>
</ol>
<h3 id="从文件系统加载运行-4"><a class="header" href="#从文件系统加载运行-4">从文件系统加载运行</a></h3>
<p>获取 AxVisor 主线代码 <code>git clone git@github.com:arceos-hypervisor/axvisor.git</code>，然后在 <code>axvisor</code> 源码目录中执行如下步骤：</p>
<ol>
<li>
<p>制作一个磁盘镜像文件，并将 ArceOS 客户机镜像放到磁盘镜像文件系统中</p>
<ol>
<li>
<p>使用 <code>make disk_img</code> 命令生成一个空的 FAT32 磁盘镜像文件 <code>disk.img</code></p>
</li>
<li>
<p>手动挂载 <code>disk.img</code>，然后将ArceOS 客户机镜像复制到该文件系统中即可</p>
<pre><code class="language-bash">$ mkdir -p tmp
$ sudo mount disk.img tmp
$ sudo cp helloworld_x86_64-qemu-q35.bin tmp/
$ sudo wget https://github.com/arceos-hypervisor/axvm-bios-x86/releases/download/v0.1/axvm-bios.bin
$ sudo cp axvm-bios.bin tmp/  #axvm-bios.bin对应配置文件中的bios_path
$ sudo umount tmp
</code></pre>
</li>
</ol>
</li>
<li>
<p>修改对应的 <code>./configs/vms/arceos-x86_64.toml</code> 文件中的配置项</p>
<pre><code class="language-toml">[kernel]
# The entry point of the kernel image.
entry_point = 0x20_0000
# The location of image: "memory" | "fs".
# Load from file system.
image_location = "fs"
# The file path of the BIOS image.
bios_path = "axvm-bios.bin"
# The load address of the BIOS image.
bios_load_addr = 0x8000
# The file path of the kernel image.
kernel_path = "helloworld_x86_64-qemu-q35.bin"
# The load address of the kernel image.
kernel_load_addr = 0x20_0000
</code></pre>
<ul>
<li><code>image_location="fs"</code> 表示从文件系统加载</li>
<li><code>kernel_path</code> 指出内核镜像在文件系统中的路径</li>
<li><code>entry_point</code> 指出内核镜像的入口地址。必须与上面构建的 ArceOS 内核镜像的入口地址一致</li>
<li><code>kernel_load_addr</code> 指出内核镜像的加载地址。默认与 <code>entry_point</code> 一致</li>
<li><code>bios_path</code> 可通过 <a href="https://github.com/arceos-hypervisor/axvm-bios-x86/releases/download/v0.1/axvm-bios.bin">链接</a> 直接下载，或参考 x86_64 用户虚拟机的极简BIOS实现 <a href="https://github.com/arceos-hypervisor/axvm-bios-x86">axvm-bios</a></li>
<li><code>bios_load_addr</code> 指出 bios 镜像的加载地址，默认为  0x8000</li>
<li>其他</li>
</ul>
</li>
<li>
<p>执行 <code>make ACCEL=y ARCH=x86_64 LOG=info VM_CONFIGS=configs/vms/arceos-x86_64.toml FEATURES=page-alloc-64g APP_FEATURES=fs run</code> 构建 AxVisor，并在 QEMU 中启动。</p>
<pre><code class="language-plaintext">       d8888                            .d88888b.   .d8888b.
      d88888                           d88P" "Y88b d88P  Y88b
     d88P888                           888     888 Y88b.
    d88P 888 888d888  .d8888b  .d88b.  888     888  "Y888b.
   d88P  888 888P"   d88P"    d8P  Y8b 888     888     "Y88b.
  d88P   888 888     888      88888888 888     888       "888
 d8888888888 888     Y88b.    Y8b.     Y88b. .d88P Y88b  d88P
d88P     888 888      "Y8888P  "Y8888   "Y88888P"   "Y8888P"

arch = x86_64
platform = x86_64-qemu-q35
target = x86_64-unknown-none
build_mode = release
log_level = info
smp = 1

[  0.003642 0 axruntime:139] Logging is enabled.
[  0.004011 0 axruntime:140] Primary CPU 0 started, dtb = 0x0.
[  0.004456 0 axruntime:142] Found physcial memory regions:
[  0.004886 0 axruntime:144]   [PA:0x200000, PA:0x29c000) .text (READ | EXECUTE | RESERVED)
[  0.005505 0 axruntime:144]   [PA:0x29c000, PA:0x2c2000) .rodata (READ | RESERVED)
[  0.006078 0 axruntime:144]   [PA:0x2c2000, PA:0x2cf000) .data .tdata .tbss .percpu (READ | WRITE | RESERVED)
[  0.006846 0 axruntime:144]   [PA:0x2cf000, PA:0x30f000) boot stack (READ | WRITE | RESERVED)
[  0.007470 0 axruntime:144]   [PA:0x30f000, PA:0x535000) .bss (READ | WRITE | RESERVED)
[  0.008057 0 axruntime:144]   [PA:0x1000, PA:0x9f000) low memory (READ | WRITE | RESERVED)
[  0.008671 0 axruntime:144]   [PA:0x535000, PA:0x8000000) free memory (READ | WRITE | FREE)
[  0.009310 0 axruntime:144]   [PA:0xb0000000, PA:0xc0000000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.009987 0 axruntime:144]   [PA:0xfe000000, PA:0xfec00000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.010710 0 axruntime:144]   [PA:0x7000000000, PA:0x7000004000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.011422 0 axruntime:144]   [PA:0xfec00000, PA:0xfec01000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.012132 0 axruntime:144]   [PA:0xfed00000, PA:0xfed01000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.012814 0 axruntime:144]   [PA:0xfee00000, PA:0xfee01000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.013487 0 axruntime:144]   [PA:0x380000000000, PA:0x380000004000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.014202 0 axruntime:226] Initialize global memory allocator...
[  0.014645 0 axruntime:227]   use TLSF allocator.
[  0.015039 0 axmm:72] Initialize virtual memory management...
[  0.016289 0 axruntime:159] Initialize platform devices...
[  0.016756 0 axhal::platform::x86_pc::apic:90] Initialize Local APIC...
[  0.017259 0 axhal::platform::x86_pc::apic:105] Using x2APIC.
[  0.017793 0 axhal::platform::x86_pc::apic:119] Initialize IO APIC...
[  0.018276 0 axtask::api:73] Initialize scheduling...
[  0.018680 0:2 axtask::api:79]   use FIFO scheduler.
[  0.019085 0:2 axdriver:172] Initialize device drivers...
[  0.019518 0:2 axdriver:173]   device model: static
[  0.034235 0:2 virtio_drivers::device::blk:59] config: 0xffff807000002000
[  0.034788 0:2 virtio_drivers::device::blk:64] found a block device of size 65536KB
[  0.035418 0:2 axdriver::bus::pci:104] registered a new Block device at 00:03.0: "virtio-blk"
[  0.186017 0:2 axfs:41] Initialize filesystems...
[  0.186444 0:2 axfs:44]   use block device 0: "virtio-blk"
[  0.195781 0:2 fatfs::dir:139] Is a directory
[  0.207073 0:2 fatfs::dir:139] Is a directory
[  0.219798 0:2 fatfs::dir:139] Is a directory
[  0.234592 0:2 fatfs::dir:139] Is a directory
[  0.238156 0:2 axruntime:192] Initialize interrupt handlers...
[  0.238621 0:2 axruntime:204] Primary CPU 0 init OK.


       d8888            888     888  d8b
      d88888            888     888  Y8P
     d88P888            888     888
    d88P 888  888  888  Y88b   d88P  888  .d8888b    .d88b.   888d888
   d88P  888  `Y8bd8P'   Y88b d88P   888  88K       d88""88b  888P"
  d88P   888    X88K      Y88o88P    888  "Y8888b.  888  888  888
 d8888888888  .d8""8b.     Y888P     888       X88  Y88..88P  888
d88P     888  888  888      Y8P      888   88888P'   "Y88P"   888


by AxVisor Team

[  0.241689 0:2 axvisor:21] Starting virtualization...
[  0.242094 0:2 axvisor:22] Hardware support: true
[  0.242489 0:4 axvisor::vmm::timer:101] Initing HV Timer...
[  0.242947 0:4 x86_vcpu::vmx::percpu:114] [AxVM] succeeded to turn on VMX.
[  0.243469 0:4 axvisor::hal:122] Hardware virtualization support enabled on core 0
[  0.244144 0:2 axvisor::vmm::config:33] Creating VM[1] "arceos"
[  0.244627 0:2 x86_vcpu::vmx::vcpu:178] [HV] created VmxVcpu(vmcs: PA:0x7d2000)
[  0.245181 0:2 axvm::vm:114] Setting up memory region: [0x0~0x1000000] READ | WRITE | EXECUTE
[  0.246636 0:2 axvm::vm:166] Setting up passthrough device memory region: [0xfec00000~0xfec01000] -&gt; [0xfec00000~0xfec01000]
[  0.247567 0:2 axvm::vm:166] Setting up passthrough device memory region: [0xfee00000~0xfee01000] -&gt; [0xfee00000~0xfee01000]
[  0.248367 0:2 axvm::vm:166] Setting up passthrough device memory region: [0xfed00000~0xfed01000] -&gt; [0xfed00000~0xfed01000]
[  0.249164 0:2 axvm::vm:202] VM[1] created
[  0.249583 0:2 axvm::vm:217] VM[1] vcpus set up
[  0.249960 0:2 axvisor::vmm::config:40] VM[1] created success, loading images...
[  0.250513 0:2 axvisor::vmm::images:49] Loading VM[1] images from memory
[  0.251069 0:2 axvisor::vmm:35] Setting up vcpus...
[  0.251467 0:2 axvisor::vmm::vcpus:219] Initializing VM[1]'s 1 vcpus
[  0.251964 0:2 axvisor::vmm::vcpus:250] Spawning task for VM[1] VCpu[0]
[  0.252468 0:2 axvisor::vmm::vcpus:262] VCpu task Task(5, "VM[1]-VCpu[0]") created cpumask: [0, ]
[  0.253119 0:2 axvisor::vmm:43] VMM starting, booting VMs...
[  0.253561 0:2 axvm::vm:284] Booting VM[1]
[  0.253904 0:2 axvisor::vmm:49] VM[1] boot success
[  0.254292 0:2 axvisor::vmm:60] a VM exited, current running VM count: 1
[  0.254803 0:5 axvisor::vmm::vcpus:283] VM[1] VCpu[0] waiting for running
[  0.255321 0:5 axvisor::vmm::vcpus:286] VM[1] VCpu[0] running...
[  0.256999 0:5 x86_vcpu::vmx::vcpu:1018] handle_cpuid: Failed to get TSC frequency by CPUID, default to 3000 MHz
Got TSC frequency by CPUID: 3000 MHz

       d8888                            .d88888b.   .d8888b.
      d88888                           d88P" "Y88b d88P  Y88b
     d88P888                           888     888 Y88b.
    d88P 888 888d888  .d8888b  .d88b.  888     888  "Y888b.
   d88P  888 888P"   d88P"    d8P  Y8b 888     888     "Y88b.
  d88P   888 888     888      88888888 888     888       "888
 d8888888888 888     Y88b.    Y8b.     Y88b. .d88P Y88b  d88P
d88P     888 888      "Y8888P  "Y8888   "Y88888P"   "Y8888P"

arch = x86_64
platform = x86_64-qemu-q35
target = x86_64-unknown-none
build_mode = release
log_level = info
smp = 1

[  0.004683 0 axruntime:139] Logging is enabled.
[  0.005191 0 axruntime:140] Primary CPU 0 started, dtb = 0x0.
[  0.005791 0 axruntime:142] Found physcial memory regions:
[  0.006373 0 axruntime:144]   [PA:0x200000, PA:0x209000) .text (READ | EXECUTE | RESERVED)
[  0.007194 0 axruntime:144]   [PA:0x209000, PA:0x20c000) .rodata (READ | RESERVED)
[  0.007951 0 axruntime:144]   [PA:0x20c000, PA:0x213000) .data .tdata .tbss .percpu (READ | WRITE | RESERVED)
[  0.008902 0 axruntime:144]   [PA:0x213000, PA:0x253000) boot stack (READ | WRITE | RESERVED)
[  0.009744 0 axruntime:144]   [PA:0x253000, PA:0x255000) .bss (READ | WRITE | RESERVED)
[  0.010539 0 axruntime:144]   [PA:0x1000, PA:0x9f000) low memory (READ | WRITE | RESERVED)
[  0.011352 0 axruntime:144]   [PA:0x255000, PA:0x8000000) free memory (READ | WRITE | FREE)
[  0.012174 0 axruntime:144]   [PA:0xb0000000, PA:0xc0000000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.013060 0 axruntime:144]   [PA:0xfe000000, PA:0xfec00000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.013941 0 axruntime:144]   [PA:0xfec00000, PA:0xfec01000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.014821 0 axruntime:144]   [PA:0xfed00000, PA:0xfed01000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.015699 0 axruntime:144]   [PA:0xfee00000, PA:0xfee01000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.016586 0 axruntime:144]   [PA:0x380000000000, PA:0x380000004000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.017540 0 axruntime:159] Initialize platform devices...
[  0.018125 0 axhal::platform::x86_pc::apic:90] Initialize Local APIC...
[  0.018920 0 axhal::platform::x86_pc::apic:105] Using x2APIC.
[  0.019645 0 axhal::platform::x86_pc::apic:119] Initialize IO APIC...
[  0.020322 0 axruntime:204] Primary CPU 0 init OK.
Hello, world!
[  0.020959 0 axhal::platform::x86_pc::misc:7] Shutting down...
[  0.274173 0:5 axvisor::vmm::vcpus:351] VM[1] run VCpu[0] SystemDown
[  0.274663 0:5 axvm::vm:306] Shutting down VM[1]
[  0.275045 0:5 axvisor::vmm::vcpus:366] VM[1] VCpu[0] shutting down because of VM shutdown
[  0.275653 0:5 axvisor::vmm::vcpus:372] VM[1] VCpu[0] last VCpu exiting, decreasing running VM count
[  0.276317 0:5 axvisor::vmm::vcpus:385] VM[1] VCpu[0] exiting...
[  0.276788 0:2 axvisor::vmm:60] a VM exited, current running VM count: 0
[  0.277301 0:2 axhal::platform::x86_pc::misc:7] Shutting down...
</code></pre>
</li>
</ol>
<h3 id="从内存加载运行-3"><a class="header" href="#从内存加载运行-3">从内存加载运行</a></h3>
<p>获取 AxVisor 主线代码 <code>git clone git@github.com:arceos-hypervisor/axvisor.git</code>，然后在 <code>axvisor</code> 源码目录中执行如下步骤：</p>
<ol>
<li>
<p>修改对应的 <code>./configs/vms/arceos-x86_64.toml</code> 中的配置项，注意设置 <code>kernel_path</code>  和 <code>bios_path</code> 为 arceos 二进制内核镜像在工作空间中的相对/绝对路径</p>
<pre><code class="language-toml">[kernel]
# The entry point of the kernel image.
entry_point = 0x20_0000
# The location of image: "memory" | "fs".
# Load from file system.
image_location = "memory"
# The file path of the BIOS image.
bios_path = "axvm-bios.bin"
# The load address of the BIOS image.
bios_load_addr = 0x8000
# The file path of the kernel image.
kernel_path = "/arceos/examples/helloworld/helloworld_x86_64-qemu-q35.bin"
# The load address of the kernel image.
kernel_load_addr = 0x20_0000
</code></pre>
<ul>
<li><code>image_location="memory"</code> 配置项</li>
<li><code>kernel_path</code> 指定内核镜像在工作空间中的相对/绝对路径</li>
<li><code>entry_point</code> 指出内核镜像的入口地址。必须与上面构建的 ArceOS 内核镜像的入口地址一致</li>
<li><code>kernel_load_addr</code> 指出内核镜像的加载地址。默认与 <code>entry_point</code> 一致</li>
<li><code>bios_path</code> 可通过 <a href="https://github.com/arceos-hypervisor/axvm-bios-x86/releases/download/v0.1/axvm-bios.bin">链接</a> 直接下载，或参考 x86_64 用户虚拟机的极简BIOS实现 <a href="https://github.com/arceos-hypervisor/axvm-bios-x86">axvm-bios</a></li>
<li><code>bios_load_addr</code> 指出 bios 镜像的加载地址，默认为  0x8000</li>
<li>其他</li>
</ul>
</li>
<li>
<p>执行 <code>make ACCEL=y ARCH=x86_64 LOG=info VM_CONFIGS=configs/vms/arceos-x86_64.toml FEATURES=page-alloc-64g run</code> 构建 AxVisor，并在 QEMU 中启动。</p>
<pre><code class="language-plaintext">       d8888                            .d88888b.   .d8888b.
      d88888                           d88P" "Y88b d88P  Y88b
     d88P888                           888     888 Y88b.
    d88P 888 888d888  .d8888b  .d88b.  888     888  "Y888b.
   d88P  888 888P"   d88P"    d8P  Y8b 888     888     "Y88b.
  d88P   888 888     888      88888888 888     888       "888
 d8888888888 888     Y88b.    Y8b.     Y88b. .d88P Y88b  d88P
d88P     888 888      "Y8888P  "Y8888   "Y88888P"   "Y8888P"

arch = x86_64
platform = x86_64-qemu-q35
target = x86_64-unknown-none
build_mode = release
log_level = info
smp = 1

[  0.003637 0 axruntime:139] Logging is enabled.
[  0.004031 0 axruntime:140] Primary CPU 0 started, dtb = 0x0.
[  0.004512 0 axruntime:142] Found physcial memory regions:
[  0.004939 0 axruntime:144]   [PA:0x200000, PA:0x274000) .text (READ | EXECUTE | RESERVED)
[  0.005601 0 axruntime:144]   [PA:0x274000, PA:0x293000) .rodata (READ | RESERVED)
[  0.006194 0 axruntime:144]   [PA:0x293000, PA:0x29e000) .data .tdata .tbss .percpu (READ | WRITE | RESERVED)
[  0.006942 0 axruntime:144]   [PA:0x29e000, PA:0x2de000) boot stack (READ | WRITE | RESERVED)
[  0.007597 0 axruntime:144]   [PA:0x2de000, PA:0x504000) .bss (READ | WRITE | RESERVED)
[  0.008186 0 axruntime:144]   [PA:0x1000, PA:0x9f000) low memory (READ | WRITE | RESERVED)
[  0.008791 0 axruntime:144]   [PA:0x504000, PA:0x8000000) free memory (READ | WRITE | FREE)
[  0.009406 0 axruntime:144]   [PA:0xb0000000, PA:0xc0000000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.010126 0 axruntime:144]   [PA:0xfe000000, PA:0xfec00000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.010853 0 axruntime:144]   [PA:0x7000000000, PA:0x7000004000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.011530 0 axruntime:144]   [PA:0xfec00000, PA:0xfec01000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.012192 0 axruntime:144]   [PA:0xfed00000, PA:0xfed01000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.012824 0 axruntime:144]   [PA:0xfee00000, PA:0xfee01000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.013483 0 axruntime:144]   [PA:0x380000000000, PA:0x380000004000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.014188 0 axruntime:226] Initialize global memory allocator...
[  0.014651 0 axruntime:227]   use TLSF allocator.
[  0.015030 0 axmm:72] Initialize virtual memory management...
[  0.016096 0 axruntime:159] Initialize platform devices...
[  0.016508 0 axhal::platform::x86_pc::apic:90] Initialize Local APIC...
[  0.017015 0 axhal::platform::x86_pc::apic:105] Using x2APIC.
[  0.017472 0 axhal::platform::x86_pc::apic:119] Initialize IO APIC...
[  0.018022 0 axtask::api:73] Initialize scheduling...
[  0.018548 0:2 axtask::api:79]   use FIFO scheduler.
[  0.018938 0:2 axruntime:192] Initialize interrupt handlers...
[  0.019409 0:2 axruntime:204] Primary CPU 0 init OK.


    _         __     ___
   / \   __  _\ \   / (_)___  ___  _ __
  / _ \  \ \/ /\ \ / /| / __|/ _ \| '__|
 / ___ \  &gt;  &lt;  \ V / | \__ \ (_) | |
/_/   \_\/_/\_\  \_/  |_|___/\___/|_|


by AxVisor Team

[  0.021007 0:2 axvisor:21] Starting virtualization...
[  0.021431 0:2 axvisor:22] Hardware support: true
[  0.021979 0:4 axvisor::vmm::timer:101] Initing HV Timer...
[  0.022427 0:4 x86_vcpu::vmx::percpu:114] [AxVM] succeeded to turn on VMX.
[  0.022951 0:4 axvisor::hal:122] Hardware virtualization support enabled on core 0
[  0.023648 0:2 axvisor::vmm::config:33] Creating VM[1] "arceos"
[  0.024115 0:2 x86_vcpu::vmx::vcpu:178] [HV] created VmxVcpu(vmcs: PA:0x79f000)
[  0.024657 0:2 axvm::vm:114] Setting up memory region: [0x0~0x1000000] READ | WRITE | EXECUTE
[  0.026157 0:2 axvm::vm:166] Setting up passthrough device memory region: [0xfec00000~0xfec01000] -&gt; [0xfec00000~0xfec01000]
[  0.027071 0:2 axvm::vm:166] Setting up passthrough device memory region: [0xfee00000~0xfee01000] -&gt; [0xfee00000~0xfee01000]
[  0.027859 0:2 axvm::vm:166] Setting up passthrough device memory region: [0xfed00000~0xfed01000] -&gt; [0xfed00000~0xfed01000]
[  0.028701 0:2 axvm::vm:202] VM[1] created
[  0.029123 0:2 axvm::vm:217] VM[1] vcpus set up
[  0.029526 0:2 axvisor::vmm::config:40] VM[1] created success, loading images...
[  0.030074 0:2 axvisor::vmm::images:49] Loading VM[1] images from memory
[  0.030612 0:2 axvisor::vmm:35] Setting up vcpus...
[  0.031005 0:2 axvisor::vmm::vcpus:219] Initializing VM[1]'s 1 vcpus
[  0.031514 0:2 axvisor::vmm::vcpus:250] Spawning task for VM[1] VCpu[0]
[  0.032018 0:2 axvisor::vmm::vcpus:262] VCpu task Task(5, "VM[1]-VCpu[0]") created cpumask: [0, ]
[  0.032728 0:2 axvisor::vmm:43] VMM starting, booting VMs...
[  0.033172 0:2 axvm::vm:284] Booting VM[1]
[  0.033514 0:2 axvisor::vmm:49] VM[1] boot success
[  0.033897 0:2 axvisor::vmm:60] a VM exited, current running VM count: 1
[  0.034401 0:5 axvisor::vmm::vcpus:283] VM[1] VCpu[0] waiting for running
[  0.034906 0:5 axvisor::vmm::vcpus:286] VM[1] VCpu[0] running...
[  0.036693 0:5 x86_vcpu::vmx::vcpu:1018] handle_cpuid: Failed to get TSC frequency by CPUID, default to 3000 MHz
Got TSC frequency by CPUID: 3000 MHz

       d8888                            .d88888b.   .d8888b.
      d88888                           d88P" "Y88b d88P  Y88b
     d88P888                           888     888 Y88b.
    d88P 888 888d888  .d8888b  .d88b.  888     888  "Y888b.
   d88P  888 888P"   d88P"    d8P  Y8b 888     888     "Y88b.
  d88P   888 888     888      88888888 888     888       "888
 d8888888888 888     Y88b.    Y8b.     Y88b. .d88P Y88b  d88P
d88P     888 888      "Y8888P  "Y8888   "Y88888P"   "Y8888P"

arch = x86_64
platform = x86_64-qemu-q35
target = x86_64-unknown-none
build_mode = release
log_level = info
smp = 1

[  0.004983 0 axruntime:139] Logging is enabled.
[  0.005525 0 axruntime:140] Primary CPU 0 started, dtb = 0x0.
[  0.006186 0 axruntime:142] Found physcial memory regions:
[  0.006782 0 axruntime:144]   [PA:0x200000, PA:0x209000) .text (READ | EXECUTE | RESERVED)
[  0.007625 0 axruntime:144]   [PA:0x209000, PA:0x20c000) .rodata (READ | RESERVED)
[  0.008407 0 axruntime:144]   [PA:0x20c000, PA:0x213000) .data .tdata .tbss .percpu (READ | WRITE | RESERVED)
[  0.009356 0 axruntime:144]   [PA:0x213000, PA:0x253000) boot stack (READ | WRITE | RESERVED)
[  0.010234 0 axruntime:144]   [PA:0x253000, PA:0x255000) .bss (READ | WRITE | RESERVED)
[  0.011091 0 axruntime:144]   [PA:0x1000, PA:0x9f000) low memory (READ | WRITE | RESERVED)
[  0.011969 0 axruntime:144]   [PA:0x255000, PA:0x8000000) free memory (READ | WRITE | FREE)
[  0.012856 0 axruntime:144]   [PA:0xb0000000, PA:0xc0000000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.013800 0 axruntime:144]   [PA:0xfe000000, PA:0xfec00000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.014710 0 axruntime:144]   [PA:0xfec00000, PA:0xfec01000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.015636 0 axruntime:144]   [PA:0xfed00000, PA:0xfed01000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.016595 0 axruntime:144]   [PA:0xfee00000, PA:0xfee01000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.017524 0 axruntime:144]   [PA:0x380000000000, PA:0x380000004000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.018524 0 axruntime:159] Initialize platform devices...
[  0.019111 0 axhal::platform::x86_pc::apic:90] Initialize Local APIC...
[  0.019892 0 axhal::platform::x86_pc::apic:105] Using x2APIC.
[  0.020610 0 axhal::platform::x86_pc::apic:119] Initialize IO APIC...
[  0.021268 0 axruntime:204] Primary CPU 0 init OK.
Hello, world!
[  0.021989 0 axhal::platform::x86_pc::misc:7] Shutting down...
[  0.054676 0:5 axvisor::vmm::vcpus:351] VM[1] run VCpu[0] SystemDown
[  0.055161 0:5 axvm::vm:306] Shutting down VM[1]
[  0.055567 0:5 axvisor::vmm::vcpus:366] VM[1] VCpu[0] shutting down because of VM shutdown
[  0.056168 0:5 axvisor::vmm::vcpus:372] VM[1] VCpu[0] last VCpu exiting, decreasing running VM count
[  0.056865 0:5 axvisor::vmm::vcpus:385] VM[1] VCpu[0] exiting...
[  0.057328 0:2 axvisor::vmm:60] a VM exited, current running VM count: 0
[  0.057904 0:2 axhal::platform::x86_pc::misc:7] Shutting down...
</code></pre>
</li>
</ol>
<h2 id="nimbos-2"><a class="header" href="#nimbos-2">NimbOS</a></h2>
<h3 id="准备-nimbos-镜像-1"><a class="header" href="#准备-nimbos-镜像-1">准备 NimbOS 镜像</a></h3>
<p><a href="https://github.com/arceos-hypervisor/nimbos">NimbOS</a> 仓库的 <a href="https://github.com/arceos-hypervisor/nimbos/releases/">release</a> 页面已经编译生成了可以直接运行的 NimbOS 二进制镜像文件压缩包：</p>
<ul>
<li>不带 <code>_usertests</code> 后缀的 NimbOS 二进制镜像包中编译的 NimbOS 启动后会进入 NimbOS 的 shell，本示例启动的就是这个 NimbOS</li>
<li>带 <code>usertests</code> 后缀的 NimbOS 二进制镜像压缩包中编译的 NimbOS 启动后会自动运行用户态测例用于测试，这个镜像用于 AxVisor 的CI测试，见 <a href="https://github.com/arceos-hypervisor/axvisor/blob/master/.github/workflows/actions/setup-nimbos-guest-image/action.yml">setup-nimbos-guest-image/action.yml</a></li>
</ul>
<h3 id="从文件系统加载运行-5"><a class="header" href="#从文件系统加载运行-5">从文件系统加载运行</a></h3>
<p>获取 AxVisor 主线代码 <code>git clone git@github.com:arceos-hypervisor/axvisor.git</code>，然后在 <code>axvisor</code> 源码目录中执行如下步骤：</p>
<ol>
<li>
<p>制作一个磁盘镜像文件，并将客户机镜像放到文件系统中</p>
<ol>
<li>
<p>使用 <code>make disk_img</code> 命令生成一个空的 FAT32 磁盘镜像文件 <code>disk.img</code></p>
</li>
<li>
<p>手动挂载 <code>disk.img</code>，然后拉取并解压二进制镜像</p>
<pre><code class="language-bash">$ mkdir -p tmp
$ sudo mount disk.img tmp
$ wget https://github.com/arceos-hypervisor/nimbos/releases/download/v0.7/x86_64.zip
$ unzip x86_64.zip # 得到 nimbos.bin
$ sudo mv nimbos.bin tmp/nimbos-x86_64.bin
$ sudo wget https://github.com/arceos-hypervisor/axvm-bios-x86/releases/download/v0.1/axvm-bios.bin
$ sudo cp axvm-bios.bin tmp/  #axvm-bios.bin对应配置文件中的bios_path
$ sudo umount tmp
</code></pre>
</li>
</ol>
</li>
<li>
<p>直接使用 <a href="https://github.com/arceos-hypervisor/axvisor/blob/master/configs/vms/nimbos-x86_64.toml"><code>configs/vms/nimbos-x86_64.toml</code></a> 文件中的配置项</p>
<ul>
<li><code>image_location="fs"</code> 表示从文件系统加载</li>
<li><code>kernel_path</code> 指出内核镜像在文件系统中的路径</li>
<li><code>entry_point</code> 指出内核镜像的入口地址。必须与上面构建的 ArceOS 内核镜像的入口地址一致</li>
<li><code>kernel_load_addr</code> 指出内核镜像的加载地址。默认与 <code>entry_point</code> 一致</li>
<li><code>bios_path</code> 可通过 <a href="https://github.com/arceos-hypervisor/axvm-bios-x86/releases/download/v0.1/axvm-bios.bin">链接</a> 直接下载，或参考 x86_64 用户虚拟机的极简BIOS实现 <a href="https://github.com/arceos-hypervisor/axvm-bios-x86">axvm-bios</a></li>
<li><code>bios_load_addr</code> 指出 bios 镜像的加载地址，默认为  0x8000</li>
<li>其他</li>
</ul>
</li>
<li>
<p>执行 <code>make ACCEL=y ARCH=x86_64 LOG=info VM_CONFIGS=configs/vms/nimbos-x86_64.toml FEATURES=page-alloc-64g APP_FEATURES=fs defconfig</code> 创建 <code>.axconfig.toml</code> 配置文件</p>
</li>
<li>
<p>执行 <code>make ACCEL=y ARCH=x86_64 LOG=info VM_CONFIGS=configs/vms/nimbos-x86_64.toml FEATURES=page-alloc-64g APP_FEATURES=fs run</code> 构建 AxVisor，并在 QEMU 中启动。</p>
<pre><code class="language-plaintext">Booting from ROM..
       d8888                            .d88888b.   .d8888b.
      d88888                           d88P" "Y88b d88P  Y88b
     d88P888                           888     888 Y88b.
    d88P 888 888d888  .d8888b  .d88b.  888     888  "Y888b.
   d88P  888 888P"   d88P"    d8P  Y8b 888     888     "Y88b.
  d88P   888 888     888      88888888 888     888       "888
 d8888888888 888     Y88b.    Y8b.     Y88b. .d88P Y88b  d88P
d88P     888 888      "Y8888P  "Y8888   "Y88888P"   "Y8888P"

arch = x86_64
platform = x86_64-qemu-q35
target = x86_64-unknown-none
build_mode = release
log_level = info
smp = 1

[  0.003847 0 axruntime:139] Logging is enabled.
[  0.004218 0 axruntime:140] Primary CPU 0 started, dtb = 0x0.
[  0.004739 0 axruntime:142] Found physcial memory regions:
[  0.005196 0 axruntime:144]   [PA:0x200000, PA:0x29b000) .text (READ | EXECUTE | RESERVED)
[  0.005806 0 axruntime:144]   [PA:0x29b000, PA:0x2ae000) .rodata (READ | RESERVED)
[  0.006403 0 axruntime:144]   [PA:0x2ae000, PA:0x2bb000) .data .tdata .tbss .percpu (READ | WRITE | RESERVED)
[  0.007159 0 axruntime:144]   [PA:0x2bb000, PA:0x2fb000) boot stack (READ | WRITE | RESERVED)
[  0.007802 0 axruntime:144]   [PA:0x2fb000, PA:0x521000) .bss (READ | WRITE | RESERVED)
[  0.008412 0 axruntime:144]   [PA:0x1000, PA:0x9f000) low memory (READ | WRITE | RESERVED)
[  0.009046 0 axruntime:144]   [PA:0x521000, PA:0x8000000) free memory (READ | WRITE | FREE)
[  0.009731 0 axruntime:144]   [PA:0xb0000000, PA:0xc0000000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.010408 0 axruntime:144]   [PA:0xfe000000, PA:0xfec00000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.011119 0 axruntime:144]   [PA:0x7000000000, PA:0x7000004000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.011829 0 axruntime:144]   [PA:0xfec00000, PA:0xfec01000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.012520 0 axruntime:144]   [PA:0xfed00000, PA:0xfed01000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.013224 0 axruntime:144]   [PA:0xfee00000, PA:0xfee01000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.013889 0 axruntime:144]   [PA:0x380000000000, PA:0x380000004000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.014607 0 axruntime:226] Initialize global memory allocator...
[  0.015078 0 axruntime:227]   use TLSF allocator.
[  0.015481 0 axmm:72] Initialize virtual memory management...
[  0.016639 0 axruntime:159] Initialize platform devices...
[  0.017086 0 axhal::platform::x86_pc::apic:90] Initialize Local APIC...
[  0.017588 0 axhal::platform::x86_pc::apic:105] Using x2APIC.
[  0.018115 0 axhal::platform::x86_pc::apic:119] Initialize IO APIC...
[  0.018618 0 axtask::api:73] Initialize scheduling...
[  0.019147 0:2 axtask::api:79]   use FIFO scheduler.
[  0.019543 0:2 axdriver:172] Initialize device drivers...
[  0.020020 0:2 axdriver:173]   device model: static
[  0.034723 0:2 virtio_drivers::device::blk:59] config: 0xffff807000002000
[  0.035288 0:2 virtio_drivers::device::blk:64] found a block device of size 65536KB
[  0.035926 0:2 axdriver::bus::pci:104] registered a new Block device at 00:03.0: "virtio-blk"
[  0.187053 0:2 axfs:41] Initialize filesystems...
[  0.187436 0:2 axfs:44]   use block device 0: "virtio-blk"
[  0.190725 0:2 fatfs::dir:139] Is a directory
[  0.196242 0:2 fatfs::dir:139] Is a directory
[  0.202807 0:2 fatfs::dir:139] Is a directory
[  0.210491 0:2 fatfs::dir:139] Is a directory
[  0.213946 0:2 axruntime:192] Initialize interrupt handlers...
[  0.214421 0:2 axruntime:204] Primary CPU 0 init OK.


       d8888            888     888  d8b
      d88888            888     888  Y8P
     d88P888            888     888
    d88P 888  888  888  Y88b   d88P  888  .d8888b    .d88b.   888d888
   d88P  888  `Y8bd8P'   Y88b d88P   888  88K       d88""88b  888P"
  d88P   888    X88K      Y88o88P    888  "Y8888b.  888  888  888
 d8888888888  .d8""8b.     Y888P     888       X88  Y88..88P  888
d88P     888  888  888      Y8P      888   88888P'   "Y88P"   888


by AxVisor Team

[  0.217631 0:2 axvisor:21] Starting virtualization...
[  0.218054 0:2 axvisor:22] Hardware support: true
[  0.218459 0:4 axvisor::vmm::timer:101] Initing HV Timer...
[  0.218940 0:4 x86_vcpu::vmx::percpu:114] [AxVM] succeeded to turn on VMX.
[  0.219489 0:4 axvisor::hal:122] Hardware virtualization support enabled on core 0
[  0.220176 0:2 axvisor::vmm::config:33] Creating VM[1] "nimbos"
[  0.220647 0:2 x86_vcpu::vmx::vcpu:178] [HV] created VmxVcpu(vmcs: PA:0x7be000)
[  0.221246 0:2 axvm::vm:114] Setting up memory region: [0x0~0x1000000] READ | WRITE | EXECUTE
[  0.222681 0:2 axvm::vm:166] Setting up passthrough device memory region: [0xfec00000~0xfec01000] -&gt; [0xfec00000~0xfec01000]
[  0.223622 0:2 axvm::vm:166] Setting up passthrough device memory region: [0xfee00000~0xfee01000] -&gt; [0xfee00000~0xfee01000]
[  0.224476 0:2 axvm::vm:166] Setting up passthrough device memory region: [0xfed00000~0xfed01000] -&gt; [0xfed00000~0xfed01000]
[  0.225324 0:2 axvm::vm:202] VM[1] created
[  0.225751 0:2 axvm::vm:217] VM[1] vcpus set up
[  0.226150 0:2 axvisor::vmm::config:40] VM[1] created success, loading images...
[  0.226731 0:2 axvisor::vmm::images::fs:153] Loading VM images from filesystem
[  0.287981 0:2 axvisor::vmm:35] Setting up vcpus...
[  0.288387 0:2 axvisor::vmm::vcpus:219] Initializing VM[1]'s 1 vcpus
[  0.288883 0:2 axvisor::vmm::vcpus:250] Spawning task for VM[1] VCpu[0]
[  0.289398 0:2 axvisor::vmm::vcpus:262] VCpu task Task(5, "VM[1]-VCpu[0]") created cpumask: [0, ]
[  0.290058 0:2 axvisor::vmm:43] VMM starting, booting VMs...
[  0.290514 0:2 axvm::vm:284] Booting VM[1]
[  0.290863 0:2 axvisor::vmm:49] VM[1] boot success
[  0.291258 0:2 axvisor::vmm:60] a VM exited, current running VM count: 1
[  0.291779 0:5 axvisor::vmm::vcpus:283] VM[1] VCpu[0] waiting for running
[  0.292309 0:5 axvisor::vmm::vcpus:286] VM[1] VCpu[0] running...

NN   NN  iii               bb        OOOOO    SSSSS
NNN  NN       mm mm mmmm   bb       OO   OO  SS
NN N NN  iii  mmm  mm  mm  bbbbbb   OO   OO   SSSSS
NN  NNN  iii  mmm  mm  mm  bb   bb  OO   OO       SS
NN   NN  iii  mmm  mm  mm  bbbbbb    OOOO0    SSSSS
              ___    ____    ___    ___
             |__ \  / __ \  |__ \  |__ \
             __/ / / / / /  __/ /  __/ /
            / __/ / /_/ /  / __/  / __/
           /____/ \____/  /____/ /____/

arch = x86_64
platform = pc
build_mode = release
log_level = warn

Initializing kernel heap at: [0xffffff8000290d00, 0xffffff8000690d00)
Initializing IDT...
Loading GDT for CPU 0...
Initializing frame allocator at: [PA:0x691000, PA:0x8000000)
Mapping .text: [0xffffff8000200000, 0xffffff800021a000)
Mapping .rodata: [0xffffff800021a000, 0xffffff8000220000)
Mapping .data: [0xffffff8000220000, 0xffffff800028c000)
Mapping .bss: [0xffffff8000290000, 0xffffff8000691000)
Mapping boot stack: [0xffffff800028c000, 0xffffff8000290000)
Mapping physical memory: [0xffffff8000691000, 0xffffff8008000000)
Mapping MMIO: [0xffffff80fec00000, 0xffffff80fec01000)
Mapping MMIO: [0xffffff80fed00000, 0xffffff80fed01000)
Mapping MMIO: [0xffffff80fee00000, 0xffffff80fee01000)
Initializing drivers...
Initializing Local APIC...
Initializing HPET...
HPET: 100.000000 MHz, 64-bit, 3 timers
[  0.303522 0:5 x86_vcpu::vmx::vcpu:1018] handle_cpuid: Failed to get TSC frequency by CPUID, default to 3000 MHz
Got TSC frequency by CPUID: 3000 MHz
Calibrated LAPIC frequency: 1000.301 MHz
Initializing task manager...
/**** APPS ****
cyclictest
exit
fantastic_text
forktest
forktest2
forktest_simple
forktest_simple_c
forktree
hello_c
hello_world
matrix
poweroff
sleep
sleep_simple
stack_overflow
thread_simple
user_shell
usertests
yield
**************/
Running tasks...
test kernel task: pid = TaskId(2), arg = 0xdead
test kernel task: pid = TaskId(3), arg = 0xbeef
Rust user shell
&gt;&gt; 
</code></pre>
</li>
</ol>
<h3 id="从内存加载运行-4"><a class="header" href="#从内存加载运行-4">从内存加载运行</a></h3>
<p>获取 AxVisor 主线代码 <code>git clone git@github.com:arceos-hypervisor/axvisor.git</code>，然后在 <code>axvisor</code> 源码目录中执行如下步骤：</p>
<ol>
<li>
<p>修改对应的 <code>./configs/vms/nimbos-x86_64.toml</code> 中的配置项，注意设置 <code>kernel_path</code>  和 <code>bios_path</code> 为 nimbos 二进制内核镜像在工作空间中的相对/绝对路径</p>
<pre><code class="language-toml">[kernel]
# The entry point of the kernel image.
entry_point = 0x8000
# The location of image: "memory" | "fs".
# Load from file system.
image_location = "memory"
# The file path of the kernel image.
kernel_path = "nimbos.bin"
# The load address of the kernel image.
kernel_load_addr = 0x20_0000
# The file path of the BIOS image.
bios_path = "axvm-bios.bin"
# The load address of the BIOS image.
bios_load_addr = 0x8000
</code></pre>
<ul>
<li><code>image_location="memory"</code> 配置项</li>
<li><code>kernel_path</code> 指定内核镜像在工作空间中的相对/绝对路径</li>
<li><code>entry_point</code> 指出内核镜像的入口地址。必须与上面构建的 ArceOS 内核镜像的入口地址一致</li>
<li><code>kernel_load_addr</code> 指出内核镜像的加载地址。默认与 <code>entry_point</code> 一致</li>
<li><code>bios_path</code> 可通过 <a href="https://github.com/arceos-hypervisor/axvm-bios-x86/releases/download/v0.1/axvm-bios.bin">链接</a> 直接下载，或参考 x86_64 用户虚拟机的极简BIOS实现 <a href="https://github.com/arceos-hypervisor/axvm-bios-x86">axvm-bios</a></li>
<li><code>bios_load_addr</code> 指出 bios 镜像的加载地址，默认为  0x8000</li>
<li>其他</li>
</ul>
</li>
<li>
<p>执行 <code>make ACCEL=y ARCH=x86_64 LOG=info VM_CONFIGS=configs/vms/nimbos-x86_64.toml FEATURES=page-alloc-64g run</code> 构建 AxVisor，并在 QEMU 中启动。</p>
<pre><code class="language-plaintext">Booting from ROM..
       d8888                            .d88888b.   .d8888b.
      d88888                           d88P" "Y88b d88P  Y88b
     d88P888                           888     888 Y88b.
    d88P 888 888d888  .d8888b  .d88b.  888     888  "Y888b.
   d88P  888 888P"   d88P"    d8P  Y8b 888     888     "Y88b.
  d88P   888 888     888      88888888 888     888       "888
 d8888888888 888     Y88b.    Y8b.     Y88b. .d88P Y88b  d88P
d88P     888 888      "Y8888P  "Y8888   "Y88888P"   "Y8888P"

arch = x86_64
platform = x86_64-qemu-q35
target = x86_64-unknown-none
build_mode = release
log_level = info
smp = 1

[  0.003516 0 axruntime:139] Logging is enabled.
[  0.003900 0 axruntime:140] Primary CPU 0 started, dtb = 0x0.
[  0.004358 0 axruntime:142] Found physcial memory regions:
[  0.004801 0 axruntime:144]   [PA:0x200000, PA:0x274000) .text (READ | EXECUTE | RESERVED)
[  0.005451 0 axruntime:144]   [PA:0x274000, PA:0x30d000) .rodata (READ | RESERVED)
[  0.006025 0 axruntime:144]   [PA:0x30d000, PA:0x318000) .data .tdata .tbss .percpu (READ | WRITE | RESERVED)
[  0.006751 0 axruntime:144]   [PA:0x318000, PA:0x358000) boot stack (READ | WRITE | RESERVED)
[  0.007382 0 axruntime:144]   [PA:0x358000, PA:0x57e000) .bss (READ | WRITE | RESERVED)
[  0.007981 0 axruntime:144]   [PA:0x1000, PA:0x9f000) low memory (READ | WRITE | RESERVED)
[  0.008598 0 axruntime:144]   [PA:0x57e000, PA:0x8000000) free memory (READ | WRITE | FREE)
[  0.009224 0 axruntime:144]   [PA:0xb0000000, PA:0xc0000000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.009897 0 axruntime:144]   [PA:0xfe000000, PA:0xfec00000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.010572 0 axruntime:144]   [PA:0x7000000000, PA:0x7000004000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.011284 0 axruntime:144]   [PA:0xfec00000, PA:0xfec01000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.011956 0 axruntime:144]   [PA:0xfed00000, PA:0xfed01000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.012623 0 axruntime:144]   [PA:0xfee00000, PA:0xfee01000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.013266 0 axruntime:144]   [PA:0x380000000000, PA:0x380000004000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.013953 0 axruntime:226] Initialize global memory allocator...
[  0.014409 0 axruntime:227]   use TLSF allocator.
[  0.014794 0 axmm:72] Initialize virtual memory management...
[  0.015976 0 axruntime:159] Initialize platform devices...
[  0.016407 0 axhal::platform::x86_pc::apic:90] Initialize Local APIC...
[  0.016899 0 axhal::platform::x86_pc::apic:105] Using x2APIC.
[  0.017370 0 axhal::platform::x86_pc::apic:119] Initialize IO APIC...
[  0.017875 0 axtask::api:73] Initialize scheduling...
[  0.018287 0:2 axtask::api:79]   use FIFO scheduler.
[  0.018689 0:2 axruntime:192] Initialize interrupt handlers...
[  0.019150 0:2 axruntime:204] Primary CPU 0 init OK.


       d8888            888     888  d8b
      d88888            888     888  Y8P
     d88P888            888     888
    d88P 888  888  888  Y88b   d88P  888  .d8888b    .d88b.   888d888
   d88P  888  `Y8bd8P'   Y88b d88P   888  88K       d88""88b  888P"
  d88P   888    X88K      Y88o88P    888  "Y8888b.  888  888  888
 d8888888888  .d8""8b.     Y888P     888       X88  Y88..88P  888
d88P     888  888  888      Y8P      888   88888P'   "Y88P"   888


by AxVisor Team

[  0.022259 0:2 axvisor:21] Starting virtualization...
[  0.022666 0:2 axvisor:22] Hardware support: true
[  0.023153 0:4 axvisor::vmm::timer:101] Initing HV Timer...
[  0.023610 0:4 x86_vcpu::vmx::percpu:114] [AxVM] succeeded to turn on VMX.
[  0.024146 0:4 axvisor::hal:122] Hardware virtualization support enabled on core 0
[  0.024840 0:2 axvisor::vmm::config:33] Creating VM[1] "nimbos"
[  0.025320 0:2 x86_vcpu::vmx::vcpu:178] [HV] created VmxVcpu(vmcs: PA:0x819000)
[  0.025877 0:2 axvm::vm:114] Setting up memory region: [0x0~0x1000000] READ | WRITE | EXECUTE
[  0.027255 0:2 axvm::vm:166] Setting up passthrough device memory region: [0xfec00000~0xfec01000] -&gt; [0xfec00000~0xfec01000]
[  0.028186 0:2 axvm::vm:166] Setting up passthrough device memory region: [0xfee00000~0xfee01000] -&gt; [0xfee00000~0xfee01000]
[  0.028998 0:2 axvm::vm:166] Setting up passthrough device memory region: [0xfed00000~0xfed01000] -&gt; [0xfed00000~0xfed01000]
[  0.029809 0:2 axvm::vm:202] VM[1] created
[  0.030227 0:2 axvm::vm:217] VM[1] vcpus set up
[  0.030602 0:2 axvisor::vmm::config:40] VM[1] created success, loading images...
[  0.031164 0:2 axvisor::vmm::images:49] Loading VM[1] images from memory
[  0.031910 0:2 axvisor::vmm:35] Setting up vcpus...
[  0.032325 0:2 axvisor::vmm::vcpus:219] Initializing VM[1]'s 1 vcpus
[  0.032814 0:2 axvisor::vmm::vcpus:250] Spawning task for VM[1] VCpu[0]
[  0.033326 0:2 axvisor::vmm::vcpus:262] VCpu task Task(5, "VM[1]-VCpu[0]") created cpumask: [0, ]
[  0.033983 0:2 axvisor::vmm:43] VMM starting, booting VMs...
[  0.034429 0:2 axvm::vm:284] Booting VM[1]
[  0.034775 0:2 axvisor::vmm:49] VM[1] boot success
[  0.035167 0:2 axvisor::vmm:60] a VM exited, current running VM count: 1
[  0.035681 0:5 axvisor::vmm::vcpus:283] VM[1] VCpu[0] waiting for running
[  0.036199 0:5 axvisor::vmm::vcpus:286] VM[1] VCpu[0] running...

NN   NN  iii               bb        OOOOO    SSSSS
NNN  NN       mm mm mmmm   bb       OO   OO  SS
NN N NN  iii  mmm  mm  mm  bbbbbb   OO   OO   SSSSS
NN  NNN  iii  mmm  mm  mm  bb   bb  OO   OO       SS
NN   NN  iii  mmm  mm  mm  bbbbbb    OOOO0    SSSSS
              ___    ____    ___    ___
             |__ \  / __ \  |__ \  |__ \
             __/ / / / / /  __/ /  __/ /
            / __/ / /_/ /  / __/  / __/
           /____/ \____/  /____/ /____/

arch = x86_64
platform = pc
build_mode = release
log_level = warn

Initializing kernel heap at: [0xffffff8000290d00, 0xffffff8000690d00)
Initializing IDT...
Loading GDT for CPU 0...
Initializing frame allocator at: [PA:0x691000, PA:0x8000000)
Mapping .text: [0xffffff8000200000, 0xffffff800021a000)
Mapping .rodata: [0xffffff800021a000, 0xffffff8000220000)
Mapping .data: [0xffffff8000220000, 0xffffff800028c000)
Mapping .bss: [0xffffff8000290000, 0xffffff8000691000)
Mapping boot stack: [0xffffff800028c000, 0xffffff8000290000)
Mapping physical memory: [0xffffff8000691000, 0xffffff8008000000)
Mapping MMIO: [0xffffff80fec00000, 0xffffff80fec01000)
Mapping MMIO: [0xffffff80fed00000, 0xffffff80fed01000)
Mapping MMIO: [0xffffff80fee00000, 0xffffff80fee01000)
Initializing drivers...
Initializing Local APIC...
Initializing HPET...
HPET: 100.000000 MHz, 64-bit, 3 timers
[  0.047412 0:5 x86_vcpu::vmx::vcpu:1018] handle_cpuid: Failed to get TSC frequency by CPUID, default to 3000 MHz
Got TSC frequency by CPUID: 3000 MHz
Calibrated LAPIC frequency: 1000.259 MHz
Initializing task manager...
/**** APPS ****
cyclictest
exit
fantastic_text
forktest
forktest2
forktest_simple
forktest_simple_c
forktree
hello_c
hello_world
matrix
poweroff
sleep
sleep_simple
stack_overflow
thread_simple
user_shell
usertests
yield
**************/
Running tasks...
test kernel task: pid = TaskId(2), arg = 0xdead
test kernel task: pid = TaskId(3), arg = 0xbeef
Rust user shell
&gt;&gt; 
</code></pre>
</li>
</ol>
<h2 id="注意事项-1"><a class="header" href="#注意事项-1">注意事项</a></h2>
<ol>
<li>
<p>目前 qemu-system-x86_64 平台提供的 virt CPU 实现不支持 VMX feature，需要在启动时开启 <code>-enable-kvm</code> 参数（Makefile 定义的环境变量为 <code>ACCEL=y</code>）</p>
</li>
<li>
<p><a href="https://github.com/arceos-hypervisor/axvm-bios-x86">axvm-bios</a> 是针对 x86_64 用户虚拟机的一个极简BIOS实现。</p>
<p>它可以承担引导 NimbOS 以及 ArceOS 启动的任务，二进制文件<a href="https://github.com/arceos-hypervisor/axvm-bios-x86/releases/download/v0.1/axvm-bios.bin">链接</a>.<style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () =&gt; window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () =&gt; { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY &lt;200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() =&gt; { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () =&gt; { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() =&gt; { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) =&gt; (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) =&gt; { btn.addEventListener("click", (event) =&gt; { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="run-axvisor-on-qemu-riscv64"><a class="header" href="#run-axvisor-on-qemu-riscv64">Run AxVisor on QEMU riscv64</a></h1>
<p>目前，在 QEMU riscv64 平台上已经对独立运行 ArceOS 和 nimbos 进行了验证。</p>
<h2 id="arceos-3"><a class="header" href="#arceos-3">ArceOS</a></h2>
<h3 id="准备-arceos-镜像-2"><a class="header" href="#准备-arceos-镜像-2">准备 ArceOS 镜像</a></h3>
<ol>
<li>
<p>获取 ArceOS 主线代码 <code>git clone https://github.com/arceos-org/arceos.git</code></p>
</li>
<li>
<p>在 <code>arceos</code> 源码目录中执行 <code>make ARCH=riscv64 SMP=1 A=examples/helloworld</code> 获得 <code>examples/helloworld/helloworld_riscv64-qemu-virt.bin</code></p>
</li>
</ol>
<h3 id="从文件系统加载运行-6"><a class="header" href="#从文件系统加载运行-6">从文件系统加载运行</a></h3>
<p>获取 AxVisor 主线代码 <code>git clone git@github.com:arceos-hypervisor/axvisor.git</code>，然后在 <code>axvisor</code> 源码目录中执行如下步骤：</p>
<ol>
<li>
<p>制作一个磁盘镜像文件，并将 ArceOS 客户机镜像放到磁盘镜像文件系统中</p>
<ol>
<li>
<p>使用 <code>make disk_img</code> 命令生成一个空的 FAT32 磁盘镜像文件 <code>disk.img</code></p>
</li>
<li>
<p>手动挂载 <code>disk.img</code>，然后将ArceOS 客户机镜像复制到该文件系统中即可</p>
<pre><code class="language-bash">$ mkdir -p tmp
$ sudo mount disk.img tmp
$ sudo cp /path/to/helloworld_riscv64-qemu-virt.bin tmp/
$ sudo umount tmp
</code></pre>
</li>
</ol>
</li>
<li>
<p>修改对应的 <code>./configs/vms/arceos-riscv64.toml</code> 文件中的配置项</p>
<pre><code class="language-toml">[kernel]
# The entry point of the kernel image.
entry_point = 0x8020_0000
# The location of image: "memory" | "fs".
# Load from file system.
image_location = "fs"
# The file path of the kernel image.
kernel_path = "/path/to/helloworld_riscv64-qemu-virt.bin"
# The load address of the kernel image.
kernel_load_addr = 0x8020_0000
</code></pre>
<ul>
<li><code>image_location="fs"</code> 表示从文件系统加载</li>
<li><code>kernel_path</code> 指出内核镜像在文件系统中的路径</li>
<li><code>entry_point</code> 指出内核镜像的入口地址。必须与上面构建的 ArceOS 内核镜像的入口地址一致</li>
<li><code>kernel_load_addr</code> 指出内核镜像的加载地址。默认与 <code>entry_point</code> 一致</li>
<li>其他</li>
</ul>
</li>
<li>
<p>执行 <code>make ACCEL=n ARCH=riscv64 LOG=info VM_CONFIGS=configs/vms/arceos-riscv64.toml FEATURES=page-alloc-64g APP_FEATURES=fs run</code> 构建 AxVisor，并在 QEMU 中启动。</p>
<pre><code class="language-plaintext">       d8888                            .d88888b.   .d8888b.
      d88888                           d88P" "Y88b d88P  Y88b
     d88P888                           888     888 Y88b.
    d88P 888 888d888  .d8888b  .d88b.  888     888  "Y888b.
   d88P  888 888P"   d88P"    d8P  Y8b 888     888     "Y88b.
  d88P   888 888     888      88888888 888     888       "888
 d8888888888 888     Y88b.    Y8b.     Y88b. .d88P Y88b  d88P
d88P     888 888      "Y8888P  "Y8888   "Y88888P"   "Y8888P"

arch = riscv64
platform = riscv64-qemu-virt
target = riscv64gc-unknown-none-elf
build_mode = release
log_level = info
smp = 1

[  0.029278 0 axruntime:139] Logging is enabled.
[  0.029991 0 axruntime:140] Primary CPU 0 started, dtb = 0x0.
[  0.030323 0 axruntime:142] Found physcial memory regions:
[  0.030872 0 axruntime:144]   [PA:0x80200000, PA:0x8026d000) .text (READ | EXECUTE | RESERVED)
[  0.031504 0 axruntime:144]   [PA:0x8026d000, PA:0x80286000) .rodata (READ | RESERVED)
[  0.031777 0 axruntime:144]   [PA:0x80286000, PA:0x80289000) .data .tdata .tbss .percpu (READ | WRITE | RESERVED)
[  0.032126 0 axruntime:144]   [PA:0x80289000, PA:0x802c9000) boot stack (READ | WRITE | RESERVED)
[  0.032423 0 axruntime:144]   [PA:0x802c9000, PA:0x804ed000) .bss (READ | WRITE | RESERVED)
[  0.032736 0 axruntime:144]   [PA:0x804ed000, PA:0x88000000) free memory (READ | WRITE | FREE)
[  0.033083 0 axruntime:144]   [PA:0x101000, PA:0x102000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.033393 0 axruntime:144]   [PA:0xc000000, PA:0xc210000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.033701 0 axruntime:144]   [PA:0x10000000, PA:0x10001000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.034025 0 axruntime:144]   [PA:0x10001000, PA:0x10009000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.034327 0 axruntime:144]   [PA:0x30000000, PA:0x40000000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.034629 0 axruntime:144]   [PA:0x40000000, PA:0x80000000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.034985 0 axruntime:226] Initialize global memory allocator...
[  0.035246 0 axruntime:227]   use TLSF allocator.
[  0.036774 0 axmm:72] Initialize virtual memory management...
[  0.060657 0 axruntime:159] Initialize platform devices...
[  0.060998 0 axtask::api:73] Initialize scheduling...
[  0.062593 0:2 axtask::api:79]   use FIFO scheduler.
[  0.063236 0:2 axdriver:172] Initialize device drivers...
[  0.063728 0:2 axdriver:173]   device model: static
[  0.067880 0:2 virtio_drivers::device::blk:59] config: 0xffffffc040006000
[  0.068333 0:2 virtio_drivers::device::blk:64] found a block device of size 65536KB
[  0.069105 0:2 axdriver::bus::pci:104] registered a new Block device at 00:01.0: "virtio-blk"
[  0.099971 0:2 axfs:41] Initialize filesystems...
[  0.100246 0:2 axfs:44]   use block device 0: "virtio-blk"
[  0.110023 0:2 fatfs::dir:139] Is a directory
[  0.117188 0:2 fatfs::dir:139] Is a directory
[  0.126339 0:2 fatfs::dir:139] Is a directory
[  0.135793 0:2 fatfs::dir:139] Is a directory
[  0.139893 0:2 axruntime:192] Initialize interrupt handlers...
[  0.140471 0:2 axruntime:204] Primary CPU 0 init OK.


    _         __     ___
   / \   __  _\ \   / (_)___  ___  _ __
  / _ \  \ \/ /\ \ / /| / __|/ _ \| '__|
 / ___ \  &gt;  &lt;  \ V / | \__ \ (_) | |
/_/   \_\/_/\_\  \_/  |_|___/\___/|_|


by AxVisor Team

[  0.141400 0:2 axvisor:21] Starting virtualization...
[  0.141663 0:2 axvisor:22] Hardware support: true
[  0.142729 0:4 axvisor::vmm::timer:101] Initing HV Timer...
[  0.143075 0:4 axvisor::hal:122] Hardware virtualization support enabled on core 0
[  0.156735 0:2 axvisor::vmm::config:33] Creating VM[1] "arceos"
[  0.157384 0:2 axvm::vm:114] Setting up memory region: [0x80000000~0x81000000] READ | WRITE | EXECUTE | USER
[  0.160395 0:2 axvm::vm:166] Setting up passthrough device memory region: [0xc000000~0xc210000] -&gt; [0xc000000~0xc210000]
[  0.161207 0:2 axvm::vm:166] Setting up passthrough device memory region: [0x10000000~0x10001000] -&gt; [0x10000000~0x10001000]
[  0.161736 0:2 axvm::vm:202] VM[1] created
[  0.162041 0:2 axvm::vm:217] VM[1] vcpus set up
[  0.162314 0:2 axvisor::vmm::config:40] VM[1] created success, loading images...
[  0.162628 0:2 axvisor::vmm::images::fs:153] Loading VM images from filesystem
[  0.168998 0:2 axvisor::vmm:35] Setting up vcpus...
[  0.169565 0:2 axvisor::vmm::vcpus:219] Initializing VM[1]'s 1 vcpus
[  0.169924 0:2 axvisor::vmm::vcpus:250] Spawning task for VM[1] VCpu[0]
[  0.170459 0:2 axvisor::vmm::vcpus:262] VCpu task Task(5, "VM[1]-VCpu[0]") created cpumask: [0, ]
[  0.170977 0:2 axvisor::vmm:43] VMM starting, booting VMs...
[  0.171295 0:2 axvm::vm:284] Booting VM[1]
[  0.171556 0:2 axvisor::vmm:49] VM[1] boot success
[  0.171856 0:2 axvisor::vmm:60] a VM exited, current running VM count: 1
[  0.172443 0:5 axvisor::vmm::vcpus:283] VM[1] VCpu[0] waiting for running
[  0.172806 0:5 axvisor::vmm::vcpus:286] VM[1] VCpu[0] running...
#��6���6Be#��6��65

                  e�q�/%5Eu��o@#0��0�\�4
���                                     ��7�I�c��7��D7ք4
�3
B�o�~4�B�#(4#*d#&lt;�#0T#4D#8#
                           ��E#�#8$#,#0$�h��}V���c��0�h�l���ŀ��ei���0�  P5
                                                                          �E/5��@N5
B�J4�B�E                                                                           *��ET���!E*���K!�N�E�����瀠�E
        �
$&amp;�$�#&lt;6�"  �� �##��/��}��#&lt;�Ec� ��)�2������/��}�����    �毵��/��}���
                                       �
                                        %�)�2�
                                              �
$&amp;�$�#&lt; �"  ��  ##��    �        ��)�2�        %��E������&amp;f�����p��Z�f
                                       �
                                        %�)�2�
                                              �
                                               %� 
$&amp;�$�#&lt;��"  ��f ##��    �        ��)�2�
                                       �
                                        %�)�2�
                                              �
                                               %�@݃U���� ��op
$&amp;�$�#&lt;��"  ���Z##��    �        ��)�2�
                                       �
                                        %�)�2�
                                              �
$&amp;�$�#&lt; �"  ��  ##��    �        ��)�2�        %��Fc����.����������p��Z�f
                                       �
                                        %�)�2�
                                              �
$&amp;�$�#&lt; �"  ��  ##��    �        ��)�2�        %�������������p��Z�f
                                       �
                                        %�)�2�
                                              �
$&amp;�$�#&lt; �"  ��  ##��    �        ��)�2��       %��Ś�Eca�����������E��
                                        %�)�2��
$&amp;�$�#&lt; �"  ��  ##��    �        ��)�2�        %������������������p��Z�f
                                       �
                                        %�)�2�
                                              �
$&amp;�$�#&lt; �"  ��  ##��    �        ��)�2�        %������������������p��Z�f
                                       �
                                        %�)�2�
                                              �
$&amp;�$�#&lt; �"  ��  ##��    �        ��)�2�        %������������������p��Z�f
                                       �
                                        %�)�2�
                                              �
$&amp;�$�#&lt; �"  ��  ##��    �        ��)�2�        %������������������p��Z�f
                                       �
                                        %�)�2�
                                              �
$&amp;�$�#&lt; �"  ��  ##��    �        ��)�2�        %������������������p��Z�f
                                       �
                                        %�)�2�
                                              �
$&amp;�$��{(�p�#&lt;�ݽ"ccݰ��   �        ����qU/ N�E���Fc�0���������������p��Z�f
$&amp;�$�.E�UaA��%%# �c�o0:����� �#�EA-�E1-F
</code></pre>
</li>
</ol>
<h3 id="从内存加载运行-5"><a class="header" href="#从内存加载运行-5">从内存加载运行</a></h3>
<p>获取 AxVisor 主线代码 <code>git clone git@github.com:arceos-hypervisor/axvisor.git</code>，然后在 <code>axvisor</code> 源码目录中执行如下步骤：</p>
<ol>
<li>
<p>修改对应的 <code>./configs/vms/arceos-riscv64.toml</code> 中的配置项</p>
<pre><code class="language-toml">[kernel]
# The entry point of the kernel image.
entry_point = 0x8020_0000
# The location of image: "memory" | "fs".
# Load from file system.
image_location = "memory"
# The file path of the kernel image.
kernel_path = "/path/to/helloworld_riscv64-qemu-virt.bin"
# The load address of the kernel image.
kernel_load_addr = 0x8020_0000
</code></pre>
<ul>
<li><code>image_location="memory"</code> 配置项</li>
<li><code>kernel_path</code> 指定内核镜像在工作空间中的相对/绝对路径</li>
<li><code>entry_point</code> 指出内核镜像的入口地址。必须与上面构建的 ArceOS 内核镜像的入口地址一致</li>
<li><code>kernel_load_addr</code> 指出内核镜像的加载地址。默认与 <code>entry_point</code> 一致</li>
<li>其他</li>
</ul>
</li>
<li>
<p>执行 <code>make ACCEL=n ARCH=riscv64 LOG=info VM_CONFIGS=configs/vms/arceos-riscv64.toml FEATURES=page-alloc-64g run</code> 构建 AxVisor，并在 QEMU 中启动。</p>
<pre><code class="language-plaintext">       d8888                            .d88888b.   .d8888b.
      d88888                           d88P" "Y88b d88P  Y88b
     d88P888                           888     888 Y88b.
    d88P 888 888d888  .d8888b  .d88b.  888     888  "Y888b.
   d88P  888 888P"   d88P"    d8P  Y8b 888     888     "Y88b.
  d88P   888 888     888      88888888 888     888       "888
 d8888888888 888     Y88b.    Y8b.     Y88b. .d88P Y88b  d88P
d88P     888 888      "Y8888P  "Y8888   "Y88888P"   "Y8888P"

arch = riscv64
platform = riscv64-qemu-virt
target = riscv64gc-unknown-none-elf
build_mode = release
log_level = info
smp = 1

[  0.033033 0 axruntime:139] Logging is enabled.
[  0.033974 0 axruntime:140] Primary CPU 0 started, dtb = 0x0.
[  0.034529 0 axruntime:142] Found physcial memory regions:
[  0.035069 0 axruntime:144]   [PA:0x80200000, PA:0x80251000) .text (READ | EXECUTE | RESERVED)
[  0.035833 0 axruntime:144]   [PA:0x80251000, PA:0x8026b000) .rodata (READ | RESERVED)
[  0.036372 0 axruntime:144]   [PA:0x8026b000, PA:0x8026e000) .data .tdata .tbss .percpu (READ | WRITE | RESERVED)
[  0.036997 0 axruntime:144]   [PA:0x8026e000, PA:0x802ae000) boot stack (READ | WRITE | RESERVED)
[  0.037600 0 axruntime:144]   [PA:0x802ae000, PA:0x804d2000) .bss (READ | WRITE | RESERVED)
[  0.038160 0 axruntime:144]   [PA:0x804d2000, PA:0x88000000) free memory (READ | WRITE | FREE)
[  0.038748 0 axruntime:144]   [PA:0x101000, PA:0x102000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.039305 0 axruntime:144]   [PA:0xc000000, PA:0xc210000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.039852 0 axruntime:144]   [PA:0x10000000, PA:0x10001000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.040411 0 axruntime:144]   [PA:0x10001000, PA:0x10009000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.040965 0 axruntime:144]   [PA:0x30000000, PA:0x40000000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.041552 0 axruntime:144]   [PA:0x40000000, PA:0x80000000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.042200 0 axruntime:226] Initialize global memory allocator...
[  0.042633 0 axruntime:227]   use TLSF allocator.
[  0.044301 0 axmm:72] Initialize virtual memory management...
[  0.068855 0 axruntime:159] Initialize platform devices...
[  0.069350 0 axtask::api:73] Initialize scheduling...
[  0.070532 0:2 axtask::api:79]   use FIFO scheduler.
[  0.071083 0:2 axruntime:192] Initialize interrupt handlers...
[  0.071811 0:2 axruntime:204] Primary CPU 0 init OK.


       d8888            888     888  d8b
      d88888            888     888  Y8P
     d88P888            888     888
    d88P 888  888  888  Y88b   d88P  888  .d8888b    .d88b.   888d888
   d88P  888  `Y8bd8P'   Y88b d88P   888  88K       d88""88b  888P"
  d88P   888    X88K      Y88o88P    888  "Y8888b.  888  888  888
 d8888888888  .d8""8b.     Y888P     888       X88  Y88..88P  888
d88P     888  888  888      Y8P      888   88888P'   "Y88P"   888


by AxVisor Team

[  0.074159 0:2 axvisor:21] Starting virtualization...
[  0.074645 0:2 axvisor:22] Hardware support: true
[  0.075869 0:4 axvisor::vmm::timer:101] Initing HV Timer...
[  0.076362 0:4 axvisor::hal:122] Hardware virtualization support enabled on core 0
[  0.090502 0:2 axvisor::vmm::config:33] Creating VM[1] "arceos"
[  0.091340 0:2 axvm::vm:114] Setting up memory region: [0x80000000~0x81000000] READ | WRITE | EXECUTE | USER
[  0.094702 0:2 axvm::vm:166] Setting up passthrough device memory region: [0xc000000~0xc210000] -&gt; [0xc000000~0xc210000]
[  0.095782 0:2 axvm::vm:166] Setting up passthrough device memory region: [0x10000000~0x10001000] -&gt; [0x10000000~0x10001000]
[  0.096655 0:2 axvm::vm:202] VM[1] created
[  0.097141 0:2 axvm::vm:217] VM[1] vcpus set up
[  0.097558 0:2 axvisor::vmm::config:40] VM[1] created success, loading images...
[  0.098164 0:2 axvisor::vmm::images:49] Loading VM[1] images from memory
[  0.099431 0:2 axvisor::vmm:35] Setting up vcpus...
[  0.100145 0:2 axvisor::vmm::vcpus:219] Initializing VM[1]'s 1 vcpus
[  0.100708 0:2 axvisor::vmm::vcpus:250] Spawning task for VM[1] VCpu[0]
[  0.101450 0:2 axvisor::vmm::vcpus:262] VCpu task Task(5, "VM[1]-VCpu[0]") created cpumask: [0, ]
[  0.102281 0:2 axvisor::vmm:43] VMM starting, booting VMs...
[  0.102764 0:2 axvm::vm:284] Booting VM[1]
[  0.103172 0:2 axvisor::vmm:49] VM[1] boot success
[  0.103630 0:2 axvisor::vmm:60] a VM exited, current running VM count: 1
[  0.104392 0:5 axvisor::vmm::vcpus:283] VM[1] VCpu[0] waiting for running
[  0.104955 0:5 axvisor::vmm::vcpus:286] VM[1] VCpu[0] running...
���2�#0�*#4�*���2�#8�*�J#&lt;Q+�
f
 2�#0�,�,�
          2��*�#4�,#8�,#&lt;A-����#0�.-E#4�.6�#8�.:�#&lt;�.#0�0����#4q0�*�#8�0; �
                                                                           �M   �IL��%�)#4�K�v#8�J#&lt;1K�f�#4�LF#8�L0#&lt;�L#0QO�#4�N#8QO#&lt;F6v#&lt;�Hp#0�J�I#0�L�q#0�H#41I#8H��G��s�uŕEc����
�Lu}�ct�Jc�څúL��-G�.��v:v&amp;�                                                                                                                                                       ���c�
t3��Aae���G�0.�������Zu5�&lt;�k��6�#&lt;�D�
�#0�C#8�%                            #&lt;�2%�Q#0�4��E#4�4#8�4�#&lt;�4ve#0�6�#4�6���%�#8�6#&lt;�7#4�9#&lt;8E#Fc
         ��e0c  ��%���
Fba�yo&amp;�E�������f#&lt;�&amp;�0ba�yo�,�#&lt;�,%E#0�.���%L##� �p����JQ����E*���*�����j����#0�"%G#&lt;��*�#0�*�#0
</code></pre>
</li>
</ol>
<h2 id="nimbos-3"><a class="header" href="#nimbos-3">NimbOS</a></h2>
<h3 id="准备-nimbos-镜像-2"><a class="header" href="#准备-nimbos-镜像-2">准备 NimbOS 镜像</a></h3>
<p><a href="https://github.com/arceos-hypervisor/nimbos">NimbOS</a> 仓库的 <a href="https://github.com/arceos-hypervisor/nimbos/releases/">release</a> 页面已经编译生成了可以直接运行的 NimbOS 二进制镜像文件压缩包：</p>
<ul>
<li>不带 <code>_usertests</code> 后缀的 NimbOS 二进制镜像包中编译的 NimbOS 启动后会进入 NimbOS 的 shell，本示例启动的就是这个 NimbOS</li>
<li>带 <code>usertests</code> 后缀的 NimbOS 二进制镜像压缩包中编译的 NimbOS 启动后会自动运行用户态测例用于测试，这个镜像用于 AxVisor 的CI测试，见 <a href="https://github.com/arceos-hypervisor/axvisor/blob/master/.github/workflows/actions/setup-nimbos-guest-image/action.yml">setup-nimbos-guest-image/action.yml</a></li>
</ul>
<h3 id="从文件系统加载运行-7"><a class="header" href="#从文件系统加载运行-7">从文件系统加载运行</a></h3>
<p>获取 AxVisor 主线代码 <code>git clone git@github.com:arceos-hypervisor/axvisor.git</code>，然后在 <code>axvisor</code> 源码目录中执行如下步骤：</p>
<ol>
<li>
<p>制作一个磁盘镜像文件，并将客户机镜像放到文件系统中</p>
<ol>
<li>
<p>使用 <code>make disk_img</code> 命令生成一个空的 FAT32 磁盘镜像文件 <code>disk.img</code></p>
</li>
<li>
<p>手动挂载 <code>disk.img</code>，然后拉取并解压二进制镜像</p>
<pre><code class="language-bash">$ mkdir -p tmp
$ sudo mount disk.img tmp
$ wget https://github.com/arceos-hypervisor/nimbos/releases/download/v0.7/riscv64.zip
$ unzip riscv64.zip # 得到 nimbos.bin
$ sudo mv nimbos.bin tmp/nimbos-riscv64.bin
$ sudo umount tmp
</code></pre>
</li>
</ol>
</li>
<li>
<p>直接使用 <a href="https://github.com/arceos-hypervisor/axvisor/blob/master/configs/vms/nimbos-riscv64.toml"><code>configs/vms/nimbos-riscv64.toml</code></a> 文件中的配置项</p>
<ul>
<li><code>image_location="fs"</code> 表示从文件系统加载</li>
<li><code>kernel_path</code> 指出内核镜像在文件系统中的路径</li>
<li><code>entry_point</code> 指出内核镜像的入口地址。必须与上面构建的 ArceOS 内核镜像的入口地址一致</li>
<li><code>kernel_load_addr</code> 指出内核镜像的加载地址。默认与 <code>entry_point</code> 一致</li>
<li>其他</li>
</ul>
</li>
<li>
<p>执行 <code>make ACCEL=n ARCH=riscv64 LOG=info VM_CONFIGS=configs/vms/nimbos-riscv64.toml FEATURES=page-alloc-64g APP_FEATURES=fs defconfig</code> 创建 <code>.axconfig.toml</code> 配置文件</p>
</li>
<li>
<p>执行 <code>make ACCEL=n ARCH=riscv64 LOG=info VM_CONFIGS=configs/vms/nimbos-riscv64.toml FEATURES=page-alloc-64g APP_FEATURES=fs run</code> 构建 AxVisor，并在 QEMU 中启动。</p>
<pre><code class="language-plaintext">qemu-system-riscv64 -m 4G -smp 1 -machine virt -bios default -kernel /code/new/axvisor/axvisor_riscv64-qemu-virt.bin -device virtio-blk-pci,drive=disk0 -drive id=disk0,if=none,format=raw,file=disk.img -nographic

OpenSBI v1.3
   ____                    _____ ____ _____
  / __ \                  / ____|  _ \_   _|
 | |  | |_ __   ___ _ __ | (___ | |_) || |
 | |  | | '_ \ / _ \ '_ \ \___ \|  _ &lt; | |
 | |__| | |_) |  __/ | | |____) | |_) || |_
  \____/| .__/ \___|_| |_|_____/|___/_____|
        | |
        |_|

Platform Name             : riscv-virtio,qemu
Platform Features         : medeleg
Platform HART Count       : 1
Platform IPI Device       : aclint-mswi
Platform Timer Device     : aclint-mtimer @ 10000000Hz
Platform Console Device   : uart8250
Platform HSM Device       : ---
Platform PMU Device       : ---
Platform Reboot Device    : sifive_test
Platform Shutdown Device  : sifive_test
Platform Suspend Device   : ---
Platform CPPC Device      : ---
Firmware Base             : 0x80000000
Firmware Size             : 322 KB
Firmware RW Offset        : 0x40000
Firmware RW Size          : 66 KB
Firmware Heap Offset      : 0x48000
Firmware Heap Size        : 34 KB (total), 2 KB (reserved), 9 KB (used), 22 KB (free)
Firmware Scratch Size     : 4096 B (total), 760 B (used), 3336 B (free)
Runtime SBI Version       : 1.0

Domain0 Name              : root
Domain0 Boot HART         : 0
Domain0 HARTs             : 0*
Domain0 Region00          : 0x0000000002000000-0x000000000200ffff M: (I,R,W) S/U: ()
Domain0 Region01          : 0x0000000080040000-0x000000008005ffff M: (R,W) S/U: ()
Domain0 Region02          : 0x0000000080000000-0x000000008003ffff M: (R,X) S/U: ()
Domain0 Region03          : 0x0000000000000000-0xffffffffffffffff M: (R,W,X) S/U: (R,W,X)
Domain0 Next Address      : 0x0000000080200000
Domain0 Next Arg1         : 0x00000000bfe00000
Domain0 Next Mode         : S-mode
Domain0 SysReset          : yes
Domain0 SysSuspend        : yes

Boot HART ID              : 0
Boot HART Domain          : root
Boot HART Priv Version    : v1.12
Boot HART Base ISA        : rv64imafdch
Boot HART ISA Extensions  : time,sstc
Boot HART PMP Count       : 16
Boot HART PMP Granularity : 4
Boot HART PMP Address Bits: 54
Boot HART MHPM Count      : 16
Boot HART MIDELEG         : 0x0000000000001666
Boot HART MEDELEG         : 0x0000000000f0b509

       d8888                            .d88888b.   .d8888b.
      d88888                           d88P" "Y88b d88P  Y88b
     d88P888                           888     888 Y88b.
    d88P 888 888d888  .d8888b  .d88b.  888     888  "Y888b.
   d88P  888 888P"   d88P"    d8P  Y8b 888     888     "Y88b.
  d88P   888 888     888      88888888 888     888       "888
 d8888888888 888     Y88b.    Y8b.     Y88b. .d88P Y88b  d88P
d88P     888 888      "Y8888P  "Y8888   "Y88888P"   "Y8888P"

arch = riscv64
platform = riscv64-qemu-virt
target = riscv64gc-unknown-none-elf
build_mode = release
log_level = info
smp = 1

[  0.028791 0 axruntime:139] Logging is enabled.
[  0.029501 0 axruntime:140] Primary CPU 0 started, dtb = 0x0.
[  0.029828 0 axruntime:142] Found physcial memory regions:
[  0.030204 0 axruntime:144]   [PA:0x80200000, PA:0x8026d000) .text (READ | EXECUTE | RESERVED)
[  0.030682 0 axruntime:144]   [PA:0x8026d000, PA:0x80286000) .rodata (READ | RESERVED)
[  0.030992 0 axruntime:144]   [PA:0x80286000, PA:0x80289000) .data .tdata .tbss .percpu (READ | WRITE | RESERVED)
[  0.031321 0 axruntime:144]   [PA:0x80289000, PA:0x802c9000) boot stack (READ | WRITE | RESERVED)
[  0.031626 0 axruntime:144]   [PA:0x802c9000, PA:0x804ed000) .bss (READ | WRITE | RESERVED)
[  0.031943 0 axruntime:144]   [PA:0x804ed000, PA:0x88000000) free memory (READ | WRITE | FREE)
[  0.032269 0 axruntime:144]   [PA:0x101000, PA:0x102000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.032566 0 axruntime:144]   [PA:0xc000000, PA:0xc210000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.032859 0 axruntime:144]   [PA:0x10000000, PA:0x10001000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.033155 0 axruntime:144]   [PA:0x10001000, PA:0x10009000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.033483 0 axruntime:144]   [PA:0x30000000, PA:0x40000000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.033778 0 axruntime:144]   [PA:0x40000000, PA:0x80000000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.034125 0 axruntime:226] Initialize global memory allocator...
[  0.034382 0 axruntime:227]   use TLSF allocator.
[  0.035886 0 axmm:72] Initialize virtual memory management...
[  0.059650 0 axruntime:159] Initialize platform devices...
[  0.059981 0 axtask::api:73] Initialize scheduling...
[  0.061045 0:2 axtask::api:79]   use FIFO scheduler.
[  0.061406 0:2 axdriver:172] Initialize device drivers...
[  0.061668 0:2 axdriver:173]   device model: static
[  0.065304 0:2 virtio_drivers::device::blk:59] config: 0xffffffc040006000
[  0.065747 0:2 virtio_drivers::device::blk:64] found a block device of size 65536KB
[  0.066567 0:2 axdriver::bus::pci:104] registered a new Block device at 00:01.0: "virtio-blk"
[  0.096997 0:2 axfs:41] Initialize filesystems...
[  0.097260 0:2 axfs:44]   use block device 0: "virtio-blk"
[  0.107167 0:2 fatfs::dir:139] Is a directory
[  0.114616 0:2 fatfs::dir:139] Is a directory
[  0.124030 0:2 fatfs::dir:139] Is a directory
[  0.133590 0:2 fatfs::dir:139] Is a directory
[  0.137773 0:2 axruntime:192] Initialize interrupt handlers...
[  0.138349 0:2 axruntime:204] Primary CPU 0 init OK.


    _         __     ___
   / \   __  _\ \   / (_)___  ___  _ __
  / _ \  \ \/ /\ \ / /| / __|/ _ \| '__|
 / ___ \  &gt;  &lt;  \ V / | \__ \ (_) | |
/_/   \_\/_/\_\  \_/  |_|___/\___/|_|


by AxVisor Team

[  0.139243 0:2 axvisor:21] Starting virtualization...
[  0.139504 0:2 axvisor:22] Hardware support: true
[  0.140719 0:4 axvisor::vmm::timer:101] Initing HV Timer...
[  0.141091 0:4 axvisor::hal:122] Hardware virtualization support enabled on core 0
[  0.154782 0:2 axvisor::vmm::config:33] Creating VM[1] "nimbos"
[  0.155608 0:2 axvm::vm:114] Setting up memory region: [0x90000000~0x91000000] READ | WRITE | EXECUTE | USER
[  0.158804 0:2 axvm::vm:166] Setting up passthrough device memory region: [0xc000000~0xc210000] -&gt; [0xc000000~0xc210000]
[  0.159618 0:2 axvm::vm:166] Setting up passthrough device memory region: [0x10000000~0x10001000] -&gt; [0x10000000~0x10001000]
[  0.160212 0:2 axvm::vm:202] VM[1] created
[  0.160527 0:2 axvm::vm:217] VM[1] vcpus set up
[  0.160803 0:2 axvisor::vmm::config:40] VM[1] created success, loading images...
[  0.161133 0:2 axvisor::vmm::images::fs:153] Loading VM images from filesystem
[  0.211299 0:2 axvisor::vmm:35] Setting up vcpus...
[  0.211971 0:2 axvisor::vmm::vcpus:219] Initializing VM[1]'s 1 vcpus
[  0.212344 0:2 axvisor::vmm::vcpus:250] Spawning task for VM[1] VCpu[0]
[  0.212914 0:2 axvisor::vmm::vcpus:262] VCpu task Task(5, "VM[1]-VCpu[0]") created cpumask: [0, ]
[  0.213460 0:2 axvisor::vmm:43] VMM starting, booting VMs...
[  0.213842 0:2 axvm::vm:284] Booting VM[1]
[  0.214197 0:2 axvisor::vmm:49] VM[1] boot success
[  0.214614 0:2 axvisor::vmm:60] a VM exited, current running VM count: 1
[  0.215355 0:5 axvisor::vmm::vcpus:283] VM[1] VCpu[0] waiting for running
[  0.215844 0:5 axvisor::vmm::vcpus:286] VM[1] VCpu[0] running...

NN   NN  iii               bb        OOOOO    SSSSS
NNN  NN       mm mm mmmm   bb       OO   OO  SS
NN N NN  iii  mmm  mm  mm  bbbbbb   OO   OO   SSSSS
NN  NNN  iii  mmm  mm  mm  bb   bb  OO   OO       SS
NN   NN  iii  mmm  mm  mm  bbbbbb    OOOO0    SSSSS
              ___    ____    ___    ___
             |__ \  / __ \  |__ \  |__ \
             __/ / / / / /  __/ /  __/ /
            / __/ / /_/ /  / __/  / __/
           /____/ \____/  /____/ /____/

arch = riscv64
platform = qemu-virt-riscv
build_mode = release
log_level = warn

Initializing kernel heap at: [0xffffffc0902920a8, 0xffffffc0906920a8)
Initializing frame allocator at: [PA:0x90693000, PA:0x98000000)
Mapping .text: [0xffffffc090200000, 0xffffffc090210000)
Mapping .rodata: [0xffffffc090210000, 0xffffffc090217000)
Mapping .data: [0xffffffc090217000, 0xffffffc09028e000)
Mapping .bss: [0xffffffc090292000, 0xffffffc090693000)
Mapping boot stack: [0xffffffc09028e000, 0xffffffc090292000)
Mapping physical memory: [0xffffffc090693000, 0xffffffc098000000)
Mapping MMIO: [0xffffffc00c000000, 0xffffffc00c210000)
Mapping MMIO: [0xffffffc010000000, 0xffffffc010001000)
Initializing drivers...
Initializing task manager...
/**** APPS ****
cyclictest
exit
fantastic_text
forktest
forktest2
forktest_simple
forktest_simple_c
forktree
hello_c
hello_world
matrix
poweroff
sleep
sleep_simple
stack_overflow
thread_simple
user_shell
usertests
yield
**************/
Running tasks...
test kernel task: pid = TaskId(2), arg = 0xdead
test kernel task: pid = TaskId(3), arg = 0xbeef
Rust user shell
&gt;&gt; 
</code></pre>
</li>
</ol>
<h3 id="从内存中加载运行-1"><a class="header" href="#从内存中加载运行-1">从内存中加载运行</a></h3>
<ul>
<li>
<p>获取 AxVisor 主线代码 <code>git clone git@github.com:arceos-hypervisor/axvisor.git</code>，然后在 <code>axvisor</code> 源码目录中执行如下步骤：</p>
<ol>
<li>
<p>修改对应的 <code>./configs/vms/nimbos-riscv64.toml</code> 中的配置项，注意设置 <code>kernel_path</code>  和 <code>bios_path</code> 为 nimbos 二进制内核镜像在工作空间中的相对/绝对路径</p>
<pre><code class="language-toml">[kernel]
# The entry point of the kernel image.
entry_point = 0x9020_0000
# The location of image: "memory" | "fs".
# Load from file system.
image_location = "memory"
# The file path of the kernel image.
kernel_path = "nimbos.bin"
# The load address of the kernel image.
kernel_load_addr = 0x9020_0000
</code></pre>
<ul>
<li><code>image_location="memory"</code> 配置项</li>
<li><code>kernel_path</code> 指定内核镜像在工作空间中的相对/绝对路径</li>
<li><code>entry_point</code> 指出内核镜像的入口地址。必须与上面构建的 ArceOS 内核镜像的入口地址一致</li>
<li><code>kernel_load_addr</code> 指出内核镜像的加载地址。默认与 <code>entry_point</code> 一致</li>
<li><code>bios_path</code> 可通过 <a href="https://github.com/arceos-hypervisor/axvm-bios-x86/releases/download/v0.1/axvm-bios.bin">链接</a> 直接下载，或参考 riscv64 用户虚拟机的极简BIOS实现 <a href="https://github.com/arceos-hypervisor/axvm-bios-x86">axvm-bios</a></li>
<li><code>bios_load_addr</code> 指出 bios 镜像的加载地址，默认为  0x8000</li>
<li>其他</li>
</ul>
</li>
<li>
<p>执行 <code>make ACCEL=n ARCH=riscv64 LOG=info VM_CONFIGS=configs/vms/nimbos-riscv64.toml FEATURES=page-alloc-64g run</code> 构建 AxVisor，并在 QEMU 中启动。</p>
<pre><code class="language-plaintext">qemu-system-riscv64 -m 4G -smp 1 -machine virt -bios default -kernel /code/new/axvisor/axvisor_riscv64-qemu-virt.bin -device virtio-blk-pci,drive=disk0 -drive id=disk0,if=none,format=raw,file=disk.img -nographic

OpenSBI v1.3
   ____                    _____ ____ _____
  / __ \                  / ____|  _ \_   _|
 | |  | |_ __   ___ _ __ | (___ | |_) || |
 | |  | | '_ \ / _ \ '_ \ \___ \|  _ &lt; | |
 | |__| | |_) |  __/ | | |____) | |_) || |_
  \____/| .__/ \___|_| |_|_____/|___/_____|
        | |
        |_|

Platform Name             : riscv-virtio,qemu
Platform Features         : medeleg
Platform HART Count       : 1
Platform IPI Device       : aclint-mswi
Platform Timer Device     : aclint-mtimer @ 10000000Hz
Platform Console Device   : uart8250
Platform HSM Device       : ---
Platform PMU Device       : ---
Platform Reboot Device    : sifive_test
Platform Shutdown Device  : sifive_test
Platform Suspend Device   : ---
Platform CPPC Device      : ---
Firmware Base             : 0x80000000
Firmware Size             : 322 KB
Firmware RW Offset        : 0x40000
Firmware RW Size          : 66 KB
Firmware Heap Offset      : 0x48000
Firmware Heap Size        : 34 KB (total), 2 KB (reserved), 9 KB (used), 22 KB (free)
Firmware Scratch Size     : 4096 B (total), 760 B (used), 3336 B (free)
Runtime SBI Version       : 1.0

Domain0 Name              : root
Domain0 Boot HART         : 0
Domain0 HARTs             : 0*
Domain0 Region00          : 0x0000000002000000-0x000000000200ffff M: (I,R,W) S/U: ()
Domain0 Region01          : 0x0000000080040000-0x000000008005ffff M: (R,W) S/U: ()
Domain0 Region02          : 0x0000000080000000-0x000000008003ffff M: (R,X) S/U: ()
Domain0 Region03          : 0x0000000000000000-0xffffffffffffffff M: (R,W,X) S/U: (R,W,X)
Domain0 Next Address      : 0x0000000080200000
Domain0 Next Arg1         : 0x00000000bfe00000
Domain0 Next Mode         : S-mode
Domain0 SysReset          : yes
Domain0 SysSuspend        : yes

Boot HART ID              : 0
Boot HART Domain          : root
Boot HART Priv Version    : v1.12
Boot HART Base ISA        : rv64imafdch
Boot HART ISA Extensions  : time,sstc
Boot HART PMP Count       : 16
Boot HART PMP Granularity : 4
Boot HART PMP Address Bits: 54
Boot HART MHPM Count      : 16
Boot HART MIDELEG         : 0x0000000000001666
Boot HART MEDELEG         : 0x0000000000f0b509

       d8888                            .d88888b.   .d8888b.
      d88888                           d88P" "Y88b d88P  Y88b
     d88P888                           888     888 Y88b.
    d88P 888 888d888  .d8888b  .d88b.  888     888  "Y888b.
   d88P  888 888P"   d88P"    d8P  Y8b 888     888     "Y88b.
  d88P   888 888     888      88888888 888     888       "888
 d8888888888 888     Y88b.    Y8b.     Y88b. .d88P Y88b  d88P
d88P     888 888      "Y8888P  "Y8888   "Y88888P"   "Y8888P"

arch = riscv64
platform = riscv64-qemu-virt
target = riscv64gc-unknown-none-elf
build_mode = release
log_level = info
smp = 1

[  0.029128 0 axruntime:139] Logging is enabled.
[  0.029882 0 axruntime:140] Primary CPU 0 started, dtb = 0x0.
[  0.030274 0 axruntime:142] Found physcial memory regions:
[  0.030696 0 axruntime:144]   [PA:0x80200000, PA:0x80251000) .text (READ | EXECUTE | RESERVED)
[  0.031218 0 axruntime:144]   [PA:0x80251000, PA:0x802ef000) .rodata (READ | RESERVED)
[  0.031503 0 axruntime:144]   [PA:0x802ef000, PA:0x802f2000) .data .tdata .tbss .percpu (READ | WRITE | RESERVED)
[  0.031857 0 axruntime:144]   [PA:0x802f2000, PA:0x80332000) boot stack (READ | WRITE | RESERVED)
[  0.032161 0 axruntime:144]   [PA:0x80332000, PA:0x80556000) .bss (READ | WRITE | RESERVED)
[  0.032476 0 axruntime:144]   [PA:0x80556000, PA:0x88000000) free memory (READ | WRITE | FREE)
[  0.032835 0 axruntime:144]   [PA:0x101000, PA:0x102000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.033141 0 axruntime:144]   [PA:0xc000000, PA:0xc210000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.033443 0 axruntime:144]   [PA:0x10000000, PA:0x10001000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.033788 0 axruntime:144]   [PA:0x10001000, PA:0x10009000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.034118 0 axruntime:144]   [PA:0x30000000, PA:0x40000000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.034440 0 axruntime:144]   [PA:0x40000000, PA:0x80000000) mmio (READ | WRITE | DEVICE | RESERVED)
[  0.034835 0 axruntime:226] Initialize global memory allocator...
[  0.035089 0 axruntime:227]   use TLSF allocator.
[  0.036595 0 axmm:72] Initialize virtual memory management...
[  0.060733 0 axruntime:159] Initialize platform devices...
[  0.061072 0 axtask::api:73] Initialize scheduling...
[  0.061923 0:2 axtask::api:79]   use FIFO scheduler.
[  0.062288 0:2 axruntime:192] Initialize interrupt handlers...
[  0.062840 0:2 axruntime:204] Primary CPU 0 init OK.


    _         __     ___
   / \   __  _\ \   / (_)___  ___  _ __
  / _ \  \ \/ /\ \ / /| / __|/ _ \| '__|
 / ___ \  &gt;  &lt;  \ V / | \__ \ (_) | |
/_/   \_\/_/\_\  \_/  |_|___/\___/|_|


by AxVisor Team

[  0.063905 0:2 axvisor:21] Starting virtualization...
[  0.064163 0:2 axvisor:22] Hardware support: true
[  0.065268 0:4 axvisor::vmm::timer:101] Initing HV Timer...
[  0.065612 0:4 axvisor::hal:122] Hardware virtualization support enabled on core 0
[  0.080076 0:2 axvisor::vmm::config:33] Creating VM[1] "nimbos"
[  0.080732 0:2 axvm::vm:114] Setting up memory region: [0x90000000~0x91000000] READ | WRITE | EXECUTE | USER
[  0.083726 0:2 axvm::vm:166] Setting up passthrough device memory region: [0xc000000~0xc210000] -&gt; [0xc000000~0xc210000]
[  0.084622 0:2 axvm::vm:166] Setting up passthrough device memory region: [0x10000000~0x10001000] -&gt; [0x10000000~0x10001000]
[  0.085274 0:2 axvm::vm:202] VM[1] created
[  0.085570 0:2 axvm::vm:217] VM[1] vcpus set up
[  0.085875 0:2 axvisor::vmm::config:40] VM[1] created success, loading images...
[  0.086337 0:2 axvisor::vmm::images:49] Loading VM[1] images from memory
[  0.087756 0:2 axvisor::vmm:35] Setting up vcpus...
[  0.088338 0:2 axvisor::vmm::vcpus:219] Initializing VM[1]'s 1 vcpus
[  0.088714 0:2 axvisor::vmm::vcpus:250] Spawning task for VM[1] VCpu[0]
[  0.089229 0:2 axvisor::vmm::vcpus:262] VCpu task Task(5, "VM[1]-VCpu[0]") created cpumask: [0, ]
[  0.089767 0:2 axvisor::vmm:43] VMM starting, booting VMs...
[  0.090118 0:2 axvm::vm:284] Booting VM[1]
[  0.090381 0:2 axvisor::vmm:49] VM[1] boot success
[  0.090687 0:2 axvisor::vmm:60] a VM exited, current running VM count: 1
[  0.091268 0:5 axvisor::vmm::vcpus:283] VM[1] VCpu[0] waiting for running
[  0.091643 0:5 axvisor::vmm::vcpus:286] VM[1] VCpu[0] running...

NN   NN  iii               bb        OOOOO    SSSSS
NNN  NN       mm mm mmmm   bb       OO   OO  SS
NN N NN  iii  mmm  mm  mm  bbbbbb   OO   OO   SSSSS
NN  NNN  iii  mmm  mm  mm  bb   bb  OO   OO       SS
NN   NN  iii  mmm  mm  mm  bbbbbb    OOOO0    SSSSS
              ___    ____    ___    ___
             |__ \  / __ \  |__ \  |__ \
             __/ / / / / /  __/ /  __/ /
            / __/ / /_/ /  / __/  / __/
           /____/ \____/  /____/ /____/

arch = riscv64
platform = qemu-virt-riscv
build_mode = release
log_level = warn

Initializing kernel heap at: [0xffffffc0902920a8, 0xffffffc0906920a8)
Initializing frame allocator at: [PA:0x90693000, PA:0x98000000)
Mapping .text: [0xffffffc090200000, 0xffffffc090210000)
Mapping .rodata: [0xffffffc090210000, 0xffffffc090217000)
Mapping .data: [0xffffffc090217000, 0xffffffc09028e000)
Mapping .bss: [0xffffffc090292000, 0xffffffc090693000)
Mapping boot stack: [0xffffffc09028e000, 0xffffffc090292000)
Mapping physical memory: [0xffffffc090693000, 0xffffffc098000000)
Mapping MMIO: [0xffffffc00c000000, 0xffffffc00c210000)
Mapping MMIO: [0xffffffc010000000, 0xffffffc010001000)
Initializing drivers...
Initializing task manager...
/**** APPS ****
cyclictest
exit
fantastic_text
forktest
forktest2
forktest_simple
forktest_simple_c
forktree
hello_c
hello_world
matrix
poweroff
sleep
sleep_simple
stack_overflow
thread_simple
user_shell
usertests
yield
**************/
Running tasks...
test kernel task: pid = TaskId(2), arg = 0xdead
test kernel task: pid = TaskId(3), arg = 0xbeef
Rust user shell
&gt;&gt; 
</code></pre>
</li>
</ol>
</li>
</ul>
<style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () => window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () => { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY <200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() => { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () => { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() => { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) => (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) => { btn.addEventListener("click", (event) => { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="run-axvisor-on-aarch64"><a class="header" href="#run-axvisor-on-aarch64">Run AxVisor on AArch64</a></h1>
<p>对于 AArch64 架构，我们在黑芝麻 A1000、RK3588 开发板、ROC-RK3568-PC 开发板中做了测试。</p>
<style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () => window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () => { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY <200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() => { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () => { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() => { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) => (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) => { btn.addEventListener("click", (event) => { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="黑芝麻-a1000"><a class="header" href="#黑芝麻-a1000">黑芝麻 A1000</a></h1>
<p>目前，在黑芝麻 A1000 平台上已经对同时运行 ArceOS + Linux 的情况进行了验证。</p>
<h1 id="arceos-4"><a class="header" href="#arceos-4">ArceOS</a></h1>
<p>TODO</p>
<h1 id="linux-2"><a class="header" href="#linux-2">Linux</a></h1>
<p>TODO</p>
<h1 id="arceos--linux-1"><a class="header" href="#arceos--linux-1">ArceOS + Linux</a></h1>
<ol>
<li>
<p>镜像准备</p>
<ol>
<li>编译一个适合黑芝麻a1000平台的linux镜像，以及对应的dtb文件</li>
<li>编译一个只使用串口设备的arceos hello_world
<ul>
<li>在qemu使用的配置信息上进行修改即可</li>
<li>将串口更改为使用uart8250，将相应的串口地址进行改动</li>
<li>将起始地址和内存信息配置为guest arceos toml中使用的对应内存</li>
<li>配合guest arceos toml中使用的内存，在<code>mem.rs</code>文件中增加对应的一级页表信息，使arceos能够使用相应的内存</li>
</ul>
</li>
</ol>
</li>
<li>
<p>修改目前的<code>build.rs</code> 、<code>image.rs</code> 、<code>config.rs</code>文件，使其支持两个os从内存中加载（目前实现方式比较暴力）</p>
</li>
<li>
<p>配置<code>arceos-umhv/arceos-vmm/configs/platforms/aarch64-bsta1000b-virt-hv.toml</code>文件</p>
<pre><code class="language-toml"># Architecture identifier.
arch = "aarch64"                    # str    //host 架构
# Platform identifier.
platform = "aarch64-bsta1000b-hv"   # str    //host 平台

#
# Platform configs
#
[plat]
# Platform family.
family = "aarch64-bsta1000b"        # str

# Base address of the whole physical memory.
phys-memory-base = 0x1_9800_0000   //host物理内存起始地址
# Size of the whole physical memory.
phys-memory-size = 0x1800_0000    //host自身占用的物理内存大小
# Base physical address of the kernel image.
kernel-base-paddr = 0x1_a000_0000  //host内核起始物理地址
# Base virtual address of the kernel image.
kernel-base-vaddr = "0x0000_0001_a000_0000"   //host内核起始虚拟地址
# Linear mapping offset, for quick conversions between physical and virtual
# addresses.
phys-virt-offset = "0x0000_0000_0000_0000"
# Offset of bus address and phys address. some boards, the bus address is
# different from the physical address.
phys-bus-offset = 0
# Kernel address space base.
kernel-aspace-base = "0x0000_0000_0000_0000"
# Kernel address space size.
kernel-aspace-size = "0x0000_ffff_ffff_f000"

#
# Device specifications
#
[devices]
# MMIO regions with format (`base_paddr`, `size`).
//host 使用的物理设备
mmio-regions = [
    [0x20008000, 0x1000], # uart8250 UART0
    [0x32000000, 0x8000], # arm,gic-400
    [0x32011000, 0x1000], # CPU CSR
    [0x33002000, 0x1000], # Top CRM
    [0x70035000, 0x1000], # CRM reg
    [0x70038000, 0x1000], # aon pinmux
] # [(uint, uint)]
# VirtIO MMIO regions with format (`base_paddr`, `size`).
virtio-mmio-regions = []    # [(uint, uint)]

# Base physical address of the PCIe ECAM space.
pci-ecam-base = 0x30E0_2000

# UART Address
uart-paddr = 0x2000_8000        # uint
# UART IRQ number
uart-irq = 0xd5                 # uint

# GIC CPU Interface base address
gicc-paddr = 0x3200_2000        # uint
# GIC Distributor base address
gicd-paddr = 0x3200_1000        # uint

# BST A1000B board registers
cpu-csr-base = 0x3201_1000          # uint
a1000base-topcrm = 0x3300_2000      # uint
a1000base-safetycrm = 0x7003_5000   # uint
a1000base-aoncfg = 0x7003_8000      # uint

# PSCI
psci-method = "smc"     # str

# RTC (PL031) Address (Need to read from DTB).
rtc-paddr = 0x0         # uint

</code></pre>
</li>
<li>
<p>配置两个guest的相关信息</p>
<ol>
<li>
<p>配置<code>arceos-umhv/arceos-vmm/configs/vms/linux-a1000-aarch64-smp1.toml</code>文件，配置guest linux的初始信息</p>
<pre><code class="language-toml">id = 0                 //guest vm id
name = "linux-a1000"   //gueest vm name
vm_type = 1     
cpu_num = 1           //分配的vcpu数量
phys_cpu_ids = [0x00]   
phys_cpu_sets = [0x02]   // vcpu绑定在2核
entry_point = 0x8100_0000  //linux内核起始地址
kernel_load_addr = 0x8100_0000  //guest linux vm 镜像加载地址
dtb_load_addr = 0x82e0_0000     //guest linux dtb 加载地址

image_location = "memory"      //加载方式为从内存加载
kernel_path = "/mnt/cicv/xh/arceos-hypervisor/a1000_port/image/Image_6.1.54.bin" //guest linux 镜像 所在路径
dtb_path = "/mnt/cicv/xh/arceos-hypervisor/a1000_port/dts_dtb/bsta1000b-fada-chery-smp1.dtb" //guest linux dtb 所在路径
# ramdisk_path = ""
# ramdisk_load_addr = 0
# disk_path = "disk.img"
# Memory regions with format (`base_paddr`, `size`, `flags`).
//guest linux 所使用的物理内存
memory_regions = [
    [0x8000_0000, 0x7000_0000, 0x7, 1],#ram 1792MB
]


# Emu_devices
# Name Base-Ipa Ipa_len Alloc-Irq Emu-Type EmuConfig
emu_devices = [
]

# Pass-through devices
//guest linux 所控制的直通设备
passthrough_devices = [
	["most-devices", 0x0000_0000, 0x0000_0000, 0x8000_0000, 0x1],
]

</code></pre>
</li>
<li>
<p>配置<code>arceos-umhv/arceos-vmm/configs/vms/arceos-aarch64-hv.toml</code>文件，配置guest arceos 初始信息</p>
<pre><code class="language-toml">id = 1          //guest vm id
name = "arceos"    //guest vm name
vm_type = 1          // guest vm type
cpu_num = 1          // guest vcpu num
phys_cpu_sets = [1]  //将guest vcpu与1核进行绑定
# entry_point = 0x1_b008_0000
entry_point = 0x1_b000_0000  //guest arceos 内核启动地址

# The location of image: "memory" | "fs"
# image_location = "fs" 
image_location = "memory"    //guest arceos 加载方式为从内存中加载
# kernel_path = "/mnt/cicv/xh/arceos/examples/helloworld/helloworld_aarch64-bsta1000b.bin"
kernel_path = "/mnt/cicv/xh/arceos/examples/helloworld/helloworld_aarch64-qemu-virt.bin"   //guest arceos kernel 镜像地址
# /mnt/cicv/xh/arceos/examples/helloworld/helloworld_aarch64-qemu-virt.bin
kernel_load_addr = 0x1_b000_0000 //guest arceos 内核加载地址

# bios_path = ""
# bios_load_addr = 0
# ramdisk_path = ""
# ramdisk_load_addr = 0
# disk_path = ""
# Memory regions with format (`base_paddr`, `size`, `flags`, `map_type`).
# For `map_type`, 0 means `MAP_ALLOC`, 1 means `MAP_IDENTICAL`.
//guest arceos 使用的内存信息
memory_regions = [
    # [0x8000_0000, 0x0800_0000, 0x7, 1],   # Low RAM		    16M 0b00111 R|W|EXECUTE
    [0x1_b000_0000, 0x0800_0000, 0x7, 1]
]

# Emu_devices
# Name Base-Ipa Ipa_len Alloc-Irq Emu-Type EmuConfig
emu_devices = []

# Pass-through devices
# Name Base-Ipa Base-Pa Length Alloc-Irq
passthrough_devices = [


    ["uart8250", 0x20008000, 0x20008000, 0x1000, 0x01],   # uart8250 UART0

]
</code></pre>
</li>
</ol>
</li>
<li>
<p>使用<code>make A=(pwd) ARCH=aarch64 VM_CONFIGS=configs/vms/linux-a1000-aarch64-smp1.toml:configs/vms/arceos-aarch64.toml PLAT_NAME=aarch64-bsta1000b-virt-hv FEATURES=page-alloc-64g,hv LOG=info SMP=2 fada</code> 编译出镜像</p>
</li>
<li>
<p>将镜像替换原有的内核，断电重启</p>
<pre><code class="language-shell">baudrate: 115200

Load ATF and UBOOT from Zone A

NOTICE:  BL31: Built : 10:13:03, Mar 30 2023


U-Boot 2019.04+2.1.1+g8fc26249.202303300858+ (Mar 30 2023 - 08:58:21 +0800)Bst A1000B, Build: jenkins-a1000_uboot_hvte_rootfs_all-4984

Press 'ctrl+C/c' to stop autoboot:  0
7020 bytes read in 5 ms (1.3 MiB/s)
normal mode
8204856 bytes read in 186 ms (42.1 MiB/s)
62598 bytes read in 12 ms (5 MiB/s)
## Loading kernel from FIT Image at 90000000 ...
   Trying 'kernel' kernel subimage
     Description:  ArceOS for BST A1000B
     Type:         Kernel Image
     Compression:  gzip compressed
     Data Start:   0x900000fc
     Data Size:    8143392 Bytes = 7.8 MiB
     Architecture: AArch64
     OS:           Linux
     Load Address: 0x1a0000000
     Entry Point:  0x1a0000000
     Hash algo:    md5
     Hash value:   de3de880d16c71162738fe3a09493347
     Hash algo:    sha1
     Hash value:   b1201ff1b8418e5e2f1f27cf2f3daf0275f9a605
   Verifying Hash Integrity ... md5+ sha1+ OK
## Flattened Device Tree blob at 80000000
   Booting using the fdt blob at 0x80000000
   Uncompressing Kernel Image ... load_buf:00000001a0000000,  image_buf:00000000900000fc
image_len:7c4220 comp:1
OK
   Loading Device Tree to 00000001ce7ed000, end 00000001ce7ff485 ... OK
enable hyp val 30

Starting kernel ...


       d8888                            .d88888b.   .d8888b.
      d88888                           d88P" "Y88b d88P  Y88b
     d88P888                           888     888 Y88b.
    d88P 888 888d888  .d8888b  .d88b.  888     888  "Y888b.
   d88P  888 888P"   d88P"    d8P  Y8b 888     888     "Y88b.
  d88P   888 888     888      88888888 888     888       "888
 d8888888888 888     Y88b.    Y8b.     Y88b. .d88P Y88b  d88P
d88P     888 888      "Y8888P  "Y8888   "Y88888P"   "Y8888P"

arch = aarch64
platform = aarch64-bsta1000b-virt-hv
target = aarch64-unknown-none-softfloat
build_mode = release
log_level = info
smp = 2

[  3.041875 axruntime:130] Logging is enabled.
[  3.047985 axruntime:131] Primary CPU 0 started, dtb = 0x1ce7ed000.
[  3.056196 axruntime:133] Found physcial memory regions:
[  3.063360 axruntime:135]   [PA:0x1a0000000, PA:0x1a0062000) .text (READ | EXECUTE | RESERVED)
[  3.074146 axruntime:135]   [PA:0x1a0062000, PA:0x1a1901000) .rodata (READ | RESERVED)
[  3.084172 axruntime:135]   [PA:0x1a1901000, PA:0x1a1909000) .data .tdata .tbss .percpu (READ | WRITE | RESERVED)
[  3.096775 axruntime:135]   [PA:0x1a1909000, PA:0x1a1989000) boot stack (READ | WRITE | RESERVED)
[  3.107851 axruntime:135]   [PA:0x1a1989000, PA:0x1a1baf000) .bss (READ | WRITE | RESERVED)
[  3.118354 axruntime:135]   [PA:0x1a1baf000, PA:0x1b0000000) free memory (READ | WRITE | FREE)
[  3.129143 axruntime:135]   [PA:0x80000000, PA:0xf0000000) reserved memory (READ | WRITE | EXECUTE | RESERVED)
[  3.141460 axruntime:135]   [PA:0x1b0000000, PA:0x1f0000000) reserved memory (READ | WRITE | EXECUTE | RESERVED)
[  3.153968 axruntime:135]   [PA:0x20008000, PA:0x20009000) mmio (READ | WRITE | DEVICE | RESERVED)
[  3.165139 axruntime:135]   [PA:0x32000000, PA:0x32008000) mmio (READ | WRITE | DEVICE | RESERVED)
[  3.176310 axruntime:135]   [PA:0x32011000, PA:0x32012000) mmio (READ | WRITE | DEVICE | RESERVED)
[  3.187481 axruntime:135]   [PA:0x33002000, PA:0x33003000) mmio (READ | WRITE | DEVICE | RESERVED)
[  3.198652 axruntime:135]   [PA:0x70035000, PA:0x70036000) mmio (READ | WRITE | DEVICE | RESERVED)
[  3.209824 axruntime:135]   [PA:0x70038000, PA:0x70039000) mmio (READ | WRITE | DEVICE | RESERVED)
[  3.220994 axruntime:208] Initialize global memory allocator...
[  3.228824 axruntime:209]   use TLSF allocator.
[  3.235195 axmm:60] Initialize virtual memory management...
[  3.263999 axruntime:150] Initialize platform devices...
[  3.271067 axhal::platform::aarch64_common::gic:67] Initialize GICv2...
[  3.279717 axtask::api:73] Initialize scheduling...
[  3.286374 axtask::api:79]   use FIFO scheduler.
[  3.292742 axhal::platform::aarch64_common::psci:115] Starting CPU 100 ON ...
[  3.301975 axruntime:176] Initialize interrupt handlers...
[  3.301975 axruntime::mp:37] Secondary CPU 1 started.
[  3.309263 axruntime:186] Primary CPU 0 init OK.
[  3.316168 axruntime::mp:47] Secondary CPU 1 init OK.
[  3.329406 0:2 arceos_vmm:17] Starting virtualization...
[  3.336566 0:2 arceos_vmm:19] Hardware support: true
[  3.343360 0:6 arceos_vmm::vmm::timer:103] Initing HV Timer...
[  3.349408 1:7 arceos_vmm::vmm::timer:103] Initing HV Timer...
[  3.351081 0:6 arceos_vmm::hal:117] Hardware virtualization support enabled on core 0
[  3.358813 1:7 arceos_vmm::hal:117] Hardware virtualization support enabled on core 1
[  3.378942 0:2 arceos_vmm::vmm::config:34] Creating VM [0] "linux-a1000"
[  3.387547 0:2 axvm::vm:113] Setting up memory region: [0x80000000~0xf0000000] READ | WRITE | EXECUTE
[  3.398997 0:2 arceos_vmm::hal:27] Failed to allocate memory region [PA:0x80000000~PA:0xf0000000]: NoMemory
[  3.429479 0:2 axvm::vm:156] Setting up passthrough device memory region: [0x0~0x80000000] -&gt; [0x0~0x80000000]
[  3.462795 0:2 axvm::vm:191] VM created: id=0
[  3.468812 0:2 axvm::vm:206] VM setup: id=0
[  3.474734 0:2 arceos_vmm::vmm::config:41] VM[0] created success, loading images...
[  3.484473 0:2 arceos_vmm::vmm::images:38] Loading VM images from memory
[  3.528456 0:2 arceos_vmm::vmm::config:34] Creating VM [1] "arceos"
[  3.536585 0:2 axvm::vm:113] Setting up memory region: [0x1b0000000~0x1b8000000] READ | WRITE | EXECUTE
[  3.548225 0:2 arceos_vmm::hal:27] Failed to allocate memory region [PA:0x1b0000000~PA:0x1b8000000]: NoMemory
[  3.561771 0:2 axvm::vm:156] Setting up passthrough device memory region: [0x20008000~0x20009000] -&gt; [0x20008000~0x20009000]
[  3.575339 0:2 axvm::vm:191] VM created: id=1
[  3.581443 0:2 axvm::vm:206] VM setup: id=1
[  3.587364 0:2 arceos_vmm::vmm::config:41] VM[1] created success, loading images...
[  3.597103 0:2 arceos_vmm::vmm::images:64] Loading VM images from memory
[  3.605823 0:2 arceos_vmm::vmm:30] Setting up vcpus...
[  3.612765 0:2 arceos_vmm::vmm::vcpus:178] Initializing VM[0]'s 1 vcpus
[  3.621353 0:2 arceos_vmm::vmm::vcpus:209] Spawning task for VM[0] Vcpu[0]
[  3.630239 0:2 arceos_vmm::vmm::vcpus:221] Vcpu task Task(8, "VM[0]-VCpu[0]") created cpumask: [1, ]
[  3.641597 0:2 arceos_vmm::vmm::vcpus:178] Initializing VM[1]'s 1 vcpus
[  3.648676 1:8 arceos_vmm::vmm::vcpus:242] VM[0] Vcpu[0] waiting for running
[  3.650188 0:2 arceos_vmm::vmm::vcpus:209] Spawning task for VM[1] Vcpu[0]
[  3.668141 0:2 arceos_vmm::vmm::vcpus:221] Vcpu task Task(9, "VM[1]-VCpu[0]") created cpumask: [0, ]
[  3.679503 0:2 arceos_vmm::vmm:37] VMM starting, booting VMs...
[  3.687330 0:2 axvm::vm:273] Booting VM[0]
[  3.693156 0:2 arceos_vmm::vmm:43] VM[0] boot success
[  3.698675 1:8 arceos_vmm::vmm::vcpus:245] VM[0] Vcpu[0] running...
[  3.700029 0:2 axvm::vm:273] Booting VM[1]
[  3.714064 0:2 arceos_vmm::vmm:43] VM[1] boot success
[  3.720942 0:9 arceos_vmm::vmm::vcpus:242] VM[1] Vcpu[0] waiting for running
[  3.730010 0:9 arceos_vmm::vmm::vcpus:245] VM[1] Vcpu[0] running...
a
       d8888                            .d88888b.   .d8888b.
      d88888                           d88P" "Y88b d88P  Y88b
     d88P888                           888     888 Y88b.
    d88P 888 888d888  .d8888b  .d88b.  888     888  "Y888b.
   d88P  888 888P"   d88P"    d8P  Y8b 888     888     "Y88b.
  d88P   888 888     888      88888888 888     888       "888
 d8888888888 888     Y88b.    Y8b.     Y88b. .d88P Y88b  d88P
d88P     888 888      "Y8888P  "Y8888   "Y88888P"   "Y8888P"

arch = aarch64
platform = aarch64-qemu-virt
target = aarch64-unknown-none-softfloat
build_mode = release
log_level = debug
smp = 1

[  3.805794 0 axruntime:130] Logging is enabled.
[  3.812095 0 axruntime:131] Primary CPU 0 started, dtb = 0x0.
[  3.819733 0 axruntime:133] Found physcial memory regions:
[  3.827086 0 axruntime:135]   [PA:0x1b0000000, PA:0x1b0007000) .text (READ | EXECUTE | RESERVED)
[  3.838065 0 axruntime:135]   [PA:0x1b0007000, PA:0x1b0009000) .rodata (READ | RESERVED)
[  3.848281 0 axruntime:135]   [PA:0x1b0009000, PA:0x1b000d000) .data .tdata .tbss .percpu (READ | WRITE | RESERVED)
[  3.861076 0 axruntime:135]   [PA:0x1b000d000, PA:0x1b004d000) boot stack (READ | WRITE | RESERVED)
[  3.872342 0 axruntime:135]   [PA:0x1b004d000, PA:0x1b004e000) .bss (READ | WRITE | RESERVED)
[  3.883036 0 axruntime:135]   [PA:0x1b004e000, PA:0x1b8000000) free memory (READ | WRITE | FREE)
[  3.894017 0 axruntime:135]   [PA:0x20008000, PA:0x20009000) mmio (READ | WRITE | DEVICE | RESERVED)
[  3.905379 0 axruntime:150] Initialize platform devices...
[  3.912731 0 axruntime:188] Primary CPU 0 init OK.
Hello, world!
[    0.000000] Booting Linux on physical CPU 0x0000000000 [0x411fd050]
[    0.000000] Linux version 6.1.54-rt15-00068-g09f2347c9237 (tanghanwe@ubuntu-virtual-machine) (aarch64-linux-gnu-gcc (Ubuntu 9.4.0-15
[    0.000000] Machine model: BST A1000B FAD-A
[    0.000000] earlycon: uart8250 at MMIO32 0x0000000020008000 (options '')
[    0.000000] printk: bootconsole [uart8250] enabled
[    0.000000] Invalid option string for rodata: 'n'
[    0.000000] Reserved memory: created DMA memory pool at 0x000000008b000000, size 32 MiB
[    0.000000] OF: reserved mem: initialized node bst_atf@8b000000, compatible id shared-dma-pool
[    0.000000] Reserved memory: created DMA memory pool at 0x000000008fec0000, size 0 MiB
[    0.000000] OF: reserved mem: initialized node bst_tee@8fec0000, compatible id shared-dma-pool
[    0.000000] Reserved memory: created DMA memory pool at 0x000000008ff00000, size 1 MiB
[    0.000000] OF: reserved mem: initialized node bstn_cma@8ff00000, compatible id shared-dma-pool
[    0.000000] Reserved memory: created DMA memory pool at 0x000000009a000000, size 32 MiB
[    0.000000] OF: reserved mem: initialized node bst_cv_cma@9a000000, compatible id shared-dma-pool
[    0.000000] Reserved memory: created DMA memory pool at 0x000000009c000000, size 16 MiB
[    0.000000] OF: reserved mem: initialized node vsp@0x9c000000, compatible id shared-dma-pool
[    0.000000] Reserved memory: created DMA memory pool at 0x00000000a1000000, size 16 MiB
[    0.000000] OF: reserved mem: initialized node bst_isp@0xa1000000, compatible id shared-dma-pool
[    0.000000] Reserved memory: created CMA memory pool at 0x00000000b2000000, size 864 MiB
[    0.000000] OF: reserved mem: initialized node coreip_pub_cma@0xb2000000, compatible id shared-dma-pool
[    0.000000] Reserved memory: created CMA memory pool at 0x00000000e8000000, size 8 MiB
[    0.000000] OF: reserved mem: initialized node noc_pmu@0xe8000000, compatible id shared-dma-pool
[    0.000000] Reserved memory: created CMA memory pool at 0x00000000e8800000, size 8 MiB
[    0.000000] OF: reserved mem: initialized node canfd@0xe8800000, compatible id shared-dma-pool
[    0.000000] Zone ranges:
[    0.000000]   DMA      [mem 0x0000000080000000-0x00000000efffffff]
[    0.000000]   DMA32    empty
[    0.000000]   Normal   empty
[    0.000000] Movable zone start for each node
[    0.000000] Early memory node ranges
[    0.000000]   node   0: [mem 0x0000000080000000-0x000000008affffff]
[    0.000000]   node   0: [mem 0x000000008b000000-0x000000008cffffff]
[    0.000000]   node   0: [mem 0x000000008d000000-0x000000008fcfffff]
[    0.000000]   node   0: [mem 0x000000008fd00000-0x000000008fdfffff]
[    0.000000]   node   0: [mem 0x000000008fe00000-0x000000008febffff]
[    0.000000]   node   0: [mem 0x000000008fec0000-0x00000000b1ffffff]
[    0.000000]   node   0: [mem 0x00000000b2000000-0x00000000efffffff]
[    0.000000] Initmem setup node 0 [mem 0x0000000080000000-0x00000000efffffff]
[    0.000000] cma: Reserved 128 MiB at 0x0000000083000000
[    0.000000] psci: probing for conduit method from DT.
[    0.000000] psci: Using PSCI v0.1 Function IDs from DT
[    0.000000] percpu: Embedded 19 pages/cpu s40872 r8192 d28760 u77824
[    0.000000] Detected VIPT I-cache on CPU0
[    0.000000] CPU features: detected: Qualcomm erratum 1009, or ARM erratum 1286807, 2441009
[    0.000000] CPU features: detected: ARM errata 1165522, 1319367, or 1530923
[    0.000000] alternatives: applying boot alternatives
[    0.000000] Built 1 zonelists, mobility grouping on.  Total pages: 451584
[    0.000000] Kernel command line: earlycon=uart8250,mmio32,0x20008000 console=ttyS0,115200n8 memreserve=64M@0xf8000000 rdinit=/sbin/n
[    0.000000] Unknown kernel command line parameters "memreserve=64M@0xf8000000", will be passed to user space.
[    0.000000] Dentry cache hash table entries: 262144 (order: 9, 2097152 bytes, linear)
[    0.000000] Inode-cache hash table entries: 131072 (order: 8, 1048576 bytes, linear)
[    0.000000] mem auto-init: stack:off, heap alloc:off, heap free:off
[    0.000000] Memory: 148300K/1835008K available (11392K kernel code, 7766K rwdata, 3884K rodata, 1856K init, 2597K bss, 654516K rese)
[    0.000000] SLUB: HWalign=64, Order=0-3, MinObjects=0, CPUs=1, Nodes=1
[    0.000000] rcu: Hierarchical RCU implementation.
[    0.000000] rcu:     RCU restricting CPUs from NR_CPUS=8 to nr_cpu_ids=1.
[    0.000000]  Tracing variant of Tasks RCU enabled.
[    0.000000] rcu: RCU calculated value of scheduler-enlistment delay is 10 jiffies.
[    0.000000] rcu: Adjusting geometry for rcu_fanout_leaf=16, nr_cpu_ids=1
[    0.000000] NR_IRQS: 64, nr_irqs: 64, preallocated irqs: 0
[    0.000000] Root IRQ handler: gic_handle_irq
[    0.000000] rcu: srcu_init: Setting srcu_struct sizes based on contention.
[    0.000000] arch_timer: cp15 timer(s) running at 325.00MHz (virt).
[    0.000000] clocksource: arch_sys_counter: mask: 0x7ffffffffffffff max_cycles: 0x4af477f6aa, max_idle_ns: 440795207830 ns
[    0.000000] sched_clock: 59 bits at 325MHz, resolution 3ns, wraps every 4398046511103ns
[    0.009203] Console: colour dummy device 80x25
[    0.014105] Calibrating delay loop (skipped), value calculated using timer frequency.. 650.00 BogoMIPS (lpj=3250000)
[    0.025674] pid_max: default: 32768 minimum: 301
[    0.030832] LSM: Security Framework initializing
[    0.035944] SELinux:  Initializing.
[    0.039963] Mount-cache hash table entries: 4096 (order: 3, 32768 bytes, linear)
[    0.048098] Mountpoint-cache hash table entries: 4096 (order: 3, 32768 bytes, linear)
[    0.057524] cacheinfo: Unable to detect cache hierarchy for CPU 0
[    0.064574] cblist_init_generic: Setting adjustable number of callback queues.
[    0.072506] cblist_init_generic: Setting shift to 0 and lim to 1.
[    0.079357] rcu: Hierarchical SRCU implementation.
[    0.079359] rcu:     Max phase no-delay instances is 1000.
[    0.079396] printk: bootconsole [uart8250] printing thread started
[    0.090833] smp: Bringing up secondary CPUs ...
[    0.090836] smp: Brought up 1 node, 1 CPU
[    0.090841] SMP: Total of 1 processors activated.
[    0.090847] CPU features: detected: 32-bit EL0 Support
[    0.090852] CPU features: detected: Data cache clean to the PoU not required for I/D coherence
[    0.090856] CPU features: detected: Common not Private translations
[    0.090858] CPU features: detected: CRC32 instructions
[    0.090864] CPU features: detected: RCpc load-acquire (LDAPR)
[    0.090866] CPU features: detected: Privileged Access Never
[    0.090869] CPU features: detected: RAS Extension Support
[    0.090920] CPU: All CPU(s) started at EL1
[    0.090923] alternatives: applying system-wide alternatives
[    0.092365] devtmpfs: initialized
[    0.112929] clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 19112604462750000 ns
[    0.112943] futex hash table entries: 256 (order: 2, 16384 bytes, linear)
[    0.143754] pinctrl core: initialized pinctrl subsystem
[    0.144394] NET: Registered PF_NETLINK/PF_ROUTE protocol family
[    0.145208] DMA: preallocated 256 KiB GFP_KERNEL pool for atomic allocations
[    0.145267] DMA: preallocated 256 KiB GFP_KERNEL|GFP_DMA pool for atomic allocations
[    0.145333] DMA: preallocated 256 KiB GFP_KERNEL|GFP_DMA32 pool for atomic allocations
[    0.328274] printk: console [ttyS0] enabled
[    0.328278] printk: bootconsole [uart8250] disabled
[    0.328291] printk: bootconsole [uart8250] printing thread stopped
[    0.328548] dw-apb-uart 2000a000.serial: uart clock frequency (&amp;p-&gt;uartclk):25000000
[    0.328553] dw-apb-uart 2000a000.serial: uart clock frequency (baudclk):25000000
[    0.328557] dw-apb-uart 2000a000.serial: uart clock frequency (apb_pclk):100000000
[    0.328665] 2000a000.serial: ttyS1 at MMIO 0x2000a000 (irq = 32, base_baud = 1562500) is a 16550A
[    0.328889] dw-apb-uart 20009000.serial: uart clock frequency (&amp;p-&gt;uartclk):25000000
[    0.328894] dw-apb-uart 20009000.serial: uart clock frequency (baudclk):25000000
[    0.328898] dw-apb-uart 20009000.serial: uart clock frequency (apb_pclk):100000000
[    0.328996] 20009000.serial: ttyS2 at MMIO 0x20009000 (irq = 33, base_baud = 1562500) is a 16550A
[    0.329813] =======lt9211_probe in...
[    0.329816] =======lt9211_probe in1...
[    0.329818] nlt9211 4-002d: =======lt9211_probe in2...
[    0.329900] max96789 1-0040: *************MAX96789 RGB To MIPIDSI Config*************
[    0.329935] printk: console [ttyS0] printing thread started
[    0.412081] ====update_chnl_id in ...!
[    0.649752] MAX config start
[    1.999794] End of MAX config status 0
[    1.999945] Mali&lt;2&gt;:
[    1.999947] Inserting Mali v900 device driver.
[    1.999950] Mali&lt;2&gt;:
[    1.999950] Compiled: Jan 22 2025, time: 15:53:22.
[    1.999953] Mali&lt;2&gt;:
[    1.999954] Driver revision: -6.1.54.REL.B231218-68-g09f2347c9237
[    1.999956] Mali&lt;2&gt;:
[    1.999957] mali_module_init() registering driver
[    2.000028] Mali&lt;2&gt;:
[    2.000029] mali_probe(): Called for platform device 33300000.gpu
[    2.000113] Mali&lt;2&gt;:
[    2.000114] mali-450 device tree detected.
[    2.000252] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPP2 not found
[    2.000260] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPPMMU2 not found
[    2.000265] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPP3 not found
[    2.000271] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPPMMU3 not found
[    2.000276] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPP4 not found
[    2.000282] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPPMMU4 not found
[    2.000286] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPP5 not found
[    2.000292] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPPMMU5 not found
[    2.000297] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPP6 not found
[    2.000302] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPPMMU6 not found
[    2.000307] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPP7 not found
[    2.000311] mali-utgard 33300000.gpu: error -ENXIO: IRQ IRQPPMMU not found
[    2.000437] Mali&lt;2&gt;:
[    2.000439] Mali SWAP: Swap out threshold vaule is 60M
[    2.000453] Mali&lt;2&gt;:
[    2.000454] Mali memory settings (shared: 0xFFFFFFFF)
[    2.000458] Mali&lt;2&gt;:
[    2.000459] Using device defined frame buffer settings (0x01000000@0xB8000000)
[    2.000463] Mali&lt;2&gt;:
[    2.000464] Memory Validator installed for Mali physical address base=0xB8000000, size=0x01000000
[    2.000469] Mali&lt;2&gt;:
[    2.000471] Mali PMU: Creating Mali PMU core
[    2.000477] Mali&lt;2&gt;:
[    2.000478] Couldn't find pmu_switch_delay in device tree configuration.
[    2.000481] Mali&lt;2&gt;:
[    2.000482] Get pmu config from device tree configuration.
[    2.000484] Mali&lt;2&gt;:
[    2.000485] Using hw detect pmu config:
[    2.000488] Mali&lt;2&gt;:
[    2.000490] domain_config[0] = 0x1
[    2.000492] Mali&lt;2&gt;:
[    2.000493] domain_config[1] = 0x2
[    2.000495] Mali&lt;2&gt;:
[    2.000496] domain_config[2] = 0x4
[    2.000498] Mali&lt;2&gt;:
[    2.000499] domain_config[9] = 0x1
[    2.000501] Mali&lt;2&gt;:
[    2.000502] domain_config[10] = 0x2
[    2.000505] Mali&lt;2&gt;:
[    2.000506] Mali PM domain: Creating Mali PM domain (mask=0x00000001)
[    2.000508] Mali&lt;2&gt;:
[    2.000509] Mali PM domain: Creating Mali PM domain (mask=0x00000002)
[    2.000511] Mali&lt;2&gt;:
[    2.000512] Mali PM domain: Creating Mali PM domain (mask=0x00000004)
[    2.000514] Mali&lt;2&gt;:
[    2.000515] Mali PM domain: Creating Mali PM domain (mask=0x00001000)
[    2.000521] Mali&lt;2&gt;:
[    2.000522] Broadcast: Creating Mali Broadcast unit: Mali_Broadcast
[    2.000533] Mali&lt;2&gt;:
[    2.000534] Mali PP: Creating Mali PP core: Mali_PP0
[    2.000535] Mali&lt;2&gt;:
[    2.000536] Mali PP: Base address of PP core: 0x33308000
[    2.000589] Mali&lt;2&gt;:
[    2.000590] Found Mali GPU Mali-450 MP r0p0
[    2.000648] Mali&lt;2&gt;:
[    2.000650] Mali DLBU: Initializing
[    2.000666] Mali&lt;2&gt;:
[    2.000667] Mali L2 cache: Created Mali_L2:   8K, 4-way, 64byte cache line, 128bit external bus
[    2.000675] Mali&lt;2&gt;:
[    2.000676] Mali L2 cache: Created Mali_L2:  64K, 4-way, 64byte cache line, 128bit external bus
[    2.000686] Mali&lt;2&gt;:
[    2.000688] Mali MMU: Creating Mali MMU: Mali_GP_MMU
[    2.000709] Mali&lt;2&gt;:
[    2.000711] mali_mmu_probe_irq_acknowledge: intstat 0x3
[    2.000713] Mali&lt;2&gt;:
[    2.000714] Probe: Page fault detect: PASSED
[    2.000716] Mali&lt;2&gt;:
[    2.000717] Probe: Bus read error detect: PASSED
[    2.000726] Mali&lt;2&gt;:
[    2.000727] Mali GP: Creating Mali GP core: Mali_GP
[    2.000769] Mali&lt;2&gt;:
[    2.000770] Mali MMU: Creating Mali MMU: Mali_PP0_MMU
[    2.000789] Mali&lt;2&gt;:
[    2.000790] mali_mmu_probe_irq_acknowledge: intstat 0x3
[    2.000792] Mali&lt;2&gt;:
[    2.000793] Probe: Page fault detect: PASSED
[    2.000794] Mali&lt;2&gt;:
[    2.000796] Probe: Bus read error detect: PASSED
[    2.000804] Mali&lt;2&gt;:
[    2.000805] Mali PP: Creating Mali PP core: Mali_PP0
[    2.000806] Mali&lt;2&gt;:
[    2.000807] Mali PP: Base address of PP core: 0x33308000
[    2.000838] Mali&lt;2&gt;:
[    2.000840] Mali MMU: Creating Mali MMU: Mali_PP1_MMU
[    2.000865] Mali&lt;2&gt;:
[    2.000867] mali_mmu_probe_irq_acknowledge: intstat 0x3
[    2.000869] Mali&lt;2&gt;:
[    2.000870] Probe: Page fault detect: PASSED
[    2.000871] Mali&lt;2&gt;:
[    2.000872] Probe: Bus read error detect: PASSED
[    2.000881] Mali&lt;2&gt;:
[    2.000882] Mali PP: Creating Mali PP core: Mali_PP1
[    2.000883] Mali&lt;2&gt;:
[    2.000884] Mali PP: Base address of PP core: 0x3330a000
[    2.000909] Mali&lt;2&gt;:
[    2.000910] Starting new virtual group for MMU PP broadcast core Mali_PP_MMU_Broadcast
[    2.000912] Mali&lt;2&gt;:
[    2.000913] Mali DLBU: Creating Mali dynamic load balancing unit: Mali_DLBU
[    2.000918] Mali&lt;2&gt;:
[    2.000919] Broadcast: Creating Mali Broadcast unit: Mali_Broadcast
[    2.000925] Mali&lt;2&gt;:
[    2.000926] Mali MMU: Creating Mali MMU: Mali_PP_MMU_Broadcast
[    2.000930] Mali&lt;2&gt;:
[    2.000931] Mali PP: Creating Mali PP core: Mali_PP_Broadcast
[    2.000932] Mali&lt;2&gt;:
[    2.000933] Mali PP: Base address of PP core: 0x33316000
[    2.000971] Mali&lt;2&gt;:
[    2.000972] 2+0 PP cores initialized
[    2.000985] Mali&lt;2&gt;:
[    2.000987] Mali GPU Timer: 1000
[    2.000990] Mali&lt;2&gt;:
[    2.000990] Mali GPU Utilization: No platform utilization handler installed
[    2.000993] Mali&lt;2&gt;:
[    2.000994] Mali DVFS init: platform function callback incomplete, need check mali_gpu_device_data in platform .
[    2.001356] Mali&lt;2&gt;:
[    2.001358] mali_probe(): Successfully initialized driver for platform device 33300000.gpu
[    2.001417] Mali:
[    2.001419] Mali device driver loaded
[    2.001470] cacheinfo: Unable to detect cache hierarchy for CPU 0
[    2.006214] brd: module loaded
[    2.008623] loop: module loaded
[    2.009038] null_blk: disk nullb0 created
[    2.009042] null_blk: module loaded
[    2.009046] dummy-irq: no IRQ given.  Use irq=N
[    2.010260] slave@0 enforce active low on chipselect handle
[    2.021387] qspi0-nor0@0 enforce active low on chipselect handle
[    2.179081] spi-nor spi6.0: w25q256jw (32768 Kbytes)
[    2.179172] 2 fixed-partitions partitions found on MTD device spi6.0
[    2.179176] Creating 2 MTD partitions on "spi6.0":
[    2.179189] 0x000000000000-0x000001e00000 : "nor0_part0"
[    2.179739] 0x000001e00000-0x000002000000 : "nor0_part1"
[    2.181991] bst_canfd 20016000.canfd: Driver registered: regs=0xffffffc009f54000, irq=44, clock=200000000
[    2.182428] bst_canfd 20016800.canfd: Driver registered: regs=0xffffffc009f58800, irq=45, clock=200000000
[    2.182935] bst_canfd 20017000.canfd: Driver registered: regs=0xffffffc009f5c000, irq=46, clock=200000000
[    2.183054] CAN device driver interface
[    2.183100] usbcore: registered new interface driver asix
[    2.183131] usbcore: registered new interface driver ax88179_178a
[    2.183156] usbcore: registered new interface driver cdc_ether
[    2.183175] usbcore: registered new interface driver net1080
[    2.183192] usbcore: registered new interface driver cdc_subset
[    2.183208] usbcore: registered new interface driver zaurus
[    2.183239] usbcore: registered new interface driver cdc_ncm
[    2.183263] usbcore: registered new interface driver r8153_ecm
[    2.183804] dwc3,usb:dwc3_set_reqinfo_len,1082
[    2.190672] bst-dwc3 amba_apu@0:usb2: usb30 could not find power control gpio.
[    2.190896] dwc3,usb:dwc3_set_reqinfo_len,1082
[    2.191939] xhci-hcd xhci-hcd.0.auto: xHCI Host Controller
[    2.191956] xhci-hcd xhci-hcd.0.auto: new USB bus registered, assigned bus number 1
[    2.192359] xhci-hcd xhci-hcd.0.auto: hcc params 0x0220fe64 hci version 0x110 quirks 0x0000000000010010
[    2.192392] xhci-hcd xhci-hcd.0.auto: irq 47, io mem 0x30200000
[    2.192515] xhci-hcd xhci-hcd.0.auto: xHCI Host Controller
[    2.192523] xhci-hcd xhci-hcd.0.auto: new USB bus registered, assigned bus number 2
[    2.192530] xhci-hcd xhci-hcd.0.auto: Host supports USB 3.0 SuperSpeed
[    2.192901] hub 1-0:1.0: USB hub found
[    2.192934] hub 1-0:1.0: 1 port detected
[    2.193097] usb usb2: We don't know the algorithms for LPM for this host, disabling LPM.
[    2.193357] hub 2-0:1.0: USB hub found
[    2.193381] hub 2-0:1.0: 1 port detected
[    2.193626] usbcore: registered new interface driver uas
[    2.193670] usbcore: registered new interface driver usb-storage
[    2.193736] usbcore: registered new interface driver option
[    2.193749] usbserial: USB Serial support registered for GSM modem (1-port)
[    2.193848] gadgetfs: USB Gadget filesystem, version 24 Aug 2004
[    2.193950] i2c_dev: i2c /dev entries driver
[    2.194458] bst,maxim-deser-hub 2-0029: maxim_hub_parse_dt() line:1255 GMSL2
[    2.194468] bst,maxim-deser-hub 2-0029: lane-num = 2
[    2.194491] bst,maxim-deser-hub 2-0029: trigger-tx-gpio index0  = 8
[    2.194496] bst,maxim-deser-hub 2-0029: camera index is 0,ser is 42,ser_alias is 60,sensor addr is 36, sensor_i2c_addr_alias is 70
[    2.194505] bst,maxim-deser-hub 2-0029: parse_input_dt:: input device1 not found
[    2.194515] bst,maxim-deser-hub 2-0029: parse_input_dt:: input device2 not found
[    2.194527] bst,maxim-deser-hub 2-0029: parse_input_dt:: input device3 not found
[    2.246055] bst,maxim-deser-hub 2-0029: read_back REG_ENABLE : 0x14
[    2.251854] bst,maxim-deser-hub 2-0029: read_back REG_MNL : 0x10
[    2.251864] bst,maxim-deser-hub 2-0029: maxim_hub_probe: lock gpio -2 is invalid
[    2.359981] maxim hub probe done
[    2.360116] bst,maxim-deser-hub 2-002a: maxim_hub_parse_dt() line:1255 GMSL2
[    2.360136] bst,maxim-deser-hub 2-002a: trigger-tx-gpio index0  = 0
[    2.360141] bst,maxim-deser-hub 2-002a: camera index is 0,ser is 42,ser_alias is 64,sensor addr is 36, sensor_i2c_addr_alias is 54
[    2.360156] bst,maxim-deser-hub 2-002a: trigger-tx-gpio index1  = 0
[    2.360161] bst,maxim-deser-hub 2-002a: camera index is 1,ser is 42,ser_alias is 65,sensor addr is 36, sensor_i2c_addr_alias is 55
[    2.360177] bst,maxim-deser-hub 2-002a: trigger-tx-gpio index2  = 0
[    2.360182] bst,maxim-deser-hub 2-002a: camera index is 2,ser is 42,ser_alias is 66,sensor addr is 36, sensor_i2c_addr_alias is 56
[    2.360198] bst,maxim-deser-hub 2-002a: trigger-tx-gpio index3  = 0
[    2.360203] bst,maxim-deser-hub 2-002a: camera index is 3,ser is 42,ser_alias is 67,sensor addr is 36, sensor_i2c_addr_alias is 57
[    2.428511] bst,maxim-deser-hub 2-002a: read_back REG_ENABLE : 0x14
[    2.435440] bst,maxim-deser-hub 2-002a: read_back REG_MNL : 0x10
[    2.435449] bst,maxim-deser-hub 2-002a: maxim_hub_probe: lock gpio -2 is invalid
[    2.543722] maxim hub probe done
[    2.543952] bst,maxim-deser-hub 2-002e: maxim_hub_parse_dt() line:1255 GMSL2
[    2.543960] bst,maxim-deser-hub 2-002e: lane-num = 2
[    2.543975] bst,maxim-deser-hub 2-002e: trigger-tx-gpio index0  = 8
[    2.543980] bst,maxim-deser-hub 2-002e: camera index is 0,ser is 42,ser_alias is 48,sensor addr is 36, sensor_i2c_addr_alias is 58
[    2.543990] bst,maxim-deser-hub 2-002e: parse_input_dt:: input device1 not found
[    2.543995] bst,maxim-deser-hub 2-002e: parse_input_dt:: input port2 not found
[    2.543995]
[    2.544000] bst,maxim-deser-hub 2-002e: parse_input_dt:: input port3 not found
[    2.544000]
[    2.596048] i2c_transfer error, slave = 0x2e, reg = 0x17, ret = -121
[    2.617712] i2c_transfer error, slave = 0x2e, reg = 0x17, ret = -121
[    2.628477] i2c_transfer error, slave = 0x2e, reg = 0x17, ret = -121
[    2.633481] write_reg() line:177, write 2e:[17,14]failed!
[    2.633486] bst,maxim-deser-hub 2-002e: max96712_reg_write: write 0x17 failed
[    2.641093] i2c_transfer error, slave = 0x2e, reg = 0x19, ret = -121
[    2.648385] i2c_transfer error, slave = 0x2e, reg = 0x19, ret = -121
[    2.656981] i2c_transfer error, slave = 0x2e, reg = 0x19, ret = -121
[    2.661984] write_reg() line:177, write 2e:[19,10]failed!
[    2.661988] bst,maxim-deser-hub 2-002e: max96712_reg_write: write 0x19 failed
[    2.669782] i2c_transfer error, slave = 0x2e, reg = 0x17, ret = -121
[    2.681765] i2c_transfer error, slave = 0x2e, reg = 0x17, ret = -121
[    2.699231] i2c_transfer error, slave = 0x2e, reg = 0x17, ret = -121
[    2.704236] bst,maxim-deser-hub 2-002e: max96712_reg_read() line:256, read 0x2e:[0x17,0x74]failed!
[    2.704241] bst,maxim-deser-hub 2-002e: read_back REG_ENABLE : 0x74
[    2.706534] i2c_transfer error, slave = 0x2e, reg = 0x19, ret = -121
[    2.721833] i2c_transfer error, slave = 0x2e, reg = 0x19, ret = -121
[    2.730518] i2c_transfer error, slave = 0x2e, reg = 0x19, ret = -121
[    2.735523] bst,maxim-deser-hub 2-002e: max96712_reg_read() line:256, read 0x2e:[0x19,0x74]failed!
[    2.735529] bst,maxim-deser-hub 2-002e: read_back REG_MNL : 0x74
[    2.735538] bst,maxim-deser-hub 2-002e: maxim_hub_probe: lock gpio -2 is invalid
[    2.741656] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121
[    2.752880] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121
[    2.761914] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121
[    2.766918] bst,maxim-deser-hub 2-002e: max96712_reg_read() line:256, read 0x2e:[0x0,0x0]failed!
[    2.807958] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121
[    2.818290] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121
[    2.832877] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121
[    2.837882] bst,maxim-deser-hub 2-002e: max96712_reg_read() line:256, read 0x2e:[0x0,0x0]failed!
[    2.878198] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121
[    2.888876] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121
[    2.899817] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121
[    2.904822] bst,maxim-deser-hub 2-002e: max96712_reg_read() line:256, read 0x2e:[0x0,0x0]failed!
[    2.951156] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121
[    2.965569] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121
[    2.989650] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121
[    2.994655] bst,maxim-deser-hub 2-002e: max96712_reg_read() line:256, read 0x2e:[0x0,0x0]failed!
[    3.035950] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121
[    3.059508] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121
[    3.068798] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121
[    3.073802] bst,maxim-deser-hub 2-002e: max96712_reg_read() line:256, read 0x2e:[0x0,0x0]failed!
[    3.118634] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121
[    3.131052] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121
[    3.142345] i2c_transfer error, slave = 0x2e, reg = 0x0, ret = -121
[    3.147350] bst,maxim-deser-hub 2-002e: max96712_reg_read() line:256, read 0x2e:[0x0,0x0]failed!
[    3.189046] bst,maxim-deser-hub 2-002e: detect max96712 timeout
[    3.189049] bst,maxim-deser-hub 2-002e: maxim_hub_probe: not found max96712
[    3.189058] bst,maxim-deser-hub: probe of 2-002e failed with error -22
[    3.189676] a1000-csi2 csi@0: a1000_csi_probe
[    3.189682] a1000-csi2 csi@0: a1000_csi_probe
[    3.189708] mipi chn 0 connected
[    3.189712] mipi chn 1 connected
[    3.189716] mipi chn 2 connected
[    3.189719] mipi chn 3 connected
[    3.189835] a1000-csi2 csi@1: a1000_csi_probe
[    3.189840] a1000-csi2 csi@1: a1000_csi_probe
[    3.189861] mipi chn 0 connected
[    3.189865] mipi chn 1 connected
[    3.189869] mipi chn 2 connected
[    3.189873] mipi chn 3 connected
[    3.189971] a1000-csi2 csi@3: a1000_csi_probe
[    3.189976] a1000-csi2 csi@3: a1000_csi_probe
[    3.189993] mipi chn 0 connected
[    3.189997] mipi chn 1 connected
[    3.190000] mipi chn 2 not connected
[    3.190003] mipi chn 3 not connected
[    3.190172] bst_wdt 2001b000.watchdog: wdt bst_wdt_drv_probe, 517
[    3.190935] bst_wdt 2001c000.watchdog: wdt bst_wdt_drv_probe, 517
[    3.191072] bst_wdt 2001d000.watchdog: wdt bst_wdt_drv_probe, 517
[    3.191202] bst_wdt 32009000.watchdog: wdt bst_wdt_drv_probe, 517
[    3.191405] bst_wdt 3200a000.watchdog: wdt bst_wdt_drv_probe, 517
[    3.191578] bst_wdt 3200b000.watchdog: wdt bst_wdt_drv_probe, 517
[    3.191752] bst_wdt 3200c000.watchdog: wdt bst_wdt_drv_probe, 517
[    3.191939] bst_wdt 3200d000.watchdog: wdt bst_wdt_drv_probe, 517
[    3.192109] bst_wdt 3200e000.watchdog: wdt bst_wdt_drv_probe, 517
[    3.192301] bst_wdt 3200f000.watchdog: wdt bst_wdt_drv_probe, 517
[    3.192467] bst_wdt 32010000.watchdog: wdt bst_wdt_drv_probe, 517
[    3.192774] sdhci: Secure Digital Host Controller Interface driver
[    3.192777] sdhci: Copyright(c) Pierre Ossman
[    3.192778] sdhci-pltfm: SDHCI platform and OF driver helper
[    3.192969] sdhci-dwcmshc 30400000.dwmmc0: dwcmshc_probe
[    3.257851] mmc0: SDHCI controller on 30400000.dwmmc0 [30400000.dwmmc0] using ADMA
[    3.258001] sdhci-dwcmshc 30500000.dwmmc1: dwcmshc_probe
[    3.504668] mmc0: new high speed MMC card at address 0001
[    3.505324] mmcblk0: mmc0:0001 CJUD4R 59.6 GiB
[    3.577787]  mmcblk0: p1 p2 p3 p4 p5 p6 p7 p8 p9 p10
[    3.579269] mmcblk0boot0: mmc0:0001 CJUD4R 31.9 MiB
[    3.581351] mmcblk0boot1: mmc0:0001 CJUD4R 31.9 MiB
[    3.595544] mmcblk0rpmb: mmc0:0001 CJUD4R 4.00 MiB, chardev (239:0)
[    4.339768] i2c_designware 20005000.i2c: controller timed out
[    4.339788] sdhci_bst_i2c_write_bytes: i2c write failed: -110
[    5.379754] i2c_designware 20005000.i2c: controller timed out
[    5.379760] sdhci_bst_i2c_read_bytes:  i2c read 1 bytes from client@0x8 starting at reg 0x8d failed, error: -110
[    5.379765] sdhci_bst_i2c_voltage_sel: i2c test failed readdata: 255 send data:1
[    5.379768] sdhci_bst_voltage_switch failed
[    5.418222] mmc1: SDHCI controller on 30500000.dwmmc1 [30500000.dwmmc1] using ADMA
[    5.418423] hid: raw HID events driver (C) Jiri Kosina
[    5.418636] optee: probing for conduit method.
[    5.418663] optee: revision 3.11 (28993363)
[    5.419063] optee: initialized driver
[    5.419965] netem: version 1.3
[    5.419985] u32 classifier
[    5.419986]     Performance counters on
[    5.419987]     input device check on
[    5.419988]     Actions configured
[    5.420100] ipip: IPv4 and MPLS over IPv4 tunneling driver
[    5.420443] gre: GRE over IPv4 demultiplexor driver
[    5.420810] NET: Registered PF_INET6 protocol family
[    5.434247] Segment Routing with IPv6
[    5.434270] In-situ OAM (IOAM) with IPv6
[    5.434305] sit: IPv6, IPv4 and MPLS over IPv4 tunneling driver
[    5.434904] NET: Registered PF_PACKET protocol family
[    5.434908] can: controller area network core
[    5.434948] NET: Registered PF_CAN protocol family
[    5.434953] can: raw protocol
[    5.434959] 8021q: 802.1Q VLAN Support v1.8
[    5.435003] sctp: Hash tables configured (bind 256/256)
[    5.435180] Key type dns_resolver registered
[    5.435268] ipc 4fec00000.ipc: assigned reserved memory node bstn_cma@8ff00000
[    5.435621] Loading compiled-in X.509 certificates
[    5.510900] [bst_cv]: bst_cv_probe 48: BST_CV driver initializing ...
[    5.510916] [bst_cv]: bst_cv_probe 66: bst_sysfile_init OK
[    5.510923] [bst_cv]: bst_cv_mem_manager_init 307: phys_to_bus_offset: 0x0
[    5.510928] [bst_cv]: bst_cv_mem_manager_init 314: dma_set_coherent_mask OK.
[    5.511059] bst_cv 51030000.bst_cv: assigned reserved memory node bst_cv_cma@9a000000
[    5.511063] [bst_cv]: bst_cv_mem_manager_init 328: kern_sub_phys_offset: 0xffffffbf78000000
[    5.511068] [bst_cv]: bst_cv_probe 74: bst_cv_mem_manager_init OK
[    5.511111] [bst_cv]: bst_cv_probe 82: bst_cv_fw_manager_init OK
[    5.511184] [bst_cv]: bst_cv_probe 90: bst_cv_misc_init OK, /dev/bst_cv registered
[    5.511188] [bst_cv]: bst_cv_probe 96: bst_cv probe completed!
[    5.511304] [bst_lwnn]: bst_lwnn_probe 74: bst_lwnn driver initializing ...
[    5.511321] [bst_lwnn]: bst_lwnn_probe 93: bst_sysfile_init OK, /sys/kernel/bst_lwnn registered
[    5.511327] [bst_lwnn]: bst_lwnn_mem_manager_init 346: phys_to_bus_offset: 0x0
[    5.511331] [bst_lwnn]: bst_lwnn_mem_manager_init 353: dma_set_coherent_mask OK.
[    5.511355] bst_lwnn 51030000.bst_lwnn: assigned reserved memory node coreip_pub_cma@0xb2000000
[    5.511360] [bst_lwnn]: bst_lwnn_probe 101: bst_lwnn_mem_manager_init OK
[    5.511700] [bst_lwnn]: bst_lwnn_probe 109: bst_lwnn_fw_manager_init OK
[    5.511751] [bst_lwnn]: bst_lwnn_msg_manager_init 302: ipc_init OK
[    5.511871] [bst_lwnn]: bst_lwnn_msg_manager_init 334: worker creation OK
[    5.511876] [bst_lwnn]: bst_lwnn_probe 117: bst_lwnn_msg_manager_init OK
[    5.511936] [bst_lwnn]: bst_lwnn_probe 125: bst_lwnn_misc_init OK, /dev/bst_lwnn registered
[    5.511941] [bst_lwnn]: bst_lwnn_probe 133: bst_lwnn probe completed!
[    5.512064] [bstn]: bstn_probe 50: BSTN driver initializing ...
[    5.512068] [bstn]: bstn_probe 51: timeout_jiffies: 3200, timeout_ms 32000
[    5.512077] [bstn]: bstn_mem_manager_init 310: phys_to_bus_offset: 0x0
[    5.512083] [bstn]: bstn_mem_manager_init 324: reserved memory: base 0xb2000000 size 0x36000000
[    5.512088] [bstn]: bstn_mem_manager_init 333: dma_set_mask OK.
[    5.512091] [bstn]: bstn_mem_manager_init 340: dma_set_coherent_mask OK.
[    5.512097] bstn 50020000.bstn: assigned reserved memory node coreip_pub_cma@0xb2000000
[    5.512101] [bstn]: bstn_probe 76: bstn_mem_manager_init OK
[    5.512119] [bstn]: bstn_fw_manager_init 300: firmware: bstn_dsp_rtos.rbf
[    5.512165] [bstn]: bstn_fw_manager_init 320: assigned mem: 0xffffffc00a232000, 0xb2005000, size: 4096
[    5.512172] [bstn]: bstn_probe 84: bstn_fw_manager_init OK
[    5.512180] [bstn]: bstn_msg_manager_init 238: ipc_init OK
[    5.512203] [bstn]: bstn_msg_manager_init 262: req_bufs @ phys:0xb2006000
[    5.512258] [bstn]: bstn_msg_manager_init 286: bstn_msg_receiver task created 0xffffff800e434380
[    5.512263] [bstn]: bstn_probe 92: bstn_msg_manager_init OK
[    5.512273] [bstn]: bstn_probe 100: bstn_sysfile_init OK
[    5.512344] [bstn]: bstn_probe 108: bstn_misc_init OK, device[bstn0] registered
[    5.512348] [bstn]: bstn_probe 111: BSTN v2.5.3 probe completed
[    5.537056] bst_identify_probe
[    5.537343] vsp-ipc 9c000000.ipc_vsp: assigned reserved memory node vsp@0x9c000000
[    5.537379] init start = 0x9c200000, initp_size = 0x20660, align size = 0x21000
[    5.537384] cmdp start = 0x9c221000, cmdp_size = 0x2098a0, align size = 0x20a000
[    5.537387] slab start = 0x9c500000, end = 0x9c600000, slab_size = 0x100000
[    5.537390] total_alloc_size = 0x600000
[    5.538507] c0.base  = (____ptrval____), c1.base  = (____ptrval____), c2.base  = (____ptrval____)
[    5.560295] enter recv
[    5.560318] printk: console [netcon0] enabled
[    5.560321] netconsole: network logging started
[    5.560934] bstgmaceth 30000000.ethernet: error -ENXIO: IRQ rx_chan4_irq not found
[    5.561038] bstgmaceth 30000000.ethernet: error -ENXIO: IRQ tx_chan4_irq not found
[    5.561208] printk: console [netcon0] printing thread started
[    5.573255] bstgmaceth 30000000.ethernet: User ID: 0x10, Synopsys ID: 0x51
[    5.573264] bstgmaceth 30000000.ethernet:    DWMAC4/5
[    5.573270] bstgmaceth 30000000.ethernet: DMA HW capability register supported
[    5.573273] bstgmaceth 30000000.ethernet: RX Checksum Offload Engine supported
[    5.573276] bstgmaceth 30000000.ethernet: TX Checksum insertion supported
[    5.573289] bstgmaceth 30000000.ethernet (unnamed net_device) (uninitialized): device MAC address 6a:78:6a:e9:b1:c2
[    5.573298] bstgmaceth 30000000.ethernet: Enabled Flow TC (entries=2)
[    5.574338] bstgmaceth 30100000.ethernet: error -ENXIO: IRQ rx_chan4_irq not found
[    5.574444] bstgmaceth 30100000.ethernet: error -ENXIO: IRQ tx_chan4_irq not found
[    5.574803] bstgmaceth 30100000.ethernet: User ID: 0x10, Synopsys ID: 0x51
[    5.574810] bstgmaceth 30100000.ethernet:    DWMAC4/5
[    5.574814] bstgmaceth 30100000.ethernet: DMA HW capability register supported
[    5.574817] bstgmaceth 30100000.ethernet: RX Checksum Offload Engine supported
[    5.574821] bstgmaceth 30100000.ethernet: TX Checksum insertion supported
[    5.574830] bstgmaceth 30100000.ethernet (unnamed net_device) (uninitialized): device MAC address 7e:fc:7a:ea:0f:1c
[    5.574836] bstgmaceth 30100000.ethernet: Enabled Flow TC (entries=2)
[    6.043844] mdio_bus bstgmac-1: MDIO device at address 7 is missing.
[    6.044017] bstgmaceth 30100000.ethernet: Cannot register the MDIO bus err -19
[    6.044022] bstgmaceth 30100000.ethernet: bstgmac_dvr_probe: MDIO bus (id: 1) registration failed
[    6.044409] a1000_isp isp: isp_probe
[    6.044415] a1000_isp isp: isp_probe
[    6.044520] a1000_isp isp: init_isp_channel_devs channel 10 not enabled, skip
[    6.044525] a1000_isp isp: init_isp_channel_devs channel 11 not enabled, skip
[    6.044679] deser_notify_bound(),line 1069 channel[3]
[    6.044687] deser_notify_bound(),line 1069 channel[2]
[    6.044693] deser_notify_bound(),line 1069 channel[1]
[    6.044697] deser_notify_bound(),line 1069 channel[0]
[    6.044709] deser_notify_bound(),line 1069 channel[0]
[    6.044744] a1000_isp isp: assigned reserved memory node bst_isp@0xa1000000
[    6.045519] Enter dphy_config
[    6.045534] dphyTst_setCfg_lanes
[    6.279753]
[    6.279753] DPHY_SHUTDOWNZ(40) = 0
[    6.279756]
[    6.279756] DPHY lane_speed = 1600
[    6.279808]
[    6.279808] reg e5 value is 0x1
[    6.279814]
[    6.279814] reg 1ac value is 0x4b
[    6.279820] nreg e4 value is 0x11
[    6.279825]
[    6.279825] reg 8 value is 0x18
[    6.279827]
[    6.279827] DPHY_N_LANES(4) = 3(ENABLE RX)
[    6.279829]
[    6.279829] force rxmode = 0x3c0030
[    6.279831] dphyTst_release
[    6.279832]
[    6.279832] DPHY_SHUTDOWNZ(40) = 1
[    6.279834]
[    6.279834] DPHY_RSTZ(44) = 1
[    6.345208] dphyTst_release timeout
[    6.345211]
[    6.345211] dphy0 enable done.
[    6.345212] dphyTst_release_1_4lane
[    6.345214]
[    6.345214] DPHY_1_RSTZ = 3c003c
[    6.347220]
[    6.347220] dphy0 and dphy1 enter stopstate.
[    6.347222]
[    6.347222] release force rxmode = 0x3c
[    6.347224] dphyTst_release_1_4lane finish
[    6.347238] bst,maxim-deser-hub 2-002a: maxim_hub_s_power() line:986
[    6.347244] bst,maxim-deser-hub 2-002a: maxim_hub_s_power() line:1007 GMSL2
[    6.407974] bst,maxim-deser-hub 2-002a: max967XX_replicate_mode() line:509
[    6.408170] bst,maxim-deser-hub 2-002a: max96712_fsync_config() line:436, tr0
[    6.408938] bst,maxim-deser-hub 2-002a: INTERNAL TRIGGER MODE
[    6.409702] bst,maxim-deser-hub 2-002a: trig_info.trigger_tx_gpio[0] = 0
[    6.416644] bst,maxim-deser-hub 2-002a: modify_serdes_address() 254
[    6.750420] bst,maxim-deser-hub 2-002a: is_gmsl2_video_connected() index = 0d
[    6.811052] bst,maxim-deser-hub 2-002a: is_gmsl2_video_connected() index = 1d
[    6.871687] bst,maxim-deser-hub 2-002a: is_gmsl2_video_connected() index = 2d
[    6.932321] bst,maxim-deser-hub 2-002a: is_gmsl2_video_connected() index = 3d

CTRL-A Z for help | 115200 8N1 | NOR | Minicom 2.9 | VT102 | Offline | ttyUSB0
[    7.166303] bst,maxim-deser-hub 2-002a: is_gmsl2_video_connected() index = 0, not linked
[    7.226936] bst,maxim-deser-hub 2-002a: is_gmsl2_video_connected() index = 1, not linked
[    7.287571] bst,maxim-deser-hub 2-002a: is_gmsl2_video_connected() index = 2, not linked
[    7.348212] bst,maxim-deser-hub 2-002a: is_gmsl2_video_connected() index = 3, not linked
[    7.456521] bst,maxim-deser-hub 2-002a: Failed to request irq 0
[    7.456526] bst,maxim-deser-hub 2-002a: maxim_hub_s_power(), line 1034, max96712 s_power success!
[    7.456540] Enter dphy_config
[    7.456555] dphyTst_setCfg_lanes
[    7.689752]
[    7.689752] DPHY_SHUTDOWNZ(40) = 0
[    7.689755]
[    7.689755] DPHY lane_speed = 2400
[    7.689808]
[    7.689808] reg e5 value is 0x1
[    7.689813]
[    7.689813] reg 1ac value is 0x4b
[    7.689819] nreg e4 value is 0x11
[    7.689825]
[    7.689825] reg 8 value is 0x18
[    7.689827]
[    7.689827] DPHY_N_LANES(4) = 1(ENABLE RX)
[    7.689829]
[    7.689829] force rxmode = 0x3c0030
[    7.689831] dphyTst_release
[    7.689832]
[    7.689832] DPHY_SHUTDOWNZ(40) = 1
[    7.689834]
[    7.689834] DPHY_RSTZ(44) = 1
[    7.755201] dphyTst_release timeout
[    7.755203]
[    7.755203] dphy0 enable done.
[    7.755204] dphyTst_release_1_4lane
[    7.755206]
[    7.755206] DPHY_1_RSTZ = 3c003c
[    7.803760] dphyTst_release_1_4lane timeout
[    7.803762]
[    7.803762] dphy0 and dphy1 enter stopstate.
[    7.803764]
[    7.803764] release force rxmode = 0x3c
[    7.803765] dphyTst_release_1_4lane finish
[    7.803777] bst,maxim-deser-hub 2-0029: maxim_hub_s_power() line:986
[    7.803782] bst,maxim-deser-hub 2-0029: maxim_hub_s_power() line:1007 GMSL2
[    7.853309] bst,maxim-deser-hub 2-0029: max967XX_replicate_mode() line:509
[    7.853506] bst,maxim-deser-hub 2-0029: max96712_fsync_config() line:436, trig_info-&gt;trigger_tx_gpio[0] = 8
[    7.854272] bst,maxim-deser-hub 2-0029: INTERNAL TRIGGER MODE
[    7.855036] bst,maxim-deser-hub 2-0029: trig_info.trigger_tx_gpio[0] = 8
[    7.855231] bst,maxim-deser-hub 2-0029: modify_serdes_address() 254
[    8.196057] bst,maxim-deser-hub 2-0029: is_gmsl2_video_connected() index = 0, not linked
[    8.196062] modify_serdes_address() cam_dev [1] is NULL, break
[    8.196064] modify_serdes_address() cam_dev [2] is NULL, break
[    8.196066] modify_serdes_address() cam_dev [3] is NULL, break
[    8.447360] bst,maxim-deser-hub 2-0029: is_gmsl2_video_connected() index = 0, not linked
[    8.507997] bst,maxim-deser-hub 2-0029: is_gmsl2_video_connected() index = 1, not linked
[    8.568632] bst,maxim-deser-hub 2-0029: is_gmsl2_video_connected() index = 2, not linked
[    8.629276] bst,maxim-deser-hub 2-0029: is_gmsl2_video_connected() index = 3, not linked
[    8.737584] bst,maxim-deser-hub 2-0029: Failed to request irq 0
[    8.737588] bst,maxim-deser-hub 2-0029: maxim_hub_s_power(), line 1034, max96712 s_power success!
[    8.737593] ox08b camera_s_power(), line 246
[    8.737600] cfg_num 0, alg_num 0
[    8.737607] a1000_isp isp: assigned reserved memory node coreip_pub_cma@0xb2000000
[    8.738184] vsp vsp@1: assigned reserved memory node coreip_pub_cma@0xb2000000
[    8.738345] [drm] plane:31 created
[    8.738352] [drm] plane:33 created
[    8.738718] [drm] Initialized bst-vsp 1.0.0 20200416 for vsp@1 on minor 0
[    8.738732] bst_drm_platform_probe exit!
[    8.738844] bst-gmwarp gmwarp@0: assigned reserved memory node coreip_pub_cma@0xb2000000
[    8.738932] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-0 as /dev/video30
[    8.739001] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-1 as /dev/video31
[    8.739059] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-2 as /dev/video32
[    8.739130] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-3 as /dev/video33
[    8.739189] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-4 as /dev/video34
[    8.739245] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-5 as /dev/video35
[    8.739316] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-6 as /dev/video36
[    8.739384] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-7 as /dev/video37
[    8.739448] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-8 as /dev/video38
[    8.739512] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-9 as /dev/video39
[    8.739568] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-10 as /dev/video40
[    8.739633] bst-gmwarp gmwarp@0: Registered bst_gmwarp_channel-11 as /dev/video41
[    8.739637] bst-gmwarp gmwarp@0: gmwarp probe ok!
[    8.754621] bst-encode encoder@0: assigned reserved memory node coreip_pub_cma@0xb2000000
[    8.754701] bst-encode encoder@0: Registerd bst_encoder-0 as /dev/video50
[    8.754761] bst-encode encoder@0: Registerd bst_encoder-1 as /dev/video51
[    8.754817] bst-encode encoder@0: Registerd bst_encoder-2 as /dev/video52
[    8.754882] bst-encode encoder@0: Registerd bst_encoder-3 as /dev/video53
[    8.754946] bst-encode encoder@0: Registerd bst_encoder-4 as /dev/video54
[    8.755003] bst-encode encoder@0: Registerd bst_encoder-5 as /dev/video55
[    8.755065] bst-encode encoder@0: Registerd bst_encoder-6 as /dev/video56
[    8.755141] bst-encode encoder@0: Registerd bst_encoder-7 as /dev/video57
[    8.755190] ALSA device list:
[    8.755195]   No soundcards found.
[    8.972528] EXT4-fs (mmcblk0p7): recovery complete
[    8.972949] EXT4-fs (mmcblk0p7): mounted filesystem with ordered data mode. Quota mode: none.
[    8.972988] VFS: Mounted root (ext4 filesystem) on device 179:7.
[    8.973612] devtmpfs: mounted
[    8.974012] Freeing unused kernel memory: 1856K
[    8.974282] Run /sbin/init as init process
[    9.158743] audit: type=1404 audit(9.129:2): enforcing=1 old_enforcing=0 auid=4294967295 ses=4294967295 enabled=1 old-enabled=1 lsm=selinux res=1
[    9.218475] SELinux:  Permission watch in class filesystem not defined in policy.
[    9.218507] SELinux:  Permission watch in class file not defined in policy.
[    9.218509] SELinux:  Permission watch_mount in class file not defined in policy.
[    9.218512] SELinux:  Permission watch_sb in class file not defined in policy.
[    9.218515] SELinux:  Permission watch_with_perm in class file not defined in policy.
[    9.218517] SELinux:  Permission watch_reads in class file not defined in policy.
[    9.218525] SELinux:  Permission watch in class dir not defined in policy.
[    9.218528] SELinux:  Permission watch_mount in class dir not defined in policy.
[    9.218530] SELinux:  Permission watch_sb in class dir not defined in policy.
[    9.218532] SELinux:  Permission watch_with_perm in class dir not defined in policy.
[    9.218534] SELinux:  Permission watch_reads in class dir not defined in policy.
[    9.218545] SELinux:  Permission watch in class lnk_file not defined in policy.
[    9.218548] SELinux:  Permission watch_mount in class lnk_file not defined in policy.
[    9.218550] SELinux:  Permission watch_sb in class lnk_file not defined in policy.
[    9.218553] SELinux:  Permission watch_with_perm in class lnk_file not defined in policy.
[    9.218555] SELinux:  Permission watch_reads in class lnk_file not defined in policy.
[    9.218562] SELinux:  Permission watch in class chr_file not defined in policy.
[    9.218564] SELinux:  Permission watch_mount in class chr_file not defined in policy.
[    9.218566] SELinux:  Permission watch_sb in class chr_file not defined in policy.
[    9.218569] SELinux:  Permission watch_with_perm in class chr_file not defined in policy.
[    9.218571] SELinux:  Permission watch_reads in class chr_file not defined in policy.
[    9.218578] SELinux:  Permission watch in class blk_file not defined in policy.
[    9.218580] SELinux:  Permission watch_mount in class blk_file not defined in policy.
[    9.218582] SELinux:  Permission watch_sb in class blk_file not defined in policy.
[    9.218584] SELinux:  Permission watch_with_perm in class blk_file not defined in policy.
[    9.218587] SELinux:  Permission watch_reads in class blk_file not defined in policy.
[    9.218593] SELinux:  Permission watch in class sock_file not defined in policy.
[    9.218595] SELinux:  Permission watch_mount in class sock_file not defined in policy.
[    9.218597] SELinux:  Permission watch_sb in class sock_file not defined in policy.
[    9.218600] SELinux:  Permission watch_with_perm in class sock_file not defined in policy.
[    9.218602] SELinux:  Permission watch_reads in class sock_file not defined in policy.
[    9.218608] SELinux:  Permission watch in class fifo_file not defined in policy.
[    9.218610] SELinux:  Permission watch_mount in class fifo_file not defined in policy.
[    9.218613] SELinux:  Permission watch_sb in class fifo_file not defined in policy.
[    9.218615] SELinux:  Permission watch_with_perm in class fifo_file not defined in policy.
[    9.218618] SELinux:  Permission watch_reads in class fifo_file not defined in policy.
[    9.218753] SELinux:  Permission perfmon in class capability2 not defined in policy.
[    9.218756] SELinux:  Permission bpf in class capability2 not defined in policy.
[    9.218758] SELinux:  Permission checkpoint_restore in class capability2 not defined in policy.
[    9.218775] SELinux:  Permission perfmon in class cap2_userns not defined in policy.
[    9.218778] SELinux:  Permission bpf in class cap2_userns not defined in policy.
[    9.218780] SELinux:  Permission checkpoint_restore in class cap2_userns not defined in policy.
[    9.218872] SELinux:  Class mctp_socket not defined in policy.
[    9.218874] SELinux:  Class perf_event not defined in policy.
[    9.218875] SELinux:  Class anon_inode not defined in policy.
[    9.218877] SELinux:  Class io_uring not defined in policy.
[    9.218879] SELinux:  Class user_namespace not defined in policy.
[    9.218881] SELinux: the above unknown classes and permissions will be allowed
[    9.241537] SELinux:  policy capability network_peer_controls=1
[    9.241551] SELinux:  policy capability open_perms=1
[    9.241553] SELinux:  policy capability extended_socket_class=1
[    9.241555] SELinux:  policy capability always_check_network=0
[    9.241558] SELinux:  policy capability cgroup_seclabel=1
[    9.241560] SELinux:  policy capability nnp_nosuid_transition=1
[    9.241562] SELinux:  policy capability genfs_seclabel_symlinks=0
[    9.241564] SELinux:  policy capability ioctl_skip_cloexec=0
[    9.337566] audit: type=1403 audit(9.309:3): auid=4294967295 ses=4294967295 lsm=selinux res=1
[    9.347876] systemd[1]: Successfully loaded SELinux policy in 189.944ms.
[    9.445456] systemd[1]: System time before build time, advancing clock.
[    9.642816] systemd[1]: Relabelled /dev, /dev/shm, /run, /sys/fs/cgroup in 48.506ms.
[    9.692606] systemd[1]: systemd 241-9-gc1f8ff8+ running in system mode. (+PAM +AUDIT +SELINUX -IMA -APPARMOR -SMACK +SYSVINIT -UTMP -LIBCRYPTSETUP -GCRYPT -GNUTLS -ACL -XZ -LZ4 -SECC)
[    9.692902] systemd[1]: Detected architecture arm64.
[    9.761188] systemd[1]: Set hostname to &lt;a1000&gt;.
[    9.765722] systemd[1]: Failed to bump fs.file-max, ignoring: Invalid argument
[    9.865774] systemd-fstab-generator[142]: Mount point  is not a valid path, ignoring.
[    9.881793] systemd-fstab-generator[142]: Mount point  is not a valid path, ignoring.
[    9.882075] systemd-fstab-generator[142]: Mount point  is not a valid path, ignoring.
[    9.945688] systemd[1]: File /lib/systemd/system/systemd-journald.service:12 configures an IP firewall (IPAddressDeny=any), but the local system does not support BPF/cgroup based fir.
[    9.945702] systemd[1]: Proceeding WITHOUT firewalling in effect! (This warning is only shown for the first loaded unit using IP firewalling.)
[    9.993988] systemd[1]: Configuration file /lib/systemd/system/user-startup.service is marked executable. Please remove executable permission bits. Proceeding anyway.
[   10.015829] systemd[1]: /lib/systemd/system/usb-gadget@.service:14: Unknown lvalue 'After' in section 'Service', ignoring
[   10.019272] systemd[1]: Configuration file /lib/systemd/system/safety-service.service is marked executable. Please remove executable permission bits. Proceeding anyway.
[   10.019582] systemd[1]: /lib/systemd/system/safety-service.service:8: Unknown lvalue 'StartLimitIntervalSec' in section 'Service', ignoring
[   12.379759] random: crng init done
[   12.475848] early application starting...
[   12.730278] audit: type=1130 audit(1675679554.279:4): pid=1 uid=0 auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 msg='unit=selinux-labeldev comm="systemd" exe="/lib/'
[   12.730364] audit: type=1131 audit(1675679554.279:5): pid=1 uid=0 auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 msg='unit=selinux-labeldev comm="systemd" exe="/lib/'
[   12.731973] audit: type=1130 audit(1675679554.279:6): pid=1 uid=0 auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 msg='unit=kmod-static-nodes comm="systemd" exe="/lib'
[   12.761921] audit: type=1130 audit(1675679554.309:7): pid=1 uid=0 auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 msg='unit=systemd-sysctl comm="systemd" exe="/lib/sy'
[   12.860995] EXT4-fs (mmcblk0p7): re-mounted. Quota mode: none.
[   12.865560] audit: type=1130 audit(1675679554.409:8): pid=1 uid=0 auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 msg='unit=systemd-remount-fs comm="systemd" exe="/li'
[   12.956353] audit: type=1130 audit(1675679554.499:9): pid=1 uid=0 auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 msg='unit=systemd-tmpfiles-setup-dev comm="systemd" '
[   13.098380] audit: type=1130 audit(1675679554.639:10): pid=1 uid=0 auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 msg='unit=systemd-journald comm="systemd" exe="/lib'
[   13.180022] systemd-journald[173]: Received request to flush runtime journal from PID 1
[   13.187569] systemd-journald[173]: File /var/log/journal/c9eb360cf45a4d3ca7df8dc9a4b9d632/system.journal corrupted or uncleanly shut down, renaming and replacing.
[   13.209076] audit: type=1130 audit(1675679554.749:11): pid=1 uid=0 auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 msg='unit=systemd-udevd comm="systemd" exe="/lib/sy'
[   13.904594] bst_noc_pmu_probe, 296
[   13.904685] bst_nocpmu 32702000.noc_pmu: assigned reserved memory node noc_pmu@0xe8000000
[   13.936242] bst-thermal 70039000.thermal: cooling_dev, name=pwm
[   14.912819] EXT4-fs (mmcblk0p9): recovery complete
[   14.912842] EXT4-fs (mmcblk0p9): mounted filesystem with ordered data mode. Quota mode: none.
[   14.916892] ext4 filesystem being mounted at /secdata supports timestamps until 2038 (0x7fffffff)
[   14.965123] EXT4-fs (mmcblk0p6): recovery complete
[   14.965622] EXT4-fs (mmcblk0p6): mounted filesystem with ordered data mode. Quota mode: none.
[   15.471416] EXT4-fs (mmcblk0p10): recovery complete
[   15.471609] EXT4-fs (mmcblk0p10): mounted filesystem with ordered data mode. Quota mode: none.
[   15.583524] kauditd_printk_skb: 2 callbacks suppressed
[   15.583538] audit: type=1130 audit(1675679557.129:14): pid=1 uid=0 auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 msg='unit=selinux-autorelabel comm="systemd" exe="/'
[   15.583841] audit: type=1131 audit(1675679557.129:15): pid=1 uid=0 auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 msg='unit=selinux-autorelabel comm="systemd" exe="/'
[   15.640743] audit: type=1130 audit(1675679557.189:16): pid=1 uid=0 auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 msg='unit=selinux-init comm="systemd" exe="/lib/sys'
[   15.641029] audit: type=1131 audit(1675679557.189:17): pid=1 uid=0 auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 msg='unit=selinux-init comm="systemd" exe="/lib/sys'
[   15.745845] audit: type=1130 audit(1675679557.289:18): pid=1 uid=0 auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 msg='unit=systemd-tmpfiles-setup comm="systemd" exe'
[   18.103131] audit: type=1130 audit(1675679559.649:19): pid=1 uid=0 auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 msg='unit=bstosuser comm="systemd" exe="/lib/system'
[   18.103678] audit: type=1131 audit(1675679559.649:20): pid=1 uid=0 auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 msg='unit=bstosuser comm="systemd" exe="/lib/system'
[   18.193782] audit: type=1130 audit(1675679559.739:21): pid=1 uid=0 auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 msg='unit=safety-service comm="systemd" exe="/lib/s'
[   18.197052] audit: type=1130 audit(1675679559.739:22): pid=1 uid=0 auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 msg='unit=user-startup comm="systemd" exe="/lib/sys'
[   18.237303] audit: type=1130 audit(1675679559.779:23): pid=1 uid=0 auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 msg='unit=busybox-syslog comm="systemd" exe="/lib/s'
[   18.831535] picp: picp init start...
[   18.831663] picp: pci not init..
[   18.893208] picp: picp init start...
[   18.893340] picp: pci not init..
[   18.934665] picp: picp init start...
[   18.934806] picp: pci not init..
[   20.667877] file system registered
[   20.741400] dwmac4: Master AXI performs fixed burst length
[   20.741447] bstgmaceth 30000000.ethernet eth0: Safety Features Fix to 0.Hw feature 3
[   20.741459] bstgmaceth 30000000.ethernet eth0: No Safety Features support found
[   20.741492] bstgmaceth 30000000.ethernet eth0: IEEE 1588-2008 Advanced Timestamp supported
[   20.746066] pps pps0: new PPS source ptp0
[   20.746880] bstgmaceth 30000000.ethernet eth0: registered PTP clock
[   20.746902] bstgmaceth 30000000.ethernet eth0: configuring for fixed/rgmii link mode
[   20.756958] bstgmaceth 30000000.ethernet eth0: Link is Up - 1Gbps/Full - flow control off
[   20.768570] bstgmaceth 30000000.ethernet eth0: Request Tx chan:0 irq:67.
[   20.768589] bstgmaceth 30000000.ethernet eth0: Request Tx chan:1 irq:68.
[   20.770788] bstgmaceth 30000000.ethernet eth0: Request Tx chan:2 irq:69.
[   20.770818] bstgmaceth 30000000.ethernet eth0: Request Tx chan:3 irq:70.
[   20.776672] bstgmaceth 30000000.ethernet eth0: Request Rx chan:0 irq:63.
[   20.782635] bstgmaceth 30000000.ethernet eth0: Request Rx chan:1 irq:64.
[   20.795483] bstgmaceth 30000000.ethernet eth0: Request Rx chan:2 irq:65.
[   20.801242] bstgmaceth 30000000.ethernet eth0: Request Rx chan:3 irq:66.
[   20.816356] 8021q: adding VLAN 0 to HW filter on device eth0
[   20.880677] kauditd_printk_skb: 19 callbacks suppressed
[   20.880692] audit: type=1130 audit(1675679562.429:43): pid=1 uid=0 auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 msg='unit=NetworkManager-dispatcher comm="systemd" '
[   20.913516] EXT4-fs (mmcblk0p5): recovery complete
[   20.913543] EXT4-fs (mmcblk0p5): mounted filesystem with ordered data mode. Quota mode: none.
[   21.166231] read descriptors
[   21.166250] read descriptors
[   21.166255] read strings
[   21.303268] bstgmac_ethtool_get_link_ksettings: eth0: PHY is not registered
[   21.498934] audit: type=1404 audit(1675679563.039:44): enforcing=0 old_enforcing=1 auid=4294967295 ses=4294967295 enabled=1 old-enabled=1 lsm=selinux res=1
[   21.504209] audit: type=1300 audit(1675679563.039:44): arch=c00000b7 syscall=64 success=yes exit=1 a0=3 a1=7fe032a6d8 a2=1 a3=7fbb55ea78 items=0 ppid=371 pid=633 auid=4294967295 uid=)
[   21.504921] audit: type=1327 audit(1675679563.039:44): proctitle=736574656E666F7263650030
[   21.520737] audit: type=1130 audit(1675679563.069:45): pid=1 uid=0 auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 msg='unit=rc-local comm="systemd" exe="/lib/systemd'
[   21.574655] audit: type=1130 audit(1675679563.119:46): pid=1 uid=0 auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 msg='unit=getty@tty1 comm="systemd" exe="/lib/syste'
[   21.636310] audit: type=1130 audit(1675679563.179:47): pid=1 uid=0 auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 msg='unit=serial-getty@ttyS0 comm="systemd" exe="/l'
[   22.202000] audit: type=1130 audit(1675679563.749:48): pid=1 uid=0 auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 msg='unit=usb-gadget@g1 comm="systemd" exe="/lib/sy'
[   22.310234] bash (697): /proc/173/oom_adj is deprecated, please use /proc/173/oom_score_adj instead.

BSTOS (Operation System by Black Sesame Technologies) 2.3.0.4 a1000 ttyS0

a1000 login: [   23.484629] audit: type=1130 audit(1675679565.029:49): pid=1 uid=0 auid=4294967295 ses=4294967295 subj=system_u:system_r:init_t:s0 msg='unit=udsservice_autostart comm="s'
[   23.637773] audit: type=1701 audit(1675679565.179:50): auid=4294967295 uid=0 gid=0 ses=4294967295 subj=system_u:system_r:initrc_t:s0 pid=701 comm="uds_service" exe="/usr/bin/uds_serv1
</code></pre>
</li>
</ol>
<h2 id="适配问题总结"><a class="header" href="#适配问题总结">适配问题总结</a></h2>
<ul>
<li>
<p>目前加载guest的方式尚不健全，需要改进</p>
</li>
<li>
<p>遇到的主要问题就是跑飞的问题，在qemu环境下实现时没有遇到，在上板子的时候则出现问题，在胡博的帮助下成功定位</p>
<p>由于在进入guest时没有无效化guest内核镜像加载区域的数据缓存，在进入guest进行一些数据读写相关的指令时访问的不是正确的数据内容，导致跑飞</p>
<p>通过在进入前对对应的区域进行缓存无效化后成功解决<style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () =&gt; window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () =&gt; { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY &lt;200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() =&gt; { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () =&gt; { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() =&gt; { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) =&gt; (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) =&gt; { btn.addEventListener("click", (event) =&gt; { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rk3588"><a class="header" href="#rk3588">RK3588</a></h1>
<p>目前，在黑芝麻 A1000 平台上已经对仅运行 Linux 的情况进行了验证。</p>
<h2 id="arceos-5"><a class="header" href="#arceos-5">ArceOS</a></h2>
<p>TODO</p>
<h2 id="linux-3"><a class="header" href="#linux-3">Linux</a></h2>
<ol>
<li>
<p>从内核源码编译一个合适的linux镜像文件和dtb文件</p>
</li>
<li>
<p>设置 <code>arceos-vmm/configs/vms/linux-rk3588-aarch64.toml</code>文件下的相关信息，此文件为guest相关配置</p>
<pre><code class="language-toml">id = 1                    //vm id
name = "linux"			  //vm 命名
vm_type = 1				  //vm类型
phy_cpu_sets = [0x1]      //设定每一个vcpu的亲和性
cpu_num = 1             //cpu 数量
entry_point = 0x1008_0000  //guest内核入口地址，约定内核从这个地址开始运行
kernel_load_addr = 0x1008_0000   //guest内核加载地址，约定将内核加载到这个地址
dtb_load_addr = 0x1000_0000      //guest dtb加载地址，约定将dtb加载到这个地址

# The location of image: "memory" | "fs"
# load from memory
image_location = "memory"       //内核加载方式，rk3588目前为从内存中加载guest镜像
kernel_path = "linux-rk3588-aarch64.bin" //guest 内核镜像所在的本地路径，推荐使用绝对地址
dtb_path = "linux-rk3588.dtb"			 //guest dtb文件所在的本地路径，推荐使用绝对地址

# ramdisk_path = ""
# ramdisk_load_addr = 0
# disk_path = "disk.img"
# Memory regions with format (`base_paddr`, `size`, `flags`, `map_type`).
# For `map_type`, 0 means `MAP_ALLOC`, 1 means `MAP_IDENTICAL`.
memory_regions = [
    [0x0, 0x10_f000, 0x37, 1],        # rk3588使用到的一段uncached内存，需要一一映射
    [0x940_0000, 0x76c00000, 0x7, 1], # 一一映射给guest的物理内存，根据实际的物理内存按需分配即可
]

# Emu_devices
# Name Base-Ipa Ipa_len Alloc-Irq Emu-Type EmuConfig
emu_devices = []

# Pass-through devices
# Name Base-Ipa Base-Pa Length Alloc-Irq
//此处的设备地址目前主要是根据设备树来的，需要给guest linux什么设备，就同时修改此处的配置和相关的dtb，使二者一致即可
passthrough_devices = [
    [
        "ramoops",
        0x11_0000,
        0x11_0000,					
        0xf_0000,
        0x1,
    ],
    [
        "sram",
        0x10_f000,
        0x10_f000,
        0x1000,
        0x1,
    ],
    [
        "gpu",
        0xfb00_0000,
        0xfb00_0000,
        0x200000,
        0x1,
    ],
    [
        "uart8250 UART",
        0xfd00_0000,
        0xfd00_0000,
        0x2000000,
        0x1,
    ],
    [
        "usb",
        0xfc00_0000,
        0xfc00_0000,
        0x1000000,
        0x1,
    ],
]
</code></pre>
</li>
<li>
<p>设置<code>arceos-vmm/configs/platforms/aarch64-rk3588j-hv.toml</code>文件下的相关信息，此文件为host相关配置</p>
<pre><code class="language-toml"># Architecture identifier.
arch = "aarch64" # str                //host 架构
# Platform identifier.
platform = "aarch64-rk3588j" # str     //host 平台

#
# Platform configs
#
[plat]
# Platform family.
family = "aarch64-rk3588j"

# Base address of the whole physical memory.
phys-memory-base = 0x20_0000 # uint         //host 物理内存起始地址
# Size of the whole physical memory.
phys-memory-size = 0x800_0000    # uint     //host自身管理使用的内存大小，由于目前对非连续物理内存的支持不够完善，此处物理内存的大小可以小于host使用的内存，在guest vm使用一一映射的内存可以不在此段内存中
# Base physical address of the kernel image.
kernel-base-paddr = 0x48_0000 # uint         //host内核起始物理地址
# Base virtual address of the kernel image.
kernel-base-vaddr = "0x0000_0000_0048_0000"   //host内核起始虚拟地址
# Linear mapping offset, for quick conversions between physical and virtual
# addresses.
phys-virt-offset = "0x0000_0000_0000_0000"
# Kernel address space base.
kernel-aspace-base = "0x0000_0000_0000_0000"
# Kernel address space size.
kernel-aspace-size = "0x0000_ffff_ffff_f000"

#
# Device specifications
#
[devices]
# MMIO regions with format (`base_paddr`, `size`).
//host物理设备的地址
mmio-regions = [
    [0xfeb50000, 0x1000], # uart8250 UART0
    [0xfe600000, 0x10000], # gic-v3 gicd
    [0xfe680000, 0x100000], # gic-v3 gicr
    [0xa41000000, 0x400000],
    [0xa40c00000, 0x400000],
    [0xf4000000,0x1000000],
    [0xf3000000,0x1000000],
] # [(uint, uint)]
# VirtIO MMIO regions with format (`base_paddr`, `size`).
virtio-mmio-regions = []  # [(uint, uint)]

# Base physical address of the PCIe ECAM space.
pci-ecam-base = 0xf4000000  # uint
# End PCI bus number (`bus-range` property in device tree).
pci-bus-end = 0xff # uint
# PCI device memory ranges (`ranges` property in device tree).
pci-ranges = [] # [(uint, uint)]
# UART Address
uart-paddr = 0xfeb5_0000 # uint
uart-irq = 0x14d # uint

# GICC Address
gicd-paddr = 0xfe600000 # uint
# GICR Address
gicc-paddr = 0xfe680000 # uint
gicr-paddr = 0xfe680000 # uint

# PSCI
psci-method = "smc" # str

# pl031@9010000 {
#     clock-names = "apb_pclk";
#     clocks = &lt;0x8000&gt;;
#     interrupts = &lt;0x00 0x02 0x04&gt;;
#     reg = &lt;0x00 0x9010000 0x00 0x1000&gt;;
#     compatible = "arm,pl031\0arm,primecell";
# };
# RTC (PL031) Address
rtc-paddr = 0x901_0000          # uint
</code></pre>
</li>
<li>
<p>使用<code>make A=(pwd) ARCH=aarch64 VM_CONFIGS=configs/vms/linux-rk3588-aarch64.toml PLAT_NAME=aarch64-rk3588j-hv FEATURES=page-alloc-64g,hv LOG=info kernel</code> 编译出一个可烧写的arceos-umhv内核镜像<code>boot.img</code>文件</p>
</li>
<li>
<p>使用rk3588官方提供的工具等方式将开发板原先的内核镜像文件替换为<code>step 4</code>编译出的文件</p>
</li>
<li>
<p>断电重启</p>
</li>
</ol>
<h1 id="arceos--linux-2"><a class="header" href="#arceos--linux-2">ArceOS + Linux</a></h1>
<p>TODO<style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () =&gt; window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () =&gt; { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY &lt;200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() =&gt; { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () =&gt; { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() =&gt; { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) =&gt; (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) =&gt; { btn.addEventListener("click", (event) =&gt; { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="roc-rk3568-pc"><a class="header" href="#roc-rk3568-pc">ROC-RK3568-PC</a></h1>
<p>对于在 ROC-RK3568-PC 开发板上的 AxVisor 中运行 ArceOS 及 Linux，我们需要将相关镜像直接部署到开发板上，关于如何在 ROC-RK3568-PC 开发板上进行部署，详见 https://github.com/arceos-hypervisor/axvisor/issues/70 中的描述。我们同时验证了单核和多核启动，以下示例以单核为例。</p>
<blockquote>
<p>注意，axvisor自身使用的配置信息为板载的 dtb 文件，故如果需要修改 axvisor 使用的配置，需要提前修改板载的 dtb 文件。</p>
</blockquote>
<h2 id="arceos-6"><a class="header" href="#arceos-6">ArceOS</a></h2>
<h3 id="准备-arceos-镜像-3"><a class="header" href="#准备-arceos-镜像-3">准备 ArceOS 镜像</a></h3>
<ol>
<li>
<p>获取 ArceOS 源码 <code>git clone git@github.com:arceos-hypervisor/arceos.git</code>。由于目前 ArceOS 还没有合并支持设备树的分支，因此我们需要执行 <code>git checkout 45-动态plat-make-脚本接口适配</code> 切换分支</p>
</li>
<li>
<p>执行 <code>make A=examples/helloworld PLATFORM=aarch64-dyn SMP=1 LOG=info</code> 构建出 ArceOS 镜像 <code>examples/helloworld/helloworld_aarch64-dyn.bin</code></p>
</li>
</ol>
<h3 id="准备-arceos-设备树"><a class="header" href="#准备-arceos-设备树">准备 ArceOS 设备树</a></h3>
<p>在 AxVisor 源码目录中执行 <code>dtc -I dts -O dtb -o configs/vms/arceos-aarch64-rk3568_smp1.dtb configs/vms/arceos-aarch64-rk3568_smp1.dts</code> 获取 ArceOS 需要的设备树文件 <code>arceos-aarch64-rk3568_smp1.dtb</code>。</p>
<h3 id="从文件系统加载运行-8"><a class="header" href="#从文件系统加载运行-8">从文件系统加载运行</a></h3>
<ol>
<li>
<p>修改 <code>configs/vms/arceos-aarch64-rk3568_smp1.toml</code> 配置文件。对于从文件系统加载 ArceOS 镜像，需要将 <code>kernel_path</code> 和 <code>dtb_path</code> 设置为 ArceOS 镜像和设备树在 rootfs 中的路径，并且修改 <code>image_location = "fs"</code> 指定从文件系统加载。</p>
</li>
<li>
<p>将 ArceOS 镜像 <code>helloworld_aarch64-dyn.bin</code> 以及设备树 <code>arceos-aarch64-rk3568_smp1.dtb</code> 放到 rootfs 中，具体步骤参见 https://github.com/arceos-hypervisor/axvisor/issues/70 中的描述！</p>
</li>
<li>
<p>准备 AxVisor 镜像文件。在 AxVisor 源码目录中执行 <code>make ACCEL=n ARCH=aarch64 PLATFORM=aarch64-dyn LOG=debug VM_CONFIGS=configs/vms/arceos-aarch64-rk3568_smp1.toml SMP=4 APP_FEATURES=fs FEATURES=ext4fs,driver-rk3568-emmc</code> 构建 AxVisor 镜像 <code>axvisor_aarch64-dyn.bin</code></p>
</li>
<li>
<p>将 <code>axvisor_aarch64-dyn.bin</code> 放到 boot.img 中，具体步骤参见 https://github.com/arceos-hypervisor/axvisor/issues/70 中的描述！</p>
</li>
<li>
<p>将修改后的 <code>boot.img</code> 和 <code>rootfs.img</code> 部署到 ROC-RK3568-PC 开发板即可，具体步骤参见 https://github.com/arceos-hypervisor/axvisor/issues/70 中的描述！</p>
</li>
</ol>
<h3 id="从内存加载运行-6"><a class="header" href="#从内存加载运行-6">从内存加载运行</a></h3>
<ol>
<li>
<p>修改 <code>configs/vms/arceos-aarch64-rk3568_smp1.toml</code> 配置文件。对于从内存系统加载 ArceOS 镜像，需要将 <code>kernel_path</code> 和 <code>dtb_path</code> 设置为 ArceOS 镜像和设备树的绝对路径，并且修改 <code>image_location = "memory"</code> 指定从内存加载。</p>
</li>
<li>
<p>准备 AxVisor 镜像文件。在 AxVisor 源码目录中执行 <code>make ACCEL=n ARCH=aarch64 LOG=info VM_CONFIGS=configs/vms/arceos-aarch64-rk3568_smp1.toml SMP=4 PLATFORM=aarch64-dyn</code> 构建 AxVisor 镜像 <code>axvisor_aarch64-dyn.bin</code></p>
</li>
<li>
<p>将 <code>axvisor_aarch64-dyn.bin</code> 放到 <code>boot.img</code> 中，具体步骤参见 https://github.com/arceos-hypervisor/axvisor/issues/70 中的描述！</p>
</li>
<li>
<p>将修改后的 <code>boot.img</code> 和 <code>rootfs.img</code> 部署到 ROC-RK3568-PC 开发板即可，具体步骤参见 https://github.com/arceos-hypervisor/axvisor/issues/70 中的描述！</p>
</li>
</ol>
<h2 id="linux-4"><a class="header" href="#linux-4">Linux</a></h2>
<h3 id="准备-linux-镜像-1"><a class="header" href="#准备-linux-镜像-1">准备 Linux 镜像</a></h3>
<p>直接用 ROC-RK3568-PC 的 SDK 按照 <code>firefly_rk3568_roc-rk3568-pc_ubuntu_defconfig</code> 这个配置文件构建出所有的镜像文件，内核镜像直接使用生成的 <code>kernel/arch/arm64/boot/Image</code></p>
<blockquote>
<p>单核与多核共用同一个内核镜像即可，因为 Linux 内核启动时，会根据设备树中的配置来决定启动多少个 CPU</p>
</blockquote>
<h3 id="准备-linux-设备树"><a class="header" href="#准备-linux-设备树">准备 Linux 设备树</a></h3>
<p>在 AxVisor 源码目录中执行 <code>dtc -I dts -O dtb -o configs/vms/linux-aarch64-rk3568_smp1.dtb configs/vms/linux-aarch64-rk3568_smp1.dts</code> 获取 Linux 需要的设备树文件。</p>
<h3 id="从文件系统加载运行-9"><a class="header" href="#从文件系统加载运行-9">从文件系统加载运行</a></h3>
<ol>
<li>
<p>修改 <code>configs/vms/linux-aarch64-rk3568_smp1.toml</code> 配置文件。对于从文件系统加载 Linux 镜像，需要将 <code>kernel_path</code> 和 <code>dtb_path</code> 设置为 Linux 镜像和设备树在 rootfs 中的路径，并且修改 <code>image_location = "fs"</code> 指定从文件系统加载。</p>
</li>
<li>
<p>将 Linux 镜像 <code>Image</code> 以及设备树 <code>linux-aarch64-rk3568_smp1.dtb</code> 放到 rootfs 中，具体步骤参见 https://github.com/arceos-hypervisor/axvisor/issues/70 中的描述！</p>
</li>
<li>
<p>准备 AxVisor 镜像文件。在 AxVisor 源码目录中执行 <code>make ACCEL=n ARCH=aarch64 PLATFORM=aarch64-dyn LOG=debug VM_CONFIGS=configs/vms/linux-aarch64-rk3568_smp1.toml SMP=4 APP_FEATURES=fs FEATURES=ext4fs,driver-rk3568-emmc</code> 构建 AxVisor 镜像 <code>axvisor_aarch64-dyn.bin</code></p>
</li>
<li>
<p>将 <code>axvisor_aarch64-dyn.bin</code> 放到 <code>boot.img</code> 中，具体步骤参见 https://github.com/arceos-hypervisor/axvisor/issues/70 中的描述！</p>
</li>
<li>
<p>将修改后的 <code>boot.img</code> 和 <code>rootfs.img</code> 部署到 ROC-RK3568-PC 开发板即可，具体步骤参见 https://github.com/arceos-hypervisor/axvisor/issues/70 中的描述！</p>
</li>
</ol>
<h3 id="从内存加载运行-7"><a class="header" href="#从内存加载运行-7">从内存加载运行</a></h3>
<ol>
<li>
<p>修改 <code>configs/vms/linux-aarch64-rk3568_smp1.toml</code> 配置文件。对于从内存系统加载 Linux 镜像，需要将 <code>kernel_path</code> 和 <code>dtb_path</code> 设置为 Linux 镜像和设备树的绝对路径，并且修改 <code>image_location = "memory"</code> 指定从内存加载。</p>
</li>
<li>
<p>准备 AxVisor 镜像文件。在 AxVisor 源码目录中执行 <code>make ACCEL=n ARCH=aarch64 PLATFORM=aarch64-dyn LOG=info VM_CONFIGS=configs/vms/linux-aarch64-rk3568_smp1.toml SMP=4 </code> 构建 AxVisor 镜像 <code>axvisor_aarch64-dyn.bin</code></p>
</li>
<li>
<p>将 <code>axvisor_aarch64-dyn.bin</code> 放到 <code>boot.img</code> 中，具体步骤参见 https://github.com/arceos-hypervisor/axvisor/issues/70 中的描述！</p>
</li>
<li>
<p>将修改后的 <code>boot.img</code> 和 <code>rootfs.img</code> 部署到 ROC-RK3568-PC 开发板即可，具体步骤参见 https://github.com/arceos-hypervisor/axvisor/issues/70 中的描述！</p>
</li>
</ol>
<h2 id="linux--arceos"><a class="header" href="#linux--arceos">Linux + ArceOS</a></h2>
<p>对于同时运行 Linux 和 ArceOS，由于开发板上默认只提供一个 UART2 作为控制台，因此，我们需要根据自己的需要更换 Linux 或 ArceOS 的控制台。主要有以下几种方案：</p>
<ol>
<li>
<p>在 U-Boot 中开启多路串口，然后 Linux 和 ArceOS 分别使用不同的串口</p>
</li>
<li>
<p>直接让 Linux 使用默认的 UART2，而 ArceOS 使用 UART3。由于 ArceOS 没有串口初始化功能，因此会阻塞在串口打印。直到 Linux 启动后，它默认会初始化串口3，但是默认是关闭的，需要在 Linux 客户机中 cat /dev/ttyS3 启动串口后，ArceOS 才能继续打印</p>
</li>
<li>
<p>让 Linux 使用 HDMI 的显示器作为控制台（需要修改内核配置，然后重新编译 Linux 镜像），而 ArceOS 继续使用 UART2 作为控制台。</p>
</li>
</ol>
<p>我们在验证时，采用了方案 2，具体步骤如下：</p>
<ol>
<li>修改 <code>configs/vms/arceos-aarch64-rk3568_smp1.toml</code> 配置文件。分配 UART3 给 ArceOS 使用，然后同步修改 <code>configs/vms/arceos-aarch64-rk3568_smp1.dts</code> 文件，将原来的 UART2 相关内容换成 UART3。</li>
</ol>
<h3 id="准备镜像文件"><a class="header" href="#准备镜像文件">准备镜像文件</a></h3>
<p>根据以上两个章节，分别准备 ArceOS 和 Linux 的镜像文件。</p>
<h3 id="从文件系统加载运行-10"><a class="header" href="#从文件系统加载运行-10">从文件系统加载运行</a></h3>
<ol>
<li>
<p>根据以上两个章节的介绍，分别修改好 <code>configs/vms/arceos-aarch64-rk3568_smp1.toml</code> 和 <code>configs/vms/linux-aarch64-rk3568_smp1.toml</code> 配置文件。这两个配置文件中的硬件资源默认就是分配好的，两个客户机可以同时运行。</p>
</li>
<li>
<p>将 ArceOS 镜像和设备树以及 Linux 镜像和设备树放到 rootfs 中，具体步骤参见 https://github.com/arceos-hypervisor/axvisor/issues/70 中的描述！</p>
</li>
<li>
<p>准备 AxVisor 镜像文件。在 AxVisor 源码目录中执行 <code>make ACCEL=n ARCH=aarch64 PLATFORM=aarch64-dyn LOG=info VM_CONFIGS=configs/vms/arceos-aarch64-rk3568_smp1.toml:configs/vms/linux-aarch64-rk3568_smp1.toml SMP=4 APP_FEATURES=fs FEATURES=ext4fs,driver-rk3568-emmc</code> 构建 AxVisor 镜像 <code>axvisor_aarch64-dyn.bin</code></p>
</li>
<li>
<p>将 <code>axvisor_aarch64-dyn.bin</code> 放到 <code>boot.img</code> 中，具体步骤参见 https://github.com/arceos-hypervisor/axvisor/issues/70 中的描述！</p>
</li>
<li>
<p>将修改后的 <code>boot.img</code> 和 <code>rootfs.img</code> 部署到 ROC-RK3568-PC 开发板即可，具体步骤参见 https://github.com/arceos-hypervisor/axvisor/issues/70 中的描述！</p>
</li>
</ol>
<h3 id="从内存加载运行-8"><a class="header" href="#从内存加载运行-8">从内存加载运行</a></h3>
<ol>
<li>
<p>根据以上两个章节的介绍，分别修改好 <code>configs/vms/arceos-aarch64-rk3568_smp1.toml</code> 和 <code>configs/vms/linux-aarch64-rk3568_smp1.toml</code> 配置文件。</p>
</li>
<li>
<p>准备 AxVisor 镜像文件。在 AxVisor 源码目录中执行 <code>make ACCEL=n ARCH=aarch64 PLATFORM=aarch64-dyn LOG=info VM_CONFIGS=configs/vms/arceos-aarch64-rk3568_smp1.toml:configs/vms/linux-aarch64-rk3568_smp1.toml SMP=4 APP_FEATURES=fs FEATURES=ext4fs,driver-rk3568-emmc</code> 构建 AxVisor 镜像 <code>axvisor_aarch64-dyn.bin</code></p>
</li>
<li>
<p>将 <code>axvisor_aarch64-dyn.bin</code> 放到 boot.img 中，具体步骤参见 https://github.com/arceos-hypervisor/axvisor/issues/70 中的描述！</p>
</li>
<li>
<p>将修改后的 <code>boot.img</code> 和 <code>rootfs.img</code> 部署到 ROC-RK3568-PC 开发板即可，具体步骤参见 https://github.com/arceos-hypervisor/axvisor/issues/70 中的描述！</p>
</li>
</ol>
<h2 id="问题参考"><a class="header" href="#问题参考">问题参考</a></h2>
<p>更详细的描述，参见移植及适配过程中对应的 ISSUE 中的记录：</p>
<ol>
<li>
<p>https://github.com/arceos-hypervisor/axvisor/issues/66</p>
</li>
<li>
<p>https://github.com/arceos-hypervisor/axvisor/issues/67</p>
</li>
<li>
<p>https://github.com/arceos-hypervisor/axvisor/issues/68</p>
</li>
</ol>
<style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () => window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () => { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY <200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() => { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () => { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() => { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) => (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) => { btn.addEventListener("click", (event) => { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="总体设计"><a class="header" href="#总体设计">总体设计</a></h1>
<h2 id="1-设计目标"><a class="header" href="#1-设计目标">1. 设计目标</a></h2>
<p>AxVisor 是基于 ArceOS unikernel 框架实现的 Hypervisor。其目标是利用 ArceOS 提供的基础操作系统功能作为基础，实现一个统一的模块化 Hypervisor。统一指使用同一套代码同时支持 x86_64、arm(aarch64) 和 RISC-V 三种架构，以最大化复用架构无关代码，简化代码开发和维护成本。模块化指 Hypervisor 的功能被分解为多个模块，每个模块实现一个特定的功能，模块之间通过标准接口进行通信，以实现功能的解耦和复用。</p>
<p>ArceOS 是一个基于 Rust 语言的 unikernel 框架，其设计目标是提供一个高性能、模块化、最小化的操作系统基座。通过在 ArceOS 的基础上添加不同的模块，就可以对应不同的应用场景生成不同的操作系统：在 ArceOS 上直接添加应用程序，就可以生成一个独立的应用程序 unikernel 镜像；在 ArceOS 上添加宏内核模块，就可以生成一个完整的宏内核操作系统；AxVisor 则在 ArceOS 的基础上添加虚拟化相关模块，从而以最小成本实现一个 Type-1 Hypervisor。</p>
<p><img src="architecture/../assets/arceos-backbone.png" alt="arceos-architecture" /></p>
<h2 id="2-软件架构"><a class="header" href="#2-软件架构">2. 软件架构</a></h2>
<p>AxVisor 的软件架构如下图所示，图中每一个框都是一个独立的模块，模块之间通过标准接口进行通信。包括作为基础的 ArceOS 在内，AxVisor 的软件架构分为五层：</p>
<p><img src="architecture/../assets/arceos-hypervisor-architecture.png" alt="arceos-hypervisor-architecture" /></p>
<p>AxVisor 整体架构</p>
<center class="half">
    <img src="architecture/../assets/arm mode.png" width="325"/><img src="architecture/../assets/x86 mode.png" width="325"/>
</center>
<h3 id="21-arceos"><a class="header" href="#21-arceos">2.1. ArceOS</a></h3>
<p>在 AxVisor 中，ArceOS 作为最底层的基础存在，提供内存管理、任务调度、设备驱动、同步原语等多种基础功能。ArceOS 的模块化设计允许 AxVisor 灵活选择需要的模块，这不仅缩减了编译的开销和二进制体积，也提高了系统的安全性和可靠性。</p>
<h3 id="22-arceos-vmm-应用程序app"><a class="header" href="#22-arceos-vmm-应用程序app">2.2. ArceOS-VMM 应用程序（App）</a></h3>
<p>ArceOS-VMM 应用程序是整个 AxVisor 的核心，它作为 ArceOS 上的一个 unikernel 应用程序运行。ArceOS-VMM 应用程序负责管理虚拟机的生命周期，进行创建、销毁、启动、停止等操作，维护虚拟机的配置、状态、资源等信息，同时也负责处理虚拟机之间的隔离与通信，以及虚拟机对硬件资源的申请和访问。</p>
<h3 id="23-axvm-模块"><a class="header" href="#23-axvm-模块">2.3. <code>axvm</code> 模块</a></h3>
<p><code>axvm</code> 模块位于 AxVisor 的中间层，它定义了虚拟机的数据结构和操作接口，具体实现了虚拟机的创建、销毁、启动、停止等功能。同时，<code>axvm</code> 模块还负责虚拟机内部虚拟 CPU 的创建、销毁、启动、停止等功能，并负责管理虚拟内存、虚拟设备等资源，实现虚拟环境内操作系统和应用程序对各种虚拟资源的访问。</p>
<h3 id="24-axvcpuaxaddrspace-和-axdevice-模块"><a class="header" href="#24-axvcpuaxaddrspace-和-axdevice-模块">2.4. <code>axvcpu</code>、<code>axaddrspace</code> 和 <code>axdevice</code> 模块</a></h3>
<p>在 <code>axvm</code> 模块的下层是 <code>axvcpu</code>、<code>axaddrspace</code> 和 <code>axdevice</code> 三个具体实现的模块，<code>axvcpu</code> 模块负责架构无关虚拟 CPU 的具体实现，<code>axaddrspace</code> 模块负责虚拟内存的具体实现，<code>axdevice</code> 模块负责虚拟设备的具体实现。这三个模块共同构成了虚拟机的基础设施，为虚拟机提供了 CPU、内存、设备等基本资源。</p>
<p><code>axvcpu</code> 模块定义了虚拟 CPU 的数据结构和统一操作接口。尽管各个架构下的虚拟化技术千差万别，但是通过统一的接口，架构之间的差异在 <code>axvcpu</code> 模块中得到了屏蔽，从而允许 <code>axvm</code> 及以上层的模块不受架构的限制，实现架构无关的虚拟机管理，提高了代码的复用性和可移植性。</p>
<p><code>axaddrspace</code> 模块定义了虚拟内存特别是嵌套页表的数据结构。通过复用 ArceOS 的页表等数据结构，实现了架构无关的虚拟内存管理。</p>
<p><code>axdevice</code> 模块定义了虚拟设备统一访问接口，提供了虚拟设备的基本抽象和封装，允许虚拟机通过统一的接口访问不同的虚拟设备，从而实现虚拟机对硬件资源的访问。</p>
<h3 id="25-具体实现模块"><a class="header" href="#25-具体实现模块">2.5. 具体实现模块</a></h3>
<p>基于 <code>axvcpu</code> 和 <code>axdevice</code> 模块，AxVisor 实现了不同架构下的具体虚拟 CPU 和虚拟设备模块，虚拟 CPU 包括 <code>x86_vcpu</code>、<code>arm_vcpu</code> 和 <code>riscv_vcpu</code>，虚拟设备包括 <code>x86_vlapic</code>、<code>arm_gic</code> 以及正在实现的 <code>virtio_blk</code>、<code>virtio_net</code> 等等。这些模块实现了具体的虚拟化功能，并且通过 <code>axvcpu</code> 和 <code>axdevice</code> 模块提供的统一接口与其它模块进行交互，这使得代码的复用性和可移植性得到了极大的提高。</p>
<!-- ### 2.6. axvisor_api？

是否需要把 `axvisor_api` 提出来。好处可以写潜在与 ArceOS 解耦，提高可移植性的可能性。另外可以随便说说。
-->
<h2 id="3-运行流程"><a class="header" href="#3-运行流程">3. 运行流程</a></h2>
<h3 id="31-虚拟-cpu-调度"><a class="header" href="#31-虚拟-cpu-调度">3.1. 虚拟 CPU 调度</a></h3>
<p>AxVisor 的执行流程的核心是虚拟 CPU 的调度。在 AxVisor 中，虚拟 CPU 是虚拟机的基本执行单元，每个虚拟机可以包含一个或多个虚拟 CPU。虚拟 CPU 的调度是通过复用 ArceOS 的任务调度机制实现的，每个虚拟 CPU 作为一个任务，由 ArceOS 的任务调度器进行调度：</p>
<p><img src="architecture/../assets/vcpu-scheduling-base.png" alt="vcpu scheduling" /></p>
<p>AxVisor 还支持混合的调度策略。对于不同的虚拟 CPU，可以采用不同的调度策略，例如，对于实时任务，可以将对应的虚拟 CPU 固定在一个物理 CPU 上，独占物理 CPU 的资源，以保证实时任务的响应时间；对于普通任务，则通过调度器进行动态调度，以实现资源的高效利用：</p>
<p><img src="architecture/../assets/vcpu-scheduling.png" alt="vcpu scheduling" /></p>
<p>未来计划实现：unikernel axtask、宏内核 process 以及 AxVisor vcpu 的统一调度</p>
<p><img src="architecture/../assets/axtask.png" alt="" /></p>
<p><img src="architecture/../assets/cpu.png" alt="" /></p>
<h3 id="33-二阶段地址翻译"><a class="header" href="#33-二阶段地址翻译">3.3. 二阶段地址翻译</a></h3>
<p><img src="architecture/../assets/pt.png" alt="" /></p>
<h3 id="33-vmexit-处理"><a class="header" href="#33-vmexit-处理">3.3. VMExit 处理</a></h3>
<p><img src="architecture/../assets/vmexit-handling.png" alt="vmexit handling" /></p>
<h3 id="34-虚拟设备实现"><a class="header" href="#34-虚拟设备实现">3.4 虚拟设备实现</a></h3>
<p><img src="architecture/../assets/driver-device.png" alt="" /></p>
<h4 id="341-virtio-device"><a class="header" href="#341-virtio-device">3.4.1 Virtio-device</a></h4>
<p><img src="architecture/../assets/io.png" alt="" /></p>
<p>AxVisor 实现 virtio-device 后端设备，具体的设备实现通过类似影子进程的设计转发给 Linux 实现</p>
<p><img src="architecture/../assets/virtio-backend.png" alt="virtio" /></p>
<h3 id="35-影子进程"><a class="header" href="#35-影子进程">3.5. 影子进程</a></h3>
<p>影子进程是一种通过将具体设备直通给虚拟机内的 Linux 等成品操作系统，让其他虚拟机通过虚拟机间通信和共享内存等方式与这个 Linux 进行通信，从而利用 Linux 中的现有驱动程序来实现虚拟设备的一种技术。影子进程技术可以大大减少虚拟机监控器的开发工作量，提高虚拟机监控器的可移植性和可扩展性。</p>
<style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () => window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () => { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY <200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() => { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () => { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() => { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) => (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) => { btn.addEventListener("click", (event) => { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="axvisor"><a class="header" href="#axvisor">AxVisor</a></h1>
<p><a href="architecture/(https://github.com/arceos-hypervisor/axvisor/)">AxVisor</a> 作为虚拟机监控器（VMM）运行，构建并作为 ArceOS 独立内核应用程序运行。</p>
<div align="center">
<img src="architecture/../assets/arceos-hv-dep.svg" width="125%">
</div>
<p>如上依赖关系图所示，它提供了一个全局视角的虚拟化资源管理，作为连接 ArceOS 核心功能组件与虚拟化相关组件的桥梁。</p>
<p>一方面，它直接依赖于 ArceOS 提供的 axstd 库，调用 ArceOS 的核心功能。一些直接的依赖包括：</p>
<ul>
<li>​<a href="https://arceos.org/arceos/axtask/index.html">axtask</a> based vCpu management and scheduling</li>
<li><a href="https://arceos.org/arceos/axhal/index.html">axhal</a> for platform-specific operations and interrupt handling</li>
<li><a href="https://arceos.org/arceos/axconfig/index.html">axconfig</a> for platform configuration</li>
</ul>
<p>另一方面，它依赖于 <a href="architecture/./axvm.html">axvm</a> 来实现虚拟机管理（配置与运行时），包括：</p>
<ul>
<li>​CRUD operations for guest VMs</li>
<li>​VM lifecycle control: setup, boot, notification and shutdown</li>
<li>Hypercall handling for communication between hypervisor and guest VMs</li>
</ul>
<h2 id="vm-管理"><a class="header" href="#vm-管理">VM 管理</a></h2>
<ul>
<li>hypercall handler</li>
<li>GLOBAL_VM_LIST</li>
</ul>
<h2 id="基于-axtask-的-vcpu-调度"><a class="header" href="#基于-axtask-的-vcpu-调度">基于 axtask 的 vCPU 调度</a></h2>
<p><a href="architecture/./vcpu/vcpu.html">axvcpu</a> 仅负责虚拟化功能支持，例如通过 vmlaunch/vmexit 进入/退出客户机。</p>
<p>由于 ArceOS 已经提供了 axtask 用于在单一特权级别下进行运行时控制流管理，我们可以重用其调度器并与之共同发展。</p>
<p>在虚拟机启动和设置过程中，axvisor 为每个 vCPU 分配 axtask，将任务的入口函数设置为 <code>vcpu_run()</code>，如果 vCPU 有专用的物理 CPU 集，它还会初始化 CPU 掩码。</p>
<h3 id="vcpu_run"><a class="header" href="#vcpu_run"><code>vcpu_run()</code></a></h3>
<p><code>vcpu_run()</code> 函数是 vCPU 任务的主要例程，可以总结如下：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn vcpu_run() {
    let curr = axtask::current();

    let vm = curr.task_ext().vm.clone();
    let vcpu = curr.task_ext().vcpu.clone();

    loop {
        match vm.run_vcpu(vcpu_id) {
            // match vcpu.run() {
            Ok(exit_reason) =&gt; match exit_reason {
                AxVCpuExitReason::Hypercall { nr, args } =&gt; {}
                }
                AxVCpuExitReason::ExternalInterrupt { vector } =&gt; {
                    // Irq injection logic
                }
                AxVCpuExitReason::Halt =&gt; {
                    wait(vm_id)
                }
                AxVCpuExitReason::Nothing =&gt; {}
                AxVCpuExitReason::CpuDown { _state } =&gt; {
                    // Sleep target axtask.
                }
                AxVCpuExitReason::CpuUp {
                    target_cpu,
                    entry_point,
                    arg,
                } =&gt; {
                    // Spawn axtask for target vCpu.
                    vcpu_on(vm.clone(), target_cpu as _, entry_point, arg as _);
                    vcpu.set_gpr(0, 0);
                }
                AxVCpuExitReason::SystemDown =&gt; {}
                _ =&gt; {
                    warn!("Unhandled VM-Exit");
                }
            },
            Err(err) =&gt; {}
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="task-扩展"><a class="header" href="#task-扩展">Task 扩展</a></h3>
<p>该机制允许调用者在不修改 axtask 结构体源代码的情况下自定义其扩展字段，（这是一种类似于线程局部存储（TLS）的轻量级机制）。</p>
<!-- Core design principles: -->
<p>axtask 结构体的基本字段:</p>
<ul>
<li>任务执行所需的基本信息，包括函数调用上下文、栈指针以及其他运行时元数据。</li>
</ul>
<p>使用场景</p>
<ul>
<li>宏内核的扩展
<ul>
<li>Process metadata (e.g., PID)</li>
<li>Memory management informations like page table</li>
<li>Resource management including fd table</li>
<li>...</li>
</ul>
</li>
<li>hypervisor 扩展
<ul>
<li>vCPU state</li>
<li>Metadata of the associated VM</li>
<li>...</li>
</ul>
</li>
</ul>
<h4 id="task-扩展设计"><a class="header" href="#task-扩展设计">Task 扩展设计</a></h4>
<ul>
<li>将 <code>task_ext_ptr</code> 引入作为扩展字段</li>
<li>利用基于指针的访问方式，实现与原生结构体字段相当的内存访问性能。</li>
<li>通过 <a href="https://arceos.org/arceos/axtask/macro.def_task_ext.html">def_task_ext</a> 在编译时确定扩展字段的大小。</li>
<li>在堆上分配内存，将扩展字段指针 <code>task_ext_ptr</code> 设置为该内存块。</li>
<li>暴露引用 API 供外部访问</li>
<li>由 <code>init_task_ext</code> 初始化</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// arceos/modules/axtask/src/task_ext.rs
#[unsafe(no_mangle)]
static __AX_TASK_EXT_SIZE: usize = ::core::mem::size_of::&lt;TaskExt&gt;();
#[unsafe(no_mangle)]
static __AX_TASK_EXT_ALIGN: usize = ::core::mem::align_of::&lt;TaskExt&gt;();

pub trait TaskExtRef&lt;T: Sized&gt; {
    /// Get a reference to the task extended data.
    fn task_ext(&amp;self) -&gt; &amp;T;
}

impl ::axtask::TaskExtRef&lt;TaskExt&gt; for ::axtask::TaskInner {
    fn task_ext(&amp;self) -&gt; &amp;TaskExt {
        unsafe {
            let ptr = self.task_ext_ptr() as *const TaskExt;
            if !!ptr.is_null() {
                ::core::panicking::panic("assertion failed: !ptr.is_null()")
            };
            &amp;*ptr
        }
    }
}

// arceos/modules/axtask/src/task.rs
impl TaskInner {
        /// Returns the pointer to the user-defined task extended data.
    ///
    /// # Safety
    ///
    /// The caller should not access the pointer directly, use [`TaskExtRef::task_ext`]
    /// or [`TaskExtMut::task_ext_mut`] instead.
    ///
    /// [`TaskExtRef::task_ext`]: crate::task_ext::TaskExtRef::task_ext
    /// [`TaskExtMut::task_ext_mut`]: crate::task_ext::TaskExtMut::task_ext_mut
    pub unsafe fn task_ext_ptr(&amp;self) -&gt; *mut u8 {
        self.task_ext.as_ptr()
    }

    /// Initialize the user-defined task extended data.
    ///
    /// Returns a reference to the task extended data if it has not been
    /// initialized yet (empty), otherwise returns [`None`].
    pub fn init_task_ext&lt;T: Sized&gt;(&amp;mut self, data: T) -&gt; Option&lt;&amp;T&gt; {
        if self.task_ext.is_empty() {
            self.task_ext.write(data).map(|data| &amp;*data)
        } else {
            None
        }
    }
}

<span class="boring">}</span></code></pre></pre>
<h4 id="taskext-in-axvisor"><a class="header" href="#taskext-in-axvisor"><code>TaskExt</code> in axvisor</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// axvisor/src/task.rs
use std::os::arceos::modules::axtask::def_task_ext;

use crate::vmm::{VCpuRef, VMRef};

/// Task extended data for the hypervisor.
pub struct TaskExt {
    /// The VM.
    pub vm: VMRef,
    /// The virtual memory address space.
    pub vcpu: VCpuRef,
}

impl TaskExt {
    pub const fn new(vm: VMRef, vcpu: VCpuRef) -&gt; Self {
        Self { vm, vcpu }
    }
}

def_task_ext!(TaskExt);

// axvisor/src/vmm/vcpus.rs
fn alloc_vcpu_task(vm: VMRef, vcpu: VCpuRef) -&gt; AxTaskRef {
    let mut vcpu_task = TaskInner::new(
        vcpu_run,
        format!("VM[{}]-VCpu[{}]", vm.id(), vcpu.id()),
        KERNEL_STACK_SIZE,
    );
    // ...
    vcpu_task.init_task_ext(TaskExt::new(vm, vcpu));
    axtask::spawn_task(vcpu_task)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="irq--timer"><a class="header" href="#irq--timer">irq &amp; timer</a></h2>
<h3 id="external-interrupt"><a class="header" href="#external-interrupt">External Interrupt</a></h3>
<p>所有来自外部设备的中断都通过多层次的 VM-Exit 处理例程返回给 axvisor 进行处理。因为 只有 axvisor 拥有全局资源管理视角。</p>
<p>axvisor 根据中断号和虚拟机配置文件识别外部中断：</p>
<ul>
<li>
<p>如果中断是预留给 axvisor 的（例如 axvisor 自己的时钟中断），则由 axhal 提供的 ArceOS 中断处理例程来处理。</p>
</li>
<li>
<p>如果中断属于某个客户虚拟机（例如客户虚拟机的直通磁盘中断），则该中断会直接注入到对应的虚拟机。</p>
<ul>
<li>请注意，一些架构的中断控制器可以配置为在不经过 VM-Exit 的情况下直接将外部中断注入到虚拟机中（例如 x86 提供的已发布中断）</li>
</ul>
</li>
</ul>
<h3 id="timer"><a class="header" href="#timer">Timer</a></h3>
<p>草拟设计请参考 <a href="https://github.com/orgs/arceos-hypervisor/discussions/36#discussioncomment-11002988">discussion#36</a>。</p>
<style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () => window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () => { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY <200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() => { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () => { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() => { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) => (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) => { btn.addEventListener("click", (event) => { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="axvisor-api设计的思考与妥协"><a class="header" href="#axvisor-api设计的思考与妥协">Axvisor API：设计的思考与妥协</a></h1>
<h2 id="1-为什么需要-axvisor-api"><a class="header" href="#1-为什么需要-axvisor-api">1. 为什么需要 Axvisor API？</a></h2>
<p>在 Axvisor 的整体架构中，ArceOS 处于最底层，负责提供内存管理、任务调度、设备驱动、同步原语等多种基础功能；这些功能会被 Axvisor 的各个组件所使用。然而，从软件工程的角度上，我们不能让 Axvisor 的各个组件直接依赖于 ArceOS （的 <code>axstd</code> 等接口组件）；这一方面是因为我们希望 ArceOS 与 Axvisor 之间的耦合度尽可能的低，这样可以提高系统的可移植性、可扩展性和可维护性，另一方面则是因为，将对 ArceOS 的依赖分散在各个组件中，会使得依赖和 feature 管理变得极度混乱，容易出现各种错误。</p>
<p>因此，我们需要一个统一的接口，收拢对 ArceOS 的依赖，同时提供给 Axvisor 的各个组件使用。在这里也存在着两个选择，第一是这个接口层放置在所有组件的下层，ArceOS 则被接口层直接依赖，位于最底层；第二是这个接口层同样放置在所有组件的下层，但是 ArceOS 与接口层之间并不直接依赖，接口层只提供接口的定义，实现则由最上层的 app 层来完成。显然，第二种方案在耦合度和可移植性上更有优势，因此我们选择了第二种方案。</p>
<h2 id="2-axvisor-api-应该如何实现"><a class="header" href="#2-axvisor-api-应该如何实现">2. Axvisor API 应该如何实现</a></h2>
<p>如何实现这样的定义与实现分离的接口呢？我们有很多可行的方案。</p>
<p>第一种，也是目前所广泛使用的方案，是在下层定义一个 trait，上层实现这个 trait，在需要使用这个 trait 的地方，通过泛型参数来传递这个 trait。例如：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 下层定义
trait MemoryHal {
    fn alloc() -&gt; u64;
    fn dealloc(addr: u64);
    fn phys_to_virt(phys: u64) -&gt; u64;
    fn virt_to_phys(virt: u64) -&gt; u64;
}

// 中层使用
struct AxVCpu&lt;M: MemoryHal&gt; {
    // ...
}

impl&lt;M: MemoryHal&gt; AxVCpu&lt;M&gt; {
    fn some_func(&amp;self) {
        let addr = M::alloc();
        // ...
        M::dealloc(addr);
    }
}

// 上层实现
struct MemoryHalImpl;

impl MemoryHal for MemoryHalImpl {
    fn alloc() -&gt; u64 {
        // ...
    }

    fn dealloc(addr: u64) {
        // ...
    }

    fn phys_to_virt(phys: u64) -&gt; u64 {
        // ...
    }

    fn virt_to_phys(virt: u64) -&gt; u64 {
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这种方案的优点是简单易懂，并且编译器有着非常充分的信息，可以进行很好的优化；实现时也可以很清楚的知道哪些接口是必须实现的。然而，这种方案也有着明显的缺点，那就是，具体的实现必须通过泛型参数一层一层地传递下去，一旦某一个较为下层的组件需要使用一个接口，那么这个接口就必须在所有的中间层都写一遍，这会使得代码的可读性和可维护性变得较差。</p>
<p>另一种方案则是贾越凯学长所实现的 <code>crate_interface</code> 方案。这个方案在链接时通过符号将接口的定义和实现连接起来，通过特殊定义的数个宏，消除了对泛型参数的依赖。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 下层定义
#[def_interface]
trait MemoryHal {
    fn alloc() -&gt; u64;
    fn dealloc(addr: u64);
    fn phys_to_virt(phys: u64) -&gt; u64;
    fn virt_to_phys(virt: u64) -&gt; u64;
}

// 中层使用
struct AxVCpu {
    // ...
}

impl AxVCpu {
    fn some_func(&amp;self) {
        let addr = call_interface!(MemoryHal::alloc);
        // ...
        call_interface!(MemoryHal::dealloc, addr);
    }
}

// 上层实现
struct MemoryHalImpl;

#[impl_interface]
impl MemoryHal for MemoryHalImpl {
    fn alloc() -&gt; u64 {
        // ...
    }

    fn dealloc(addr: u64) {
        // ...
    }

    fn phys_to_virt(phys: u64) -&gt; u64 {
        // ...
    }

    fn virt_to_phys(virt: u64) -&gt; u64 {
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>相比于通过泛型参数进行依赖注入的方案，<code>crate_interface</code> 方案的优点在于无需写出泛型参数，代码更加简洁；同时保留了 trait 的定义，能够明确地知道哪些接口是必须实现的。这个方案的缺点在于，调用接口时需要通过宏，这会使得代码的可读性变差；同时，由于接口的实现是通过符号链接的，因此在编译时会有一些限制，例如无法在一个 crate 中同时实现两个相同的接口，不过考虑到我们的需求（调用 ArceOS 的系统功能），这个限制并不会对我们造成太大的困扰。</p>
<h2 id="3-axvisor-api-的设计与妥协"><a class="header" href="#3-axvisor-api-的设计与妥协">3. Axvisor API 的设计与妥协</a></h2>
<p>目前 <code>axvisor_api</code> crate 中使用了一种改良的定义接口的方式，即使用 <code>mod</code> 组织 API，使用标注在 <code>mod</code> 上的 <code>#[api_mod]</code> 和 <code>#[api_mod_impl]</code> 宏来定义和实现接口。示例如下：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 下层定义
#[api_mod]
mod memory {
    type PhysAddr = u64;
    type VirtAddr = u64;

    extern fn alloc() -&gt; VirtAddr;
    extern fn dealloc(addr: VirtAddr);
    extern fn phys_to_virt(phys: PhysAddr) -&gt; VirtAddr;
    extern fn virt_to_phys(virt: VirtAddr) -&gt; PhysAddr;

    fn alloc_2_pages() -&gt; (VirtAddr, VirtAddr) {
        let addr = alloc();
        let addr2 = alloc();
        (addr, addr2)
    }
}

// 中层使用
struct AxVCpu {
    // ...
}

impl AxVCpu {
    fn some_func(&amp;self) {
        let addr = memory::alloc();
        // ...
        memory::dealloc(addr);
    }
}

// 上层实现
#[api_mod_impl(path::to::memory)]
mod memory_impl {
    extern fn alloc() -&gt; memory::VirtAddr {
        // ...
    }

    extern fn dealloc(addr: memory::VirtAddr) {
        // ...
    }

    extern fn phys_to_virt(phys: memory::PhysAddr) -&gt; memory::VirtAddr {
        // ...
    }

    extern fn virt_to_phys(virt: memory::VirtAddr) -&gt; memory::PhysAddr {
        // ...
    }
}
<span class="boring">}</span></code></pre></pre>
<p>这种实现方式的优点在于：</p>
<ol>
<li>组织更加接近于普通的 Rust 模块组织，易于理解；调用接口也使用普通的函数调用语法，对调用者心智负担较小；</li>
<li>接口模块中可以定义一些辅助和工具内容，方便实用，例如 API 相关的类型别名，基于 API 的简单封装等；</li>
</ol>
<p>但是这种实现方式也有一些缺点：</p>
<ol>
<li>不容易一次性看出有哪些接口是必须实现的；</li>
</ol>
<p>实际上，这两个宏背后使用了 <code>crate_interface</code> crate 作为底层实现；虽然技术上可以绕过 <code>crate_interface</code>，只使用 <code>link_name</code> 来实现接口，但这样就会完全失去使用 trait 来约束必须实现的接口的优势。而现在虽然使用了 trait，但是视觉上仍然不容易看出哪些接口是必须实现的；针对这一点，<code>api_mod</code> 宏现在会自动在文档中生成一个列表，列出所有的接口，方便查看。</p>
<ol start="2">
<li>在 <code>#[api_mod]</code> 标注的 <code>mod</code> 中，允许所有能够出现在普通 <code>mod</code> 中的内容，包括 <code>struct</code>、<code>enum</code>、<code>const</code> 等，这样可能会使得接口模块变得过于臃肿，不易维护；</li>
</ol>
<p>这一点可以通过约定来解决，例如只在接口模块中定义接口相关的内容，其他内容放在其他模块中。</p>
<p>目前，经过与贾越凯、胡柯洋等同学的讨论，我们认为可以先在使用现有泛型参数传递方式极为不便的情况下，使用 <code>axvisor_api</code> crate 来实现 API，以评估其实际表现和可用性；如果在实际使用中发现了问题，再考虑是否需要进一步改进。</p>
<style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () => window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () => { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY <200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() => { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () => { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() => { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) => (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) => { btn.addEventListener("click", (event) => { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="axvm-resource-management-within-each-vm"><a class="header" href="#axvm-resource-management-within-each-vm"><a href="https://github.com/arceos-hypervisor/axvm">AxVM</a>: resource management within each VM</a></h1>
<p>WIP 🚧</p>
<ul>
<li>address space of guest VM</li>
<li>axvcpu list</li>
<li>axdevice list</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A Virtual Machine.
pub struct AxVM&lt;H: AxVMHal, U: AxVCpuHal&gt; {
    running: AtomicBool,
    inner_const: AxVMInnerConst&lt;U&gt;,
    inner_mut: AxVMInnerMut&lt;H&gt;,
}

struct AxVMInnerConst&lt;U: AxVCpuHal&gt; {
    id: usize,
    config: AxVMConfig,
    vcpu_list: Box&lt;[AxVCpuRef&lt;U&gt;]&gt;,
    devices: AxVmDevices,
}

struct AxVMInnerMut&lt;H: AxVMHal&gt; {
    // Todo: use more efficient lock.
    address_space: Mutex&lt;AddrSpace&lt;H::PagingHandler&gt;&gt;,
    _marker: core::marker::PhantomData&lt;H&gt;,
}
<span class="boring">}</span></code></pre></pre>
<style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () => window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () => { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY <200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() => { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () => { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() => { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) => (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) => { btn.addEventListener("click", (event) => { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="axvcpu-virtual-cpu-interface-and-wrapper-for-arceos"><a class="header" href="#axvcpu-virtual-cpu-interface-and-wrapper-for-arceos">AxVCpu: Virtual CPU interface and wrapper for ArceOS.</a></h1>
<ul>
<li><a href="https://github.com/arceos-hypervisor/axvcpu">axvcpu</a> 提供 CPU 虚拟化支持
<ul>
<li>高度依赖于架构</li>
<li>存储不同架构的异常上下文框架</li>
<li>基本调度项</li>
<li>特定架构的 vCPU 实现需要被分离到独立的 crate 中:
<ul>
<li><a href="https://github.com/arceos-hypervisor/arm_vcpu">arm_vcpu</a></li>
<li><a href="https://github.com/arceos-hypervisor/x86_vcpu">x86_vcpu</a></li>
<li><a href="https://github.com/arceos-hypervisor/riscv_vcpu">riscv_vcpu</a></li>
<li>...</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// A trait for architecture-specific vcpu.
///
/// This trait is an abstraction for virtual CPUs of different architectures.
pub trait AxArchVCpu: Sized {
    /// The configuration for creating a new [`AxArchVCpu`]. Used by [`AxArchVCpu::new`].
    type CreateConfig;
    /// The configuration for setting up a created [`AxArchVCpu`]. Used by [`AxArchVCpu::setup`].
    type SetupConfig;

    /// Create a new `AxArchVCpu`.
    fn new(config: Self::CreateConfig) -&gt; AxResult&lt;Self&gt;;

    /// Set the entry point of the vcpu.
    ///
    /// It's guaranteed that this function is called only once, before [`AxArchVCpu::setup`] being called.
    fn set_entry(&amp;mut self, entry: GuestPhysAddr) -&gt; AxResult;

    /// Set the EPT root of the vcpu.
    ///
    /// It's guaranteed that this function is called only once, before [`AxArchVCpu::setup`] being called.
    fn set_ept_root(&amp;mut self, ept_root: HostPhysAddr) -&gt; AxResult;

    /// Setup the vcpu.
    ///
    /// It's guaranteed that this function is called only once, after [`AxArchVCpu::set_entry`] and [`AxArchVCpu::set_ept_root`] being called.
    fn setup(&amp;mut self, config: Self::SetupConfig) -&gt; AxResult;

    /// Run the vcpu until a vm-exit occurs.
    fn run(&amp;mut self) -&gt; AxResult&lt;AxVCpuExitReason&gt;;

    /// Bind the vcpu to the current physical CPU.
    fn bind(&amp;mut self) -&gt; AxResult;

    /// Unbind the vcpu from the current physical CPU.
    fn unbind(&amp;mut self) -&gt; AxResult;

    /// Set the value of a general-purpose register according to the given index.
    fn set_gpr(&amp;mut self, reg: usize, val: usize);
}
```&lt;style&gt;.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }&lt;/style&gt;&lt;button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"&gt; &lt;i class="fa fa-angle-up"&gt;&lt;/i&gt;&lt;/button&gt;&lt;script&gt;const scrollToTop = () =&gt; window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () =&gt; { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY &lt;200); });&lt;/script&gt;&lt;style&gt;.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }&lt;/style&gt;&lt;div style="display: none" data-id="0.2.11" class="announcement-banner"&gt; &lt;p&gt;&lt;em&gt;正在逐步完善中。。。&lt;/em&gt;&lt;/p&gt; &lt;button type="button" data-close&gt;X&lt;/button&gt;&lt;/div&gt;&lt;script&gt;(() =&gt; { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () =&gt; { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();&lt;/script&gt;&lt;style&gt;.giscus { margin-top: 6rem; }&lt;/style&gt;&lt;script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async&gt;&lt;/script&gt;&lt;script&gt;(() =&gt; { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) =&gt; (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) =&gt; { btn.addEventListener("click", (event) =&gt; { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();&lt;/script&gt;&lt;style&gt;footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }&lt;/style&gt;&lt;footer&gt;&lt;p&gt;Copyright © 2025 • Created by ArceOS Team&lt;/p&gt;&lt;/footer&gt;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="https://github.com/arceos-hypervisor/x86_vcpu">x86_64</a></li>
</ul>
<h1 id="x86_vcpu"><a class="header" href="#x86_vcpu">x86_vcpu</a></h1>
<h2 id="介绍"><a class="header" href="#介绍">介绍</a></h2>
<p>定义 x86_64 架构的 vCPU 结构和虚拟化相关接口支持。</p>
<p>crate 用户必须使用 <a href="https://crates.io/crates/crate_interface"><code>crate_interface::impl_interface</code></a> 实现 <code>PhysFrameIf</code> trait，以提供 <code>PhysFrame</code> 分配和释放的低级实现，相关实现可参考 <a href="https://github.com/arceos-org/arceos/blob/main/modules/axhal/src/paging.rs">ArceOS</a>。</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><code>use x86_vcpu::PhysFrameIf;

struct PhysFrameIfImpl;

#[crate_interface::impl_interface]
impl axvm::PhysFrameIf for PhysFrameIfImpl {
    fn alloc_frame() -&gt; Option&lt;PhysAddr&gt; {
        // Your implementation here
    }
    fn dealloc_frame(paddr: PhysAddr) {
        // Your implementation here
    }
    fn phys_to_virt(paddr: PhysAddr) -&gt; VirtAddr {
        // Your implementation here
    }
}
</code></pre>
<h2 id="系统架构"><a class="header" href="#系统架构">系统架构</a></h2>
<h3 id="模块组织"><a class="header" href="#模块组织">模块组织</a></h3>
<pre><code>x86_vcpu/
    ├── src/
    │   ├── msr.rs          - 模型特定寄存器操作
    │   ├── regs.rs         - 通用寄存器管理
    │   ├── ept.rs          - 扩展页表支持
    │   ├── frame.rs        - 物理内存帧管理
    │   ├── vmx/            - Intel VT-x 相关实现
    │   │   ├── definitions.rs  - 常量和类型定义
    │   │   ├── instructions.rs - VMX 指令封装
    │   │   ├── percpu.rs       - 每 CPU 状态管理
    │   │   ├── structs.rs      - VMX 数据结构
    │   │   ├── vcpu.rs         - 虚拟 CPU 实现
    │   │   ├── vmcs.rs         - VMCS 字段操作
    │   │   └── mod.rs          - 模块入口
    │   └── lib.rs          - 库入口点
</code></pre>
<h3 id="核心组件"><a class="header" href="#核心组件">核心组件</a></h3>
<ul>
<li><code>VmxVcpu</code>: 虚拟 CPU 实现，管理客户机状态和执行</li>
<li><code>VmxPerCpuState</code>: 每物理 CPU 的 VMX 状态</li>
<li><code>VMCS</code> 管理: 虚拟机控制结构字段的读写操作</li>
<li><code>EPT</code> 控制: 扩展页表配置和违规处理</li>
<li>物理内存管理: 通过 PhysFrame 抽象管理物理内存</li>
</ul>
<h2 id="关键数据结构"><a class="header" href="#关键数据结构">关键数据结构</a></h2>
<h3 id="generalregisters"><a class="header" href="#generalregisters"><code>GeneralRegisters</code></a></h3>
<p>用于存储和操作 X86_64 通用寄存器状态：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
pub struct GeneralRegisters {
    pub rax: u64,
    pub rcx: u64,
    // ... 其他寄存器
}
<span class="boring">}</span></code></pre></pre>
<p>提供按索引访问和修改寄存器值的方法：</p>
<ul>
<li><code>get_reg_of_index(index: u8) -&gt; u64</code></li>
<li><code>set_reg_of_index(index: u8, value: u64)</code></li>
</ul>
<h3 id="vmxvcpu"><a class="header" href="#vmxvcpu"><code>VmxVcpu</code></a></h3>
<p>虚拟 CPU 的核心实现：</p>
<pre><code>pub struct VmxVcpu&lt;H: AxVCpuHal&gt; {
    guest_regs: GeneralRegisters,
    host_stack_top: u64,
    launched: bool,
    vmcs: VmxRegion&lt;H&gt;,
    io_bitmap: IOBitmap&lt;H&gt;,
    msr_bitmap: MsrBitmap&lt;H&gt;,
    // ... 其他字段
}
</code></pre>
<h3 id="guestpagewalkinfo"><a class="header" href="#guestpagewalkinfo"><code>GuestPageWalkInfo</code></a></h3>
<p>存储客户机页表遍历所需的信息：</p>
<pre><code>pub struct GuestPageWalkInfo {
    pub top_entry: usize,
    pub level: usize,
    pub width: u32,
    // ... 权限和控制位
}
</code></pre>
<h3 id="physframe"><a class="header" href="#physframe"><code>PhysFrame</code></a></h3>
<p>物理内存页面的安全抽象：</p>
<pre><code>pub struct PhysFrame&lt;H: AxVCpuHal&gt; {
    start_paddr: Option&lt;HostPhysAddr&gt;,
    _marker: PhantomData&lt;H&gt;,
}
</code></pre>
<h2 id="核心功能实现"><a class="header" href="#核心功能实现">核心功能实现</a></h2>
<h3 id="vcpu-生命周期管理"><a class="header" href="#vcpu-生命周期管理">VCPU 生命周期管理</a></h3>
<pre><code>// 创建新的虚拟 CPU
pub fn new() -&gt; AxResult&lt;Self&gt; { ... }

// 配置虚拟 CPU
pub fn setup(&amp;mut self, ept_root: HostPhysAddr, entry: GuestPhysAddr) -&gt; AxResult { ... }

// 绑定到当前物理 CPU
pub fn bind_to_current_processor(&amp;self) -&gt; AxResult { ... }

// 执行客户机代码
pub fn inner_run(&amp;mut self) -&gt; Option&lt;VmxExitInfo&gt; { ... }
</code></pre>
<h3 id="vmcs-设置"><a class="header" href="#vmcs-设置">VMCS 设置</a></h3>
<pre><code>fn setup_vmcs_guest(&amp;mut self, entry: GuestPhysAddr) -&gt; AxResult { ... }

fn setup_vmcs_host(&amp;self) -&gt; AxResult { ... }

fn setup_vmcs_control(&amp;mut self, ept_root: HostPhysAddr, is_guest: bool) -&gt; AxResult { ... }
</code></pre>
<h3 id="vm-进入退出处理"><a class="header" href="#vm-进入退出处理">VM 进入/退出处理</a></h3>
<pre><code>#[naked]
unsafe extern "C" fn vmx_launch(&amp;mut self) -&gt; usize { ... }

#[naked]
unsafe extern "C" fn vmx_resume(&amp;mut self) -&gt; usize { ... }

fn builtin_vmexit_handler(&amp;mut self, exit_info: &amp;VmxExitInfo) -&gt; Option&lt;AxResult&gt; { ... }
</code></pre>
<h3 id="事件注入"><a class="header" href="#事件注入">事件注入</a></h3>
<pre><code>/// Add a virtual interrupt or exception to the pending events list,
/// and try to inject it before later VM entries.
pub fn queue_event(&amp;mut self, vector: u8, err_code: Option&lt;u32&gt;) { ... }

/// Try to inject a pending event before next VM entry.
fn inject_pending_events(&amp;mut self) -&gt; AxResult { ... }
</code></pre>
<h3 id="io-和-msr-拦截"><a class="header" href="#io-和-msr-拦截">I/O 和 MSR 拦截</a></h3>
<pre><code>/// Set I/O intercept by modifying I/O bitmap.
pub fn set_io_intercept_of_range(&amp;mut self, port_base: u32, count: u32, intercept: bool) { ... }

/// Set msr intercept by modifying msr bitmap.
pub fn set_msr_intercept_of_range(&amp;mut self, msr: u32, intercept: bool) { ... }
</code></pre>
<h2 id="关键技术"><a class="header" href="#关键技术">关键技术</a></h2>
<h3 id="vmx-操作模式"><a class="header" href="#vmx-操作模式">VMX 操作模式</a></h3>
<p>实现了完整的 VMX 操作模式切换：</p>
<ul>
<li>通过 <code>VMXON</code> 指令进入 VMX 操作模式</li>
<li>通过 <code>VMLAUNCH</code> 和 <code>VMRESUME</code> 指令执行客户机代码</li>
<li>通过 VM 退出处理程序响应客户机事件</li>
</ul>
<h3 id="嵌套分页-ept"><a class="header" href="#嵌套分页-ept">嵌套分页 (EPT)</a></h3>
<p>使用扩展页表实现高效内存虚拟化：</p>
<ul>
<li>配置 EPT 指针 (EPTP)</li>
<li>处理 EPT 违规事件</li>
<li>支持内存访问权限控制</li>
</ul>
<h3 id="寄存器状态切换"><a class="header" href="#寄存器状态切换">寄存器状态切换</a></h3>
<p>通过X86汇编代码实现状态切换：</p>
<ul>
<li><code>save_regs_to_stack!</code> 宏保存寄存器状态到堆栈</li>
<li><code>restore_regs_from_stack!</code> 宏从堆栈恢复寄存器状态</li>
<li>特殊处理栈指针 (RSP) 以确保正确的状态切换</li>
</ul>
<h3 id="指令模拟"><a class="header" href="#指令模拟">指令模拟</a></h3>
<p>为特定指令提供模拟实现：</p>
<ul>
<li>CPUID 指令模拟，提供自定义处理器信息</li>
<li>XSETBV 指令处理，管理扩展状态</li>
<li>CR 寄存器访问处理</li>
</ul>
<h2 id="内存管理"><a class="header" href="#内存管理">内存管理</a></h2>
<h3 id="物理内存分配"><a class="header" href="#物理内存分配">物理内存分配</a></h3>
<p>通过 PhysFrame 抽象提供安全的物理内存管理：</p>
<ul>
<li>自动释放不再使用的物理页面</li>
<li>支持零填充和自定义初始化</li>
<li>提供物理地址到虚拟地址的转换</li>
</ul>
<h3 id="ept-页表管理"><a class="header" href="#ept-页表管理">EPT 页表管理</a></h3>
<p>实现二级地址转换机制：</p>
<ul>
<li>创建和管理 EPT 页表结构</li>
<li>支持不同的页面粒度 (4KB, 2MB, 1GB)</li>
<li>处理页面权限和访问控制</li>
</ul>
<style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () => window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () => { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY <200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() => { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () => { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() => { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) => (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) => { btn.addEventListener("click", (event) => { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer><div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="https://github.com/arceos-hypervisor/arm_vcpu">aarch64</a></li>
</ul>
<h1 id="arm_vcpu"><a class="header" href="#arm_vcpu">arm_vcpu</a></h1>
<h2 id="arm-虚拟化简介"><a class="header" href="#arm-虚拟化简介">ARM 虚拟化简介</a></h2>
<p>ARM 的硬件辅助虚拟化技术叫做 ARM-V (Virtualization) 技术，从 ARMv8 开始比较好的支持这种硬件辅助虚拟化技术。类似 X86 根/非根模式，ARM 引入多个异常级来控制资源访问权限。宿主机上 VMM 运行在 EL2 层，客户机操作系统运行在 EL1 层，应用程序运行在 EL0 层。</p>
<p>ARMv8 的异常级分为 4 级（EL0~EL3），权限也是从低到高。同时也分了两个 CPU 运行状态（Non-secure 和 Secure），顾名思义为了安全和非安全的运行态，此处不扩展。每一级运行的内容如下图所示：</p>
<p><img src="architecture/vcpu/../../assets/arm_vcpu.webp" alt="" /></p>
<p>运行在不同异常级最大的区别就是能够访问的寄存器组不同，同时也影响了某些硬件行为（比如对页表的 lookup）。运行在高异常级时可以访问低异常级的寄存器组，反之不行。
为了切换到更高的异常级（主动触发某个异常级的异常），需要主动执行特殊的指令：
• Supervisor Call (SVC)。一般由 EL0 切换到 EL1 的指令，会进入 EL1 的异常向量表。
• Hypervisor Call (HVC) 。Non-secure EL1 切换到 EL2 的指令，会进入到 EL2 的异常向量表。
• Secure monitor Call (SMC) 。切换到 EL3 的指令，只有在 EL1、EL2 执行有效。</p>
<h2 id="项目概述"><a class="header" href="#项目概述">项目概述</a></h2>
<p>arm_vcpu 是 axvisor 项目的重要组成部分，特别为 ARM 架构设计的虚拟 CPU 实现。该项目提供了在 ARM64 架构上实现虚拟机（VM）的底层组件，使操作系统或 hypervisor 能够创建和管理虚拟 CPU，进而运行客户操作系统。</p>
<h2 id="核心组件结构"><a class="header" href="#核心组件结构">核心组件结构</a></h2>
<h3 id="主要模块"><a class="header" href="#主要模块">主要模块</a></h3>
<p>项目包含以下核心模块：</p>
<ul>
<li><strong>context_frame</strong>: 定义了 ARM64 CPU 上下文帧结构</li>
<li><strong>exception</strong>: 处理异常和 VM 退出</li>
<li><strong>exception_utils</strong>: 提供异常处理的工具函数</li>
<li><strong>pcpu</strong>: 物理 CPU 相关功能的实现</li>
<li><strong>smc</strong>: 安全监视器调用实现</li>
<li><strong>vcpu</strong>: 虚拟 CPU 的核心实现</li>
</ul>
<h3 id="核心数据结构"><a class="header" href="#核心数据结构">核心数据结构</a></h3>
<h4 id="aarch64contextframe-srccontext_framers"><a class="header" href="#aarch64contextframe-srccontext_framers">Aarch64ContextFrame (src/context_frame.rs)</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Aarch64ContextFrame {
    pub gpr: [u64; 31],      // 通用寄存器
    pub sp_el0: u64,         // EL0 栈指针
    pub elr: u64,            // 异常链接寄存器
    pub spsr: u64,           // 保存的程序状态寄存器
}
<span class="boring">}</span></code></pre></pre>
<p>这个结构体代表了一个完整的 ARM64 CPU 上下文，包含了 CPU 的通用寄存器、栈指针、返回地址和状态标志。当发生 VM 切换时，这些寄存器需要保存和恢复。</p>
<h4 id="guestsystemregisters-srccontext_framers"><a class="header" href="#guestsystemregisters-srccontext_framers">GuestSystemRegisters (src/context_frame.rs)</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct GuestSystemRegisters {
    // 通用定时器相关寄存器
    pub cntvoff_el2: u64,
    cntp_cval_el0: u64,
    ...
    // 虚拟ID寄存器
    vpidr_el2: u32,
    pub vmpidr_el2: u64,

    // EL1/EL0 寄存器
    pub sp_el0: u64,
    sp_el1: u64,
    ...

    // Hypervisor上下文
    pub hcr_el2: u64,
    pub vttbr_el2: u64,
    ...
}
<span class="boring">}</span></code></pre></pre>
<p>这个结构体包含了客户虚拟机的系统寄存器状态，包括定时器寄存器、CPU ID、异常控制、内存管理等。这些寄存器在 VM 进入/退出时需要保存和恢复。</p>
<h4 id="aarch64vcpu-srcvcpurs"><a class="header" href="#aarch64vcpu-srcvcpurs">Aarch64VCpu (src/vcpu.rs)</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Aarch64VCpu&lt;H: AxVCpuHal&gt; {
    ctx: TrapFrame,
    host_stack_top: u64,
    guest_system_regs: GuestSystemRegisters,
    mpidr: u64,
    _phantom: PhantomData&lt;H&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Aarch64VCpu 是实现虚拟 CPU 的核心结构体，包含了虚拟 CPU 的完整状态：</p>
<ul>
<li><code>ctx</code>: 保存客户 VM 的 CPU 上下文</li>
<li><code>host_stack_top</code>: 主机栈顶指针，用于 VM 退出时恢复主机上下文</li>
<li><code>guest_system_regs</code>: 客户系统寄存器状态</li>
<li><code>mpidr</code>: 多处理器 ID 寄存器值</li>
</ul>
<h2 id="关键功能实现"><a class="header" href="#关键功能实现">关键功能实现</a></h2>
<h3 id="vcpu-初始化和运行"><a class="header" href="#vcpu-初始化和运行">VCPU 初始化和运行</a></h3>
<p>VCPU 的初始化在 <code>Aarch64VCpu::new()</code> 方法中实现，设置初始化 CPU 寄存器和系统状态：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn new(config: Self::CreateConfig) -&gt; AxResult&lt;Self&gt; {
    let mut ctx = TrapFrame::default();
    ctx.set_argument(config.dtb_addr);

    Ok(Self {
        ctx,
        host_stack_top: 0,
        guest_system_regs: GuestSystemRegisters::default(),
        mpidr: config.mpidr_el1,
        _phantom: PhantomData,
    })
}
<span class="boring">}</span></code></pre></pre>
<p>VCPU 的运行在 <code>run()</code> 方法中实现：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run(&amp;mut self) -&gt; AxResult&lt;AxVCpuExitReason&gt; {
    let exit_reson = unsafe {
        // 保存主机 SP_EL0 到上下文中
        save_host_sp_el0();
        self.restore_vm_system_regs();
        self.run_guest()
    };

    let trap_kind = TrapKind::try_from(exit_reson as u8).expect("Invalid TrapKind");
    self.vmexit_handler(trap_kind)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="异常处理机制"><a class="header" href="#异常处理机制">异常处理机制</a></h3>
<p>异常处理是通过异常向量表和处理函数实现的。异常向量表在 <code>exception.S</code> 中定义：</p>
<pre><code class="language-assembly">.section .text
.p2align 11
.global exception_vector_base_vcpu
exception_vector_base_vcpu:
    // current EL, with SP_EL0
    INVALID_EXCP_EL2 0 0
    ...
    // lower EL, aarch64
    HANDLE_LOWER_SYNC_VCPU
    HANDLE_LOWER_IRQ_VCPU
    ...
</code></pre>
<p>同步异常处理在 <code>handle_exception_sync</code> 函数中实现：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn handle_exception_sync(ctx: &amp;mut TrapFrame) -&gt; AxResult&lt;AxVCpuExitReason&gt; {
    match exception_class() {
        Some(ESR_EL2::EC::Value::DataAbortLowerEL) =&gt; {
            let elr = ctx.exception_pc();
            let val = elr + exception_next_instruction_step();
            ctx.set_exception_pc(val);
            handle_data_abort(ctx)
        }
        Some(ESR_EL2::EC::Value::HVC64) =&gt; {
            // 处理超级调用
            ...
        }
        ...
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="vm-进入退出流程"><a class="header" href="#vm-进入退出流程">VM 进入/退出流程</a></h3>
<p>VM 进入是通过 <code>run_guest()</code> 函数实现的：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn run_guest(&amp;mut self) -&gt; usize {
    unsafe {
        core::arch::asm!(
            // 保存主机上下文
            save_regs_to_stack!(),
            "mov x9, sp",
            "mov x10, x11",
            // 保存当前主机栈顶到 Aarch64VCpu 结构中
            "str x9, [x10]",
            "mov x0, x11",
            "b context_vm_entry",
            in("x11") &amp;self.host_stack_top as *const _ as usize,
            options(nostack)
        );
    }

    // 返回值，实际返回值是在 x0 中，当 return_run_guest 返回时
    0
}
<span class="boring">}</span></code></pre></pre>
<p>VM 退出是通过 <code>vmexit_handler()</code> 函数处理的：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn vmexit_handler(&amp;mut self, exit_reason: TrapKind) -&gt; AxResult&lt;AxVCpuExitReason&gt; {
    unsafe {
        // 保存客户系统寄存器
        self.guest_system_regs.store();

        // 保存客户 SP_EL0 到 Aarch64VCpu 结构中
        self.ctx.sp_el0 = self.guest_system_regs.sp_el0;

        // 恢复主机的 SP_EL0
        restore_host_sp_el0();
    }

    match exit_reason {
        TrapKind::Synchronous =&gt; handle_exception_sync(&amp;mut self.ctx),
        TrapKind::Irq =&gt; Ok(AxVCpuExitReason::ExternalInterrupt {
            vector: H::irq_fetch() as _,
        }),
        _ =&gt; panic!("Unhandled exception {:?}", exit_reason),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="物理-cpu-初始化"><a class="header" href="#物理-cpu-初始化">物理 CPU 初始化</a></h3>
<p>物理 CPU 初始化在 <code>Aarch64PerCpu::new()</code> 和 <code>hardware_enable()</code> 方法中实现：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn hardware_enable(&amp;mut self) -&gt; AxResult {
    // 首先保存原始异常向量表基址
    unsafe { ORI_EXCEPTION_VECTOR_BASE.write_current_raw(VBAR_EL2.get() as usize) }

    // 设置当前 VBAR_EL2 为本 crate 中定义的 exception_vector_base_vcpu
    VBAR_EL2.set(exception_vector_base_vcpu as usize as _);

    // 启用虚拟化功能
    HCR_EL2.modify(
        HCR_EL2::VM::Enable
            + HCR_EL2::RW::EL1IsAarch64
            + HCR_EL2::IMO::EnableVirtualIRQ
            + HCR_EL2::FMO::EnableVirtualFIQ
            + HCR_EL2::TSC::EnableTrapEl1SmcToEl2,
    );

    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<h2 id="关键机制解析"><a class="header" href="#关键机制解析">关键机制解析</a></h2>
<h3 id="上下文切换机制"><a class="header" href="#上下文切换机制">上下文切换机制</a></h3>
<p>上下文切换是虚拟化的核心机制，包括以下步骤：</p>
<ol>
<li>
<p><strong>VM 进入时</strong>:</p>
<ul>
<li>保存主机上下文（通用寄存器、栈指针）</li>
<li>加载客户 VM 上下文和系统寄存器</li>
<li>通过 <code>eret</code> 指令切换到 VM 执行</li>
</ul>
</li>
<li>
<p><strong>VM 退出时</strong>:</p>
<ul>
<li>通过异常向量捕获退出事件</li>
<li>保存客户 VM 上下文和系统寄存器</li>
<li>恢复主机上下文</li>
<li>返回 VM 退出原因</li>
</ul>
</li>
</ol>
<h3 id="内存管理-1"><a class="header" href="#内存管理-1">内存管理</a></h3>
<p>虚拟 CPU 的内存管理主要通过 <code>EPT</code> (Extended Page Table) 或 ARM 中的第二阶段地址转换实现：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set_ept_root(&amp;mut self, ept_root: HostPhysAddr) -&gt; AxResult {
    debug!("set vcpu ept root:{:#x}", ept_root);
    self.guest_system_regs.vttbr_el2 = ept_root.as_usize() as u64;
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>内存访问异常由 <code>handle_data_abort</code> 处理：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn handle_data_abort(context_frame: &amp;mut TrapFrame) -&gt; AxResult&lt;AxVCpuExitReason&gt; {
    let addr = exception_fault_addr()?;
    let access_width = exception_data_abort_access_width();
    let is_write = exception_data_abort_access_is_write();
    let reg = exception_data_abort_access_reg();
    let reg_width = exception_data_abort_access_reg_width();

    // ...

    if is_write {
        return Ok(AxVCpuExitReason::MmioWrite {
            addr,
            width,
            data: context_frame.gpr(reg) as u64,
        });
    }
    Ok(AxVCpuExitReason::MmioRead {
        addr,
        width,
        reg,
        reg_width,
    })
}
<span class="boring">}</span></code></pre></pre>
<h3 id="中断和异常处理"><a class="header" href="#中断和异常处理">中断和异常处理</a></h3>
<p>中断和异常处理通过异常向量表和对应的处理函数实现。系统提供了以下主要异常处理路径：</p>
<ol>
<li><strong>同步异常处理</strong>：处理客户 VM 的指令执行异常</li>
<li><strong>中断处理</strong>：处理物理中断并将其路由到适当的目标（主机或客户 VM）</li>
<li><strong>SMC 调用处理</strong>：安全监控器调用的处理</li>
</ol>
<h2 id="附-1参考资料"><a class="header" href="#附-1参考资料">附 1：参考资料</a></h2>
<p>ARM 官方虚拟化手册：</p>
<ul>
<li><a href="https://developer.arm.com/documentation/102142/0100/Introduction-to-virtualization">Introduction to virtualization</a></li>
<li><a href="https://developer.arm.com/-/media/Arm%20Developer%20Community/PDF/Learn%20the%20Architecture/Armv8-A%20virtualization.pdf?revision=a765a7df-1a00-434d-b241-357bfda2dd31">Armv8-A virtualization</a></li>
</ul>
<style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () => window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () => { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY <200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() => { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () => { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() => { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) => (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) => { btn.addEventListener("click", (event) => { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="概述-1"><a class="header" href="#概述-1">概述</a></h1>
<p>本节介绍在RISC-V体系结构中，与<strong>CPU虚拟化</strong>相关的基本知识、原理和设计。</p>
<h1 id="体系结构的虚拟化扩展-h"><a class="header" href="#体系结构的虚拟化扩展-h">体系结构的虚拟化扩展 'H'</a></h1>
<p>与x86等体系架构类似，RISC-V也采取了硬件辅助虚拟化的方式，以提升虚拟化效率，这种方式表现为对体系结构的一个扩展，代号'H'。</p>
<img src="architecture/vcpu/./riscv_vcpu.assets/image-20250314151758837.png" alt="image-20250314151758837" style="zoom:67%;" />
<center>图1：RISC-V扩展的官方示意图</center>
<p>上图来自RISC-V官方文档，可以看出，虚拟化扩展'H' 在原有的<strong>非虚拟化世界</strong>基础上创造了一个平行的<strong>虚拟化世界</strong>。</p>
<p>虚拟化世界是一个虚拟的计算机环境，它包含了两个特权级，正好可以满足各类主流的客户操作系统（Guest OS）设计与机制上对特权级保护的需要，其中<strong>VS</strong>用于运行Guest OS的内核，<strong>VU</strong>用于运行Guest OS支撑的用户态应用。只要不触及<strong>敏感指令</strong>，整个Guest OS及其之上的应用都只会在这个虚拟世界中运行，如此就保证了较高的执行效率；只有执行到<strong>敏感指令</strong>，虚拟世界无法提供虚拟化支持时，才会跳回到非虚拟化世界，此时Hypervisor接管系统执行权，处理虚拟世界模式中无法处理的情况后，再返回到虚拟世界中继续运行。</p>
<p>特权级<strong>HS</strong>是让两个世界相互切换机制得以实现的关键，Hypervisor就运行在这个特权级。该特权级在原有<strong>S</strong>特权级的基础上增加了一些特性与机制，针对虚拟化，新增了一些寄存器，扩展了某些寄存器的属性位，例如，在一个特殊的寄存器标志位的控制下，HS特权级可以决定是向<strong>U</strong>还是向<strong>VS</strong>返回。（后面专门说明该寄存器标志位）</p>
<p>下面为'H'扩展的相关概念和机制给出更准确的描述。</p>
<ul>
<li>
<p>非虚拟化世界 - 基本模式，或简称H-Mode。（在x86体系结构中，称为根模式）</p>
</li>
<li>
<p>虚拟化世界 - 虚拟模式，或简称V-Mode。（在x86体系结构中，称为非根模式）</p>
</li>
</ul>
<p>按照'H'扩展的设计，模式与特权级之间是<strong>正交</strong>的关系。图1虽然直观，但未能很好的体现这种正交的关系，它应该是受到了<strong>模拟器</strong>层次示意图的影响。但Hypervisor与模拟器还是有明确的区别。下面是更准确的图示：</p>
<img src="architecture/vcpu/./riscv_vcpu.assets/image-20250315113238902.png" alt="image-20250315113238902" style="zoom:80%;" />
<center>图2：模式与特权级的正交关系</center>
<blockquote>
<p>虚拟机是对物理机的“高效”复制，高效主要体现在虚拟机与物理机的“同质性”上，核心是CPU指令集的兼容，让虚拟机需要执行的大多数指令都可以不须翻译过程，而直接运行在物理CPU上。</p>
</blockquote>
<p>Guest所在的虚拟机运行在V-Mode模式中，一般的CPU指令直接由物理CPU执行，并不需要Hypervisor这一层次的中介干预，这是主流；只是在触及敏感指令才会切换到H-Mode，由Hypervisor处理。由于触及敏感指令是相对少数的情况，所以上面的正交关系示意图应该是更为合理的表述。</p>
<blockquote>
<p>本节只是涉及CPU虚拟化，事实上，对于内存和设备虚拟化来说，如果Hypervisor已经完成了特定物理页帧与Guest的分配关联，如果对特定外设采取了Passthrough的方案，那么Guest在运行中同样是直通物理硬件，而不需要Hypervisor作为中介干预的，Hypervisor在此类情况下，只是提前为Guest做了setup的工作。</p>
</blockquote>
<h1 id="cpu虚拟化涉及的关键对象及相互关系"><a class="header" href="#cpu虚拟化涉及的关键对象及相互关系">CPU虚拟化涉及的关键对象及相互关系</a></h1>
<p>在CPU虚拟化方面涉及的关键对象主要包括vCPU、虚拟机VM、物理CPU、任务Task和运行队列RUN_QUEUE，其中任务Task与运行队列由ArceOS提供，Hypervisor基于对它们的扩展和使用来实现所需的功能，它们的关系如下：</p>
<img src="architecture/vcpu/./riscv_vcpu.assets/image-20250315195416778.png" alt="image-20250315195416778" style="zoom:80%;" />
<p>以vCPU为起点进行分析，它是虚拟化世界中逻辑执行的主体。</p>
<p>每个虚拟机VM至少有一个vCPU，称为Primary vCPU，也是Boot vCPU。在此基础上，虚拟机VM可以包含更多的Secondary vCPU。这些从属于同一个虚拟机的vCPU在执行上是相互独立的，它们可以在不同的物理CPU上被同时调度执行。</p>
<p>vCPU实现的基础是ArceOS中的Task，它们可以看作是同一个对象在不同层面各自的表现形式，即在虚拟世界中表现为vCPU，而在ArceOS Hypervisor中的运行形式就是Task。</p>
<p>每个物理CPU有自己的RUN_QUEUE，如果想指定vCPU在某个或某组物理CPU上执行，只要把vCPU对应Task调度到相应的RUN_QUEUE即可。</p>
<h1 id="虚拟机首次启动前的准备"><a class="header" href="#虚拟机首次启动前的准备">虚拟机首次启动前的准备</a></h1>
<p>虚拟机VM首次启动前，Hypervisor需要为其检查和准备必要的条件。与CPU相关的核心工作：</p>
<ul>
<li>
<p>检查确认硬件平台支持‘H'扩展</p>
<p>底层平台必须支持RISC-V的’H'扩展，首先OpenSBI固件在启动时会检查misa寄存器的第7个状态位，如果是1表示支持虚拟化扩展。</p>
<img src="architecture/vcpu/./riscv_vcpu.assets/image-20250315232321423.png" alt="image-20250315232321423" style="zoom:50%;" />
<p>Hypervisor可以通过查看OpenSBI的输出来确定是否支持。但目前Hypervisor采取的方式是：直接尝试读hgatp，如果读失败，则说明底层平台不支持‘H’扩展。</p>
<blockquote>
<p>OpenSBI可以通过把misa的第7位设置为0，来从固件层面关闭对虚拟化的支持。</p>
</blockquote>
</li>
<li>
<p>设置寄存器hstatus状态，为切换到虚拟化模式做准备</p>
<p>特权级HS是U特权级切换和VS特权级切换的汇聚点，执行sret进行特权级返回时，通过hstatus的SPV这一位来确定返回的方向。</p>
<p>SPV这一位的作用是保存进入HS特权级之前的原始模式，如果是0，表示之前是非虚拟化模式，即从U特权级切换而来；如果是1，表示之前是在虚拟化模式中运行，即从VS特权级切换而来。</p>
<img src="architecture/vcpu/./riscv_vcpu.assets/image-20250315234025806.png" alt="image-20250315234025806" style="zoom:50%;" />
<p>Hypervisor在首次进入虚拟机之前，把hstatus的SPV设置为1，这样将来在执行sret时就能够确保进入到虚拟机中运行。</p>
</li>
<li>
<p>设置Guest寄存器sepc和sstatus，指定Guest OS 内核最初启动的指令地址和状态</p>
<p>预先为Guest伪造现场，当虚拟器首次启动时，将从Guest OS内核的入口开始执行。</p>
<img src="architecture/vcpu/./riscv_vcpu.assets/image-20250316074320672.png" alt="image-20250316074320672" style="zoom:50%;" />
</li>
</ul>
<p>准备工作完成后，Hypervisor通过VM-Entry过程首次启动虚拟机（实际是启动Primary vCPU），由此进入一个循环：</p>
<img src="architecture/vcpu/./riscv_vcpu.assets/image-20250315225843014.png" alt="image-20250315225843014" style="zoom: 50%;" />
<p>虚拟机启动后，Guest OS的内核与用户态应用在虚拟环境中运行，如同在物理机器中运行；触及敏感指令时将触发VM-Exit过程，退出虚拟化模式，控制权返回到Hypervisor，Hypervisor根据退出原因进行相应的处理，然后再次经由VM-Entry过程进入虚拟机，Guest将从上次执行的断点处恢复执行，如同从未被打断执行一样。如此循环往复，直至虚拟机关闭。</p>
<h1 id="vm-entry-从host到guest"><a class="header" href="#vm-entry-从host到guest">VM-Entry: 从Host到Guest</a></h1>
<p>VM-Entry是从Host环境进入Guest环境的过程，在体系结构的层面看，物理CPU需要完成从非虚拟化模式到虚拟化模式的切换。在切换过程中，一些跨模式共享的寄存器就可能遭到破坏。因此，Hypervisor需要在物理层执行切换前，预先保存部分寄存器组的状态到Host上下文中。此外，物理层面的模式切换完成后，会立即基于当时的寄存器状态继续工作，因此还需要在模式切换前，从Guest上下文中恢复相关寄存器到上次离开Guest环境到状态。vCPU代表了虚拟环境中独立的执行流，因此Host和Guest上下文同一由vCPU来维护。</p>
<img src="architecture/vcpu/./riscv_vcpu.assets/image-20250316074551411.png" alt="image-20250316074551411" style="zoom:50%;" />
<p>具体到RISC-V体系结构，对于VM-Entry，保存/恢复上下文的工作在_run_guest中完成，最后执行sret指令完成物理CPU的模式切换。过程_run_guest定义在riscv_vcpu/src/trap.S文件中，关键的数据结构和过程如下：</p>
<ul>
<li>
<p>RISCV_VCPU保存寄存器上下文的结构，参见riscv_cpu/src/vcpu.rs和riscv_cpu/src/regs.rs</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct RISCVVCpu&lt;H: AxVCpuHal&gt; {
    regs: VmCpuRegisters,
	... ...
}

pub struct VmCpuRegisters {
    // CPU state that's shared between our's and the guest's execution environment. Saved/restored
    // when entering/exiting a VM.
    pub hyp_regs: HypervisorCpuState,
    pub guest_regs: GuestCpuState,
	... ...
<span class="boring">}</span></code></pre></pre>
<p>每个RISCV_VCPU实例中通过regs成员保存寄存器状态，具体又分为Host上下文hyp_regs和Guest上下文guest_regs。</p>
</li>
<li>
<p>向_run_guest传入上下文数据区的起始地址，参见riscv_vcpu/src/vcpu.rs</p>
<p>RISCV_VCPU的主运行方法run在调用_run_guest时，会传入其regs成员的地址作为参数。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run(&amp;mut self) -&gt; AxResult&lt;AxVCpuExitReason&gt; {
	... ...
    // Safe to run the guest as it only touches memory assigned to it by being owned
    // by its page table
    _run_guest(&amp;mut self.regs);
	... ...
<span class="boring">}</span></code></pre></pre>
<p>RISCV_VCPU成员regs的地址作为第一个参数，在汇编层面保存在a0寄存器中。</p>
</li>
<li>
<p>过程_run_guest关于保存Host上下文的实现，参见riscv_vcpu/src/trap.S</p>
<p>接上面，_run_guest中的a0保存的是RISCV_VCPU的成员regs的开始地址，加上偏移就可以访问到Host/Guest两组上下文中存放各个寄存器的具体位置。</p>
<pre><code class="language-assembly">_run_guest:
    /* Save hypervisor state */

    /* Save hypervisor GPRs (except T0-T6 and a0, which is GuestInfo and stashed in sscratch) */
    sd   ra, ({hyp_ra})(a0)
    sd   gp, ({hyp_gp})(a0)
    sd   tp, ({hyp_tp})(a0)
	... ...
</code></pre>
</li>
<li>
<p>过程_run_guest关于恢复Guest上下文的实现</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    /* Restore the gprs from this GuestInfo */
    ld   ra, ({guest_ra})(a0)
    ld   gp, ({guest_gp})(a0)
    ld   tp, ({guest_tp})(a0)
	... ...
<span class="boring">}</span></code></pre></pre>
<p>为Guest运行提前准备，把涉及的寄存器状态从上下文中恢复出来。</p>
</li>
<li>
<p>执行模式切换，进入到虚拟机执行Guest OS</p>
<p>在前面已经保存和恢复上下文的基础上，通过指令<code>sret</code>完成物理CPU模式的切换，进入到Guest环境中执行。</p>
</li>
</ul>
<h1 id="vm-exit从gust返回host"><a class="header" href="#vm-exit从gust返回host">VM-Exit：从Gust返回Host</a></h1>
<p>VM-Exit是虚拟机无法满足虚拟化条件时，从体系结构硬件发起的、由特殊trap响应函数配合的自动过程。从执行逻辑上看，它基本上是GuestVM-Entry的逆向过程。</p>
<img src="architecture/vcpu/./riscv_vcpu.assets/image-20250316093606353.png" alt="image-20250316093606353" style="zoom:50%;" />
<ul>
<li>
<p>VM-Exit过程的触发</p>
<p>VM-Exit过程的触发是物理硬件的基本机制，相当于宏内核模式下，低特权级程序在执行某些特权操作时所触发的trap过程。软件层面Hypervisor需要做的工作就是在上次执行_run_guest时，提前注册响应函数_guest_exit。</p>
<pre><code class="language-assembly">    /* Set stvec so that hypervisor resumes after the sret when the guest exits. */
    la    t1, _guest_exit
    csrrw t1, stvec, t1
	...
</code></pre>
<p>对于RISC-V，寄存器stvec保存trap响应函数入口表的起始地址，对于虚拟化导致的trap同样适用。</p>
</li>
<li>
<p>VM-Exit的响应过程</p>
<p>响应过程主体就是_guest_exit的实现，参见riscv_vcpu/src/trap.S</p>
<pre><code class="language-assembly">.align 2
_guest_exit:
    /* Pull GuestInfo out of sscratch, swapping with guest's a0 */
    csrrw a0, sscratch, a0

    /* Save guest GPRs. */
    sd   ra, ({guest_ra})(a0)
    sd   gp, ({guest_gp})(a0)
    sd   tp, ({guest_tp})(a0)
	... ...
	ret
</code></pre>
<p>由于逻辑上基本是_run_guest的逆过程，不再赘述。但是需要特别注意该过程的最后一行是<code>ret</code>指令，是普通的函数返回指令，原理是从寄存器ra取出返回地址后跳转。回顾VM-Entry中切换模式进入虚拟机时，执行的是_run_guest，如下：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run(&amp;mut self) -&gt; AxResult&lt;AxVCpuExitReason&gt; {
	... ...
    // Safe to run the guest as it only touches memory assigned to it by being owned
    // by its page table
    _run_guest(&amp;mut self.regs);
	... ...	// &lt;- Reg 'ra' points to this line.
<span class="boring">}</span></code></pre></pre>
<p>当时寄存器ra保存的就是_run_guest函数的下一行指令代码地址，所以此时执行<code>ret</code>的效果就是返回到该处继续执行。</p>
<p>从Hypervisor的角度看，它执行_run_guest的效果就如同执行了一次普通的函数调用，但是内部已经经历了一次从进入虚拟机到退出虚拟机的完整周期。</p>
</li>
</ul>
<h1 id="附1参考资料"><a class="header" href="#附1参考资料">附1：参考资料</a></h1>
<p>RISC-V官方指令手册中，关于‘H’扩展的章节。</p>
<p><a href="https://github.com/konpoe/riscv-docs/blob/main/riscv-privileged-20211203.pdf">riscv-docs/riscv-privileged-20211203.pdf at main · konpoe/riscv-docs</a></p>
<h1 id="附2vcpu与物理cpu绑定"><a class="header" href="#附2vcpu与物理cpu绑定">附2：vCPU与物理CPU绑定</a></h1>
<p>如正文所述，Hypervisor基于对ArceOS的扩展实现。vCPU与ArceOS的Task是一体的，因此vCPU与物理CPU的绑定关系是通过Task与物理CPU的绑定关系来实现的。</p>
<p>ArceOS提供了要给cpumask的功能，即通过位图的形式指定Task可以被哪些RUN_QUEUE所执行，RUN_QUEUE与物理CPU是一一对应的关系，由此可以实现vCPU到物理CPU的绑定。<style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () =&gt; window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () =&gt; { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY &lt;200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() =&gt; { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () =&gt; { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() =&gt; { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) =&gt; (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) =&gt; { btn.addEventListener("click", (event) =&gt; { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer></p>
<div style="break-before: page; page-break-before: always;"></div><p>🚧 Coming soon.<style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () =&gt; window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () =&gt; { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY &lt;200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() =&gt; { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () =&gt; { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() =&gt; { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) =&gt; (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) =&gt; { btn.addEventListener("click", (event) =&gt; { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="axaddrspace"><a class="header" href="#axaddrspace">axaddrspace</a></h1>
<h2 id="介绍-1"><a class="header" href="#介绍-1">介绍</a></h2>
<p>内存虚拟化由<a href="https://github.com/arceos-hypervisor/axaddrspace">axaddrspace</a>实现，该模块与架构无关，负责管理和映射客户虚拟机的二级地址空间（GPA -&gt; HPA）</p>
<p><img src="architecture/../assets/pt.png" alt="" /></p>
<h2 id="系统架构-1"><a class="header" href="#系统架构-1">系统架构</a></h2>
<h3 id="模块组织-1"><a class="header" href="#模块组织-1">模块组织</a></h3>
<pre><code>axaddrspace/
    ├── src/
    │   ├── address_space/   
    |   |   ├── backend
    |   |   |    ├── alloc.rs   - 动态分配映射实现
    |   |   |    ├── linear.rs  - 线性映射实现
    |   |   └── ├── mod.rs     - 模块入口
    |   └── ├── mod.rs     - 客户机物理地址空间管理模块
    │   ├── npt/
    │   |   ├── arch/
    │   |   |   ├── aarch64.rs   - ARMv8 架构下嵌套页表管理
    │   |   |   ├── mod.rs       - 模块入口
    │   │   |   ├── riscv.rs     - riscv页表管理
    │   │   └── ├── x86_64.rs    - x86_64 架构扩展页表管理
    │   └── ├── mod.rs       - 模块入口
    │   ├── addr.rs      - 地址类型定义
    │   └── lib.rs       - 库入口点
</code></pre>
<h3 id="关键数据结构-1"><a class="header" href="#关键数据结构-1">关键数据结构</a></h3>
<p>客户机物理地址空间结构体</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct AddrSpace&lt;H: PagingHandler&gt; {
  va_range: GuestPhysAddrRange,  //地址空间范围
  areas: MemorySet&lt;Backend&lt;H&gt;&gt;,  //内存区域集合
  pt: PageTable&lt;H&gt;,              //嵌套页表实例
}
<span class="boring">}</span></code></pre></pre>
<p>该结构体使用了一个泛型类型参数<H>，该参数受page_table_multiarch模块中PagingHandler trait的约束。</p>
<h2 id="核心功能实现-1"><a class="header" href="#核心功能实现-1">核心功能实现</a></h2>
<h3 id="功能代码"><a class="header" href="#功能代码">功能代码</a></h3>
<p>定义一个统一内存映射后端枚举类型 <code>Backend&lt;H&gt;</code>，用于抽象不同策略的物理内存管理方式。通过泛型参数 <code>H: PagingHandler</code> 实现对不同页表操作接口的兼容，允许后端适配不同架构的页表实现（如x86_64的EPT、ARM的Stage-2页表）。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Backend&lt;H: PagingHandler&gt; {
  /// Linear mapping backend.
  Linear {
    /// `vaddr - paddr`.
    pa_va_offset: usize,
  },
  /// Allocation mapping backend.
  Alloc {
    populate: bool,
    _phantom: core::marker::PhantomData&lt;H&gt;,
  },
}
<span class="boring">}</span></code></pre></pre>
<p>当前支持两种内存映射后端策略：</p>
<ol>
<li>
<p>Linear（线性映射）<strong><code>物理地址 = 虚拟地址 - pa_va_offset</code></strong></p>
</li>
<li>
<p>Alloc（动态分配映射）：通过全局分配器动态获取物理帧，支持两种模式：</p>
<ul>
<li><strong>预分配模式 (<code>populate=true</code>)</strong>: 立即分配所有物理帧，无缺页开销</li>
<li><strong>按需分配模式 (<code>populate=false</code>)</strong>: 延迟分配，通过缺页异常触发分配</li>
</ul>
</li>
</ol>
<p>文件alloc.rs实现了动态分配映射:</p>
<div class="table-wrapper"><table><thead><tr><th>方法</th><th style="text-align: left">功能描述</th></tr></thead><tbody>
<tr><td><code>new_alloc</code></td><td style="text-align: left">创建后端实例，指定是否预分配</td></tr>
<tr><td><code>map_alloc</code></td><td style="text-align: left">建立客户机虚拟地址到动态分配物理帧的映射</td></tr>
<tr><td><code>unmap_alloc</code></td><td style="text-align: left">解除映射并释放关联的物理帧</td></tr>
<tr><td><code>handle_page_fault</code></td><td style="text-align: left">处理缺页异常，为未映射的地址分配物理帧</td></tr>
</tbody></table>
</div>
<p>文件linear.rs实现了线性映射，功能有：</p>
<pre><code>impl&lt;H: PagingHandler&gt; Backend&lt;H&gt; {
    // 创建线性映射后端实例
    pub const fn new_linear(pa_va_offset: usize) -&gt; Self
    // 执行线性映射
    pub(crate) fn map_linear(...) -&gt; bool 
    // 解除线性映射
    pub(crate) fn unmap_linear(...) -&gt; bool

}
</code></pre>
<p>axaddrspace通过使用<code>page_table_multiarch</code>的泛型页表框架和<code>page_table_entry</code>的标准接口定义，实现了支持x86、ARM、RISC-V的嵌套页表管理的多架构兼容。</p>
<h3 id="依赖注入"><a class="header" href="#依赖注入">依赖注入</a></h3>
<p><code>AddrSpace</code>结构体表示虚拟机的内存区域和二级地址映射，依赖于泛型类型<code>PagingHandler</code>处理页表相关操作。<code>axaddrspace</code>由<code>axvm</code>的<code>AxVM</code>结构体拥有和管理，而<code>AxVM</code>依赖于定义在<code>axvm</code>的<code>hal.rs</code>中的<code>AxVMHal</code> trait。</p>
<p>实际上，<code>PagingHandler</code>是<code>AxVMHal</code> trait的一个关联类型：</p>
<pre><code>// 底层软件（内核或虚拟机监控程序）必须实现的接口
pub trait AxVMHal: Sized {
    type PagingHandler: page_table_multiarch::PagingHandler;
    // 将虚拟地址转换为对应的物理地址
    fn virt_to_phys(vaddr: HostVirtAddr) -&gt; HostPhysAddr;
    // 获取当前时间（纳秒）
    fn current_time_nanos() -&gt; u64;
	// ...
}
</code></pre>
<p><code>AxVMHal</code>由<code>vmm-app</code>中的<code>AxVMHalImpl</code>实现，其关联类型<code>PagingHandler</code>依赖于ArceOS的<code>axhal</code>模块提供的<code>PagingHandlerImpl</code>：</p>
<pre><code>pub struct AxVMHalImpl;

impl AxVMHal for AxVMHalImpl {
    type PagingHandler = axhal::paging::PagingHandlerImpl;
    fn virt_to_phys(vaddr: VirtAddr) -&gt; PhysAddr {
        axhal::mem::virt_to_phys(vaddr)
    }
    fn current_time_nanos() -&gt; u64 {
        axhal::time::monotonic_time_nanos()
    }
	// ...
}
</code></pre>
<p>当前设计通过Rust的泛型类型（Trait）及其关联类型机制实现了依赖注入。<style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () =&gt; window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () =&gt; { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY &lt;200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() =&gt; { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () =&gt; { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() =&gt; { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) =&gt; (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) =&gt; { btn.addEventListener("click", (event) =&gt; { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="虚拟中断控制器"><a class="header" href="#虚拟中断控制器">虚拟中断控制器</a></h1>
<h2 id="各架构控制器"><a class="header" href="#各架构控制器">各架构控制器</a></h2>
<ul>
<li>x86_64: local Apic (xAPIC and x2APIC) and IO Apic</li>
<li>aarch64: GIC (v2,v3,v4)</li>
<li>riscv64: PLIC or APLIC</li>
</ul>
<h2 id="实现方式"><a class="header" href="#实现方式">实现方式</a></h2>
<h3 id="虚拟控制器"><a class="header" href="#虚拟控制器">虚拟控制器</a></h3>
<p>为相应架构的中断控制器设计虚拟控制器模型，为每个 <code>vcpu</code> 创建一个内部中断模拟设备，用于管理 <code>systime</code> 中断等，为每个客户机创建一个外部中断模拟设备，用于管理 <code>io</code> 中断。</p>
<h3 id="mmio-区域注册"><a class="header" href="#mmio-区域注册">MMIO 区域注册</a></h3>
<p>在客户机进行中断控制器的寄存器读写时，会通过 <code>data abort</code> 陷入到虚拟机，到达 <code>axvcpu</code> 的如下代码段：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match &amp;exit_reason {
    AxVCpuExitReason::MmioRead {
        addr,
        width,
        reg,
        reg_width: _,
    } =&gt; {
        let val = self
            .get_devices()
            .handle_mmio_read(*addr, (*width).into())?;
        vcpu.set_gpr(*reg, val);
        true
    }
    AxVCpuExitReason::MmioWrite { addr, width, data } =&gt; {
        self.get_devices()
            .handle_mmio_write(*addr, (*width).into(), *data as usize);
        true
    }
    AxVCpuExitReason::IoRead { port: _, width: _ } =&gt; true,
    AxVCpuExitReason::IoWrite {
        port: _,
        width: _,
        data: _,
    } =&gt; true,
    AxVCpuExitReason::NestedPageFault { addr, access_flags } =&gt; self
        .inner_mut
        .address_space
        .lock()
        .handle_page_fault(*addr, *access_flags),
    _ =&gt; false,
};
<span class="boring">}</span></code></pre></pre>
<p>通过 <code>handle_mmio_read</code> 和 <code>handle_mmio_write</code> 实现相应 <code>mmio</code> 范围内的地址访问会路由到相应虚拟设备。</p>
<p>通过对相应虚拟寄存器的读写逻辑，实现对客户机中断设置的权限控制。</p>
<h3 id="中断透传"><a class="header" href="#中断透传">中断透传</a></h3>
<p>虚拟中断控制器通过配置表，判断客户机是否有权限控制中断号，若有权限，则将客户机中断号相应操作透传到物理中断控制器。</p>
<h3 id="虚拟设备到-guest-os-的通知"><a class="header" href="#虚拟设备到-guest-os-的通知">虚拟设备到 Guest OS 的通知</a></h3>
<p>绝大多数情况下，虚拟设备通知 Guest OS 的方式是虚拟中断。但虚拟中断并不完全来自虚拟设备，也可能来自直通设备的物理中断（由 Hypervisor 转发）或者来自某个 VCpu 的虚拟 IPI（同样由 Hypervisor 转发）。因此，需要一个统一的虚拟中断注入接口，用以向指定的 VCpu 注入中断。</p>
<p>这个接口应该放置在 AxVM 中，签名类似于 inject_interrupt_to_vcpu(target: Option<CpuMask>, vector: usize) -&gt; AxResult。其中 target 可以控制中断注入的目标 VCpu，是任意一个 VCpu，指定一个 VCpu，指定一组 VCpu，或者所有 VCpu；vector 是中断向量。放置在 AxVM 中的原因是，中断注入的操作可能需要访问 VGIC 等设备。</p>
<p>为了设备不直接依赖于 AxVM 或者 AxVCpu，虚拟设备结构体不能直接调用 inject_interrupt_to_vcpu，而是应当通过提供给设备的一个闭包来实现中断注入。</p>
<p>系统时钟和虚拟设备等中断通过全虚拟化方式实现，每个 <code>vcpu</code> 都有一个中断向量表，用于记录客户机中断号对应的中断状态。</p>
<p>当虚拟设备触发中断时，向物理中断控制器发送软中断，由物理中断控制器将中断请求转发到 <code>vcpu</code>。</p>
<h3 id="inject_interrupt_to_vcpu-的实现"><a class="header" href="#inject_interrupt_to_vcpu-的实现"><code>inject_interrupt_to_vcpu</code> 的实现</a></h3>
<p>为了保持 AxVM 的架构无关性，AxVCpu 和 AxArchVCpu 仍然应该提供一个 inject_interrupt 方法，用以向当前 VCpu 注入中断。AxVM 的 inject_interrupt_to_vcpu 方法应该根据 target 参数，调用对应 AxVCpu 的 inject_interrupt 方法。在 aarch64 和 riscv64 平台上，AxArchVCpu 在 setup 时，应该通过 SetupConfig 得到一个实际完成中断注入的闭包；而在 x86 平台上，AxArchVCpu 本身具有中断注入的能力，因此无需进一步的配置。</p>
<p>当被注入中断时，如果 VCpu 正在当前核心上运行，可以直接通过各个架构的虚拟化机制注入中断；如果 VCpu 处于当前核心就绪队列中，则应该记录中断，等 VCpu 下次运行时再注入；如果 VCpu 在非当前核心上运行，可以通过 IPI 通知目标核心的 Hypervisor，由 Hypervisor 负责注入中断。</p>
<h2 id="参考资料"><a class="header" href="#参考资料">参考资料</a></h2>
<ul>
<li>Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volum 3C: CHAPTER 30 APIC VIRTUALIZATION AND VIRTUAL INTERRUPTS</li>
<li><a href="https://developer.arm.com/documentation/ihi0048/latest/">ARM Generic Interrupt Controller Architecture version 2.0 - Architecture Specification</a></li>
<li><a href="https://developer.arm.com/documentation/ihi0069/latest/">Arm Generic Interrupt Controller (GIC) Architecture Specification GIC architecture version 3 and version 4</a></li>
<li>https://github.com/riscv/riscv-plic-spec/blob/master/riscv-plic.adoc<style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () =&gt; window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () =&gt; { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY &lt;200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() =&gt; { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () =&gt; { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() =&gt; { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) =&gt; (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) =&gt; { btn.addEventListener("click", (event) =&gt; { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 align="center">Virtual GIC v2 设计文档</h1>
<h1 id="一gicv2介绍"><a class="header" href="#一gicv2介绍">一、GICv2介绍</a></h1>
<p><img src="architecture/irq/../../assets/vgicv2/banner.png" alt="" /></p>
<p>通过上图可以确定，GIC 主要包含 3 部分：Distributor、CPU interfaces 和 Virtual CPU interfaces。Virtual CPU interfaces 包含 Virtual interface control 和 Virtual CPU interface。</p>
<p><img src="architecture/irq/../../assets/vgicv2/no-virtualization.png" alt="" /></p>
<ul>
<li>
<p>中断进入 distributor，然后分发到 CPU interface</p>
</li>
<li>
<p>某个 CPU 触发中断后，读 GICC_IAR 拿到中断信息，处理完后写 GICC_EOIR 和 GICC_DIR（如果 GICC_CTLR.EOImodeNS 是 0，则 EOI 的同时也会 DI）</p>
</li>
<li>
<p>GICD、GICC 寄存器都是 MMIO 的，device tree 中会给出物理地址</p>
</li>
</ul>
<h2 id="中断类型"><a class="header" href="#中断类型">中断类型</a></h2>
<ul>
<li>
<h3 id="1-软件生成中断software-generated-interrupts-sgi"><a class="header" href="#1-软件生成中断software-generated-interrupts-sgi">1. <strong>软件生成中断（Software Generated Interrupts, SGI）</strong></a></h3>
<ul>
<li><strong>中断号范围</strong>：0 到 15（共 16 个中断号）</li>
<li><strong>用途</strong>：用于处理器间通信（IPI），允许一个处理器核心向另一个处理器核心发送中断信号。</li>
<li><strong>特点</strong>：每个核心都可以生成和接收这些中断，通常用于任务调度、同步等操作。</li>
</ul>
<h3 id="2-私有外设中断private-peripheral-interrupts-ppi"><a class="header" href="#2-私有外设中断private-peripheral-interrupts-ppi">2. <strong>私有外设中断（Private Peripheral Interrupts, PPI）</strong></a></h3>
<ul>
<li><strong>中断号范围</strong>：16 到 31（共 16 个中断号）</li>
<li><strong>用途</strong>：用于处理与特定处理器核心直接相关的硬件事件，例如计时器中断、性能监控中断、调试中断等。</li>
<li><strong>特点</strong>：这些中断是每个核心私有的，只有对应的核心会处理这些中断。</li>
</ul>
<h3 id="3-共享外设中断shared-peripheral-interrupts-spi"><a class="header" href="#3-共享外设中断shared-peripheral-interrupts-spi">3. <strong>共享外设中断（Shared Peripheral Interrupts, SPI）</strong></a></h3>
<ul>
<li>
<p><strong>中断号范围</strong>：32 到 1019（共 988 个中断号）</p>
</li>
<li>
<p><strong>用途</strong>：用于处理系统中共享的外设中断，例如来自外部设备、网络接口、存储设备等的中断。</p>
</li>
<li>
<p><strong>特点</strong>：这些中断是所有核心共享的，可以由任何一个核心处理，通常通过中断亲和性（affinity）来决定哪个核心处理该中断。</p>
</li>
<li>
<p>SPI默认发送vcpu 0上，同样将中断信号放到vcpu的ap_list字段排队，等待vcpu处理。</p>
</li>
</ul>
</li>
</ul>
<h2 id="distributor-作用"><a class="header" href="#distributor-作用">Distributor 作用</a></h2>
<p>Distributor 主要作用为检测中断源、控制中断源行为和将中断源分发到指定 CPU 接口上（针对每个 CPU 将优先级最高的中断转发到该接口上）。</p>
<p>Distributor 对中断的控制包括：</p>
<ul>
<li>
<p>全局启用中断转发到 CPU 接口</p>
</li>
<li>
<p>开启或关闭每一个中断</p>
</li>
<li>
<p>为每个中断设置优先级</p>
</li>
<li>
<p>为每个中断设置目标处理器列表</p>
</li>
<li>
<p>设置每个外设中断触发方式（电平触发、边缘触发）</p>
</li>
<li>
<p>为每个中断设置组</p>
</li>
<li>
<p>将 SGI 转发到一个或多个处理器</p>
</li>
<li>
<p>每个中断状态可见</p>
</li>
<li>
<p>提供软件设置或清除外设中断的挂起状态的一种机制</p>
</li>
</ul>
<h2 id="中断-id"><a class="header" href="#中断-id">中断 ID</a></h2>
<p>使用 ID 对中断源进行标识。每个 CPU 接口最多可以有 1020 个中断。SPI 和 PPI 中断为每个接口特定的，SPI 为为所有接口共用，因此多处理器系统中实际中断数大于 1020 个。</p>
<h2 id="cpu-interface"><a class="header" href="#cpu-interface">CPU Interface</a></h2>
<p>CPU 接口提供一个处理器连接到 GIC 的接口。每一个 CPU 接口都提供一个编程接口：</p>
<ul>
<li>允许向处理器发送中断请求信号</li>
<li>确认中断</li>
<li>指示中断处理完成</li>
<li>为处理器设置中断优先级掩码</li>
<li>为处理器定义抢占策略</li>
<li>选择最高优先级挂起中断</li>
</ul>
<h1 id="二中断处理状态机"><a class="header" href="#二中断处理状态机">二、中断处理状态机</a></h1>
<p><code>GIC</code> 为每个 <code>CPU</code> 接口上每个受支持的中断维护一个状态机。下图显示了此状态机的实例，以及可能的状态转换。</p>
<p><img src="architecture/irq/../../assets/vgicv2/interrupt-state.png" alt="" /></p>
<ul>
<li>Inactive：该中断源处于未激活状态</li>
<li>Pending：中断源触发状态，GIC感知到，但还未被分发到PE</li>
<li>Active：中断已经被某个PE认领确认</li>
<li>Active and pending：这个中断源的一次触发已经被PE确认，同时这个中断源的另一次触发正在pending状态</li>
</ul>
<h2 id="添加挂起状态a1a2"><a class="header" href="#添加挂起状态a1a2">添加挂起状态（A1、A2）</a></h2>
<ul>
<li>
<p>对于一个 SGI，发生以下 2 种情况的 1 种：</p>
<ul>
<li>软件写 <strong>GICD_SGIR</strong> 寄存器，指定目标处理器</li>
<li>目标处理器上软件写 <strong>GICD_SPENDSGIRn</strong> 寄存器</li>
</ul>
</li>
<li>
<p>对于一个 SPI 或 PPI，发生以下 2 种情况的 1 种：</p>
<ul>
<li>
<p>外设发出一个中断请求信号</p>
</li>
<li>
<p>软件写 <strong>GICD_ISPENDRn</strong> 寄存器</p>
</li>
</ul>
</li>
</ul>
<h2 id="删除挂起状态b1b2"><a class="header" href="#删除挂起状态b1b2">删除挂起状态（B1、B2）</a></h2>
<ul>
<li>对于 SGI
<ul>
<li>目标处理器写 <strong>GICD_CPENDSGIRn</strong> 寄存器</li>
</ul>
</li>
<li>对于一个 SPI 或 PPI，发生以下 2 种情况的 1 种：
<ul>
<li>电平触发类型中断，信号取消</li>
<li>边沿触发类型中断，软件写 GICD_ICPENDRn 寄存器</li>
</ul>
</li>
</ul>
<h2 id="挂起到激活c"><a class="header" href="#挂起到激活c">挂起到激活（C）</a></h2>
<ul>
<li>如果中断使能，并且高优先级，软件从 GICC_IAR 寄存器读取时发生状态改变。</li>
</ul>
<h2 id="挂起到激活和挂起d"><a class="header" href="#挂起到激活和挂起d">挂起到激活和挂起（D）</a></h2>
<ul>
<li>
<p>对于 SGI，这种转变发生在以下任一情况下：</p>
<ul>
<li>将 SGI 状态设置为挂起的写入操作与读取 GICC_IAR 几乎同时发生</li>
<li>当多个挂起的 SGI 具有相同 ID 时，并且它们来自同一个源处理器并指向同一个处理器。其中一个 SGI 状态变为激活（C），其他 SGI 状态变为激活和挂起（D）</li>
</ul>
</li>
<li>
<p>对于 SPI 或 PPI，满足以下所有条件，则发生这种转换</p>
<ul>
<li>中断开启</li>
<li>软件读取 GICC_IAR，读操作将激活状态添加到中断中。</li>
<li>此外，还应满足以下条件之一：
<ul>
<li>对于电平触发中断，中断信号保持。通常都是这样，因为外设直到处理器处理完中断后才会取消触发信号。</li>
<li>对于边沿触发中断，是否发生此转换取决于读取 GICC_IAR 的时间（中断再次触发，上一次未处理），读取 <strong>GICC_IAR</strong> 可能会转换到 C，后面可能会转换到 A2。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="删除激活状态e1e2"><a class="header" href="#删除激活状态e1e2">删除激活状态（E1、E2）</a></h2>
<ul>
<li>软件写入 GICC_EOIR 或 GICC_DIR 来停用中断，</li>
</ul>
<h1 id="三中断虚拟化设计"><a class="header" href="#三中断虚拟化设计">三、中断虚拟化设计</a></h1>
<h2 id="中断虚拟化概要"><a class="header" href="#中断虚拟化概要">中断虚拟化概要</a></h2>
<p><img src="architecture/irq/../../assets/vgicv2/vgic_summary.png" alt="" /></p>
<ul>
<li>HCR_EL2.IMO 设置为 1 后，所有 IRQ 都会 trap 到 Hypervisor</li>
<li>Hypervisor 判断该 IRQ 是否需要插入到 vCPU</li>
<li>插入 vIRQ 之后，在切换到 VM 之前需要 EOI 物理 IRQ，即 priority drop，降低运行优先级，使之后 VM 运行时能够再次触发该中断</li>
<li>回到 VM 后，GIC 在 EL1 触发 vIRQ，这时候 EOI 和 DI 会把 vIRQ 和物理 IRQ 都 deactivate，因此不需要再 trap 到 Hypervisor ，不过如果是 SGI 的话并不会 deactivate，需要 Hypervisor 自己处理。</li>
</ul>
<h3 id="hypervisor-interface-gich"><a class="header" href="#hypervisor-interface-gich">Hypervisor interface (GICH)</a></h3>
<ul>
<li>GICH base 物理地址在 device tree 中给出</li>
<li>控制寄存器：GICH_HCR、GICH_VMCR 等</li>
<li>List 寄存器：GICH_LRn</li>
<li>KVM 中，这些寄存器保存在 <code>struct vgic_cpu</code> 的 <code>vgic_v2</code> 字段，<code>struct vgic_cpu</code> 本身放在 <code>struct kvm_vcpu_arch</code>，每个 vCPU 一份</li>
<li>vCPU switch 的时候，需要切换这些寄存器（KVM 在 <code>vgic-v2-switch.S</code> 中定义相关切换函数）</li>
<li>VM 无法访问 GICH 寄存器，因为根本没有映射</li>
</ul>
<h3 id="vcpu-interface-gicv-gicc-in-vms-view"><a class="header" href="#vcpu-interface-gicv-gicc-in-vms-view">vCPU interface (GICV, GICC in VM's view)</a></h3>
<ul>
<li>GICV 也是物理 GIC 上存在的，base 物理地址同样在 device tree 中给出</li>
<li>KVM 在系统全局的一个结构体（<code>struct vgic_params vgic_v2_params</code>）保存了这个物理地址</li>
<li>创建 VM 时 Hypervisor 把一个特定的 GPA（KVM 中通过 <code>ioctl</code> 设置该地址）映射到 GICV base 物理地址，然后把这个 GPA 作为 GICC base 在 device tree 中传给 VM</li>
<li>VM 以为自己在访问 GICC，实际上它在访问 GICV</li>
<li>目前理解这些 GICV 寄存器在 vCPU switch 的时候是不需要保存的（KVM 里没有保存 GICV 相关的代码），因为它其实在硬件里访问的是 GICH 配置的那些寄存器，比如 LR</li>
</ul>
<h3 id="virtual-distributor-gicd-in-vms-view"><a class="header" href="#virtual-distributor-gicd-in-vms-view">Virtual distributor (GICD in VM's view)</a></h3>
<ul>
<li>实际是内核里的一个结构体（<code>struct vgic_dist</code>）</li>
<li>在 device tree 中给 VM 一个 GICD base，但实际上没有映射</li>
<li>VM 访问 GICD 时，trap &amp; emulate，直接返回或设置 <code>struct vgic_dist</code> 里的字段（在 <code>vgic-v2-emul.c</code> 文件中）</li>
<li>每个 VM 一个，而不是每个 vCPU 一个，所以 <code>struct vgic_dist</code> 放在 <code>struct kvm_arch</code> 里</li>
</ul>
<h3 id="vms-view"><a class="header" href="#vms-view">VM's view</a></h3>
<p><img src="architecture/irq/../../assets/vgicv2/gicv2-vm-view.png" alt="img" /></p>
<ul>
<li>从 device tree 获得 GICD、GICC base 物理地址（实际是 Hypervisor 伪造的地址）</li>
<li>配置 GICD 寄存器（实际上 trap 到 Hypervisor ，模拟地读写了内核某 struct 里的数据）</li>
<li>执行直到发生中断（中断先到 Hypervisor ，Hypervisor 在 LR 中配置了一个物理 IRQ 到 vIRQ 的映射，并且设置为 pending，回到 VM 之后 GIC 在 VM 的 EL1 触发中断）</li>
<li>读 GICC_IAR（经过 stage 2 页表翻译，实际上读了 GICV_IAR，GIC 根据 LR 返回 vIRQ 的信息，vIRQ 状态从 pending 转为 active）</li>
<li>写 GICC_EOIR、GICC_DIR（经过 stage 2 页表翻译，实际上写了 GICV_EOIR、GICV_DIR，GIC EOI 并 deactivate 对应的 vIRQ，并 deactivate vIRQ 对应的物理 IRQ）</li>
</ul>
<h2 id="vgic设计"><a class="header" href="#vgic设计">VGIC设计</a></h2>
<p>主要以以下4中case进行讨论，其中case4涉及vCPU调度，其他情况不涉及调度：</p>
<p><img src="architecture/irq/../../assets/vgicv2/vgicv2_4case.png" alt="" /></p>
<h3 id="vgic-distributor设计"><a class="header" href="#vgic-distributor设计">VGIC Distributor设计</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct VgicDist {
    ...
    nr_spis: usize,           // num of SPIs
    spis: Vec&lt;VgicIrq&gt;,       // store SPI
    dist_iodev: VgicIoDevice, // Distributor I/O设备描述符
    ....
}

impl VgicDist {
    pub fn new() {
        let nr_spis = 256; 
        let mut spis = Vec::new(); 

        // init SPI interrupt
        for _ in 0..nr_spis {
            spis.push(VgicIrq {
                ap_list: RefCell::new(LinkedList::new()),
                vcpu: Some(Box::new(Vcpu {})),
                target_vcpu: Some(Box::new(Vcpu {})),
                intid: 0,
                line_level: false,
                active: false,
                enabled: true,
            });
        }

        let dist_iodev = VgicIoDevice {  };
        VgicDist {
            nr_spis,
            spis,
            dist_iodev,
        }
    }
}

<span class="boring">}</span></code></pre></pre>
<p>VGIC Distributor 主要模拟 nr_spis 个 spis 中断</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct VgicIrq {
    /// A linked list header for managing interrupts.
    /// This is used for managing the list of interrupts associated with a VCPU.
    ap_list: RefCell&lt;LinkedList&lt;Box&lt;VgicIrq&gt;&gt;&gt;,
    
    /// For SGIs and PPIs: The VCPU that generated the interrupt.
    /// For SPIs: The VCPU whose `ap_list` this is queued on.
    vcpu: Option&lt;Box&lt;dyn VcpuTrait&gt;&gt;,
    
    /// The VCPU that this interrupt should be sent to, based on the targets register (v2)
    target_vcpu: Option&lt;Box&lt;dyn VcpuTrait&gt;&gt;,
    
    /// The guest-visible interrupt ID.
    intid: u32,
    
    /// Indicates if the interrupt is level-triggered only.
    line_level: bool,
    
    /// Not used for LPIs.
    active: bool,
    
    /// Indicates if the interrupt is enabled.
    enabled: bool,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>GIC所以只处理SPI类型的中断，原因是其它两类中断的输入就是针对特定一个CPU的，不需要Distributor控制其中断信号的deliver行为；而SPI的目标CPU，是可以用户配置的，因此需要模拟一个Distributor来控制中断deliver的目标，并将Distributor的控制接口暴露给用户。</li>
<li>target_vcpu结构用来存放用户设置的GIC中断路由信息，如果用户没有设置，那target_vcpu就使用默认的CPU0，后续GIC可能会根据负载均衡策略将中断分发到其它目标CPU上。换句话说，target_vcpu可能不是中断最终投递的CPU，只是一个初始值，而vcpu才是中断最终投递的CPU</li>
</ul>
<h3 id="vgic初始化"><a class="header" href="#vgic初始化">VGIC初始化</a></h3>
<ol>
<li>vgicd-ctrl 寄存器：</li>
</ol>
<p>​	 - 对于case 1、2 和 3，不需要 IPI 通信。case 4 需要 IPI 通信。</p>
<ol start="2">
<li>vgicd-iid 寄存器，vgicd-type 寄存器：</li>
</ol>
<p>​	 - 这些寄存器保存 GIC 的一些属性和处理元素（PE）的数量。</p>
<pre><code>- 虚拟化提供的 vgicd 应根据 VPE 的数量进行配置。
</code></pre>
<ol start="3">
<li>vgicd-isenable 寄存器：</li>
</ol>
<p>​	 - getenable：直接从结构中读取内容。</p>
<p>​	 - setenable：根据 vtop 和 ptov 设置配置 GIC。对于情况 1、2 和 3，不需要 IPI 通信。情况 4 需要 IPI 通信。</p>
<ol start="4">
<li>其他 emu 寄存器：</li>
</ol>
<p>​	 - 其他 vgicd-emu 寄存器与 isenabler 类似。</p>
<h3 id="sgi软件生成中断"><a class="header" href="#sgi软件生成中断">SGI软件生成中断</a></h3>
<p>SGI是一种特殊的中断，由软件生成，通常用于在多核系统中实现CPU间通信。SGI的目标CPU由发送者指定，并且SGI可以被路由到一个或多个核上。</p>
<p>在虚拟化环境下，由于多个vCPU可能共享同一个物理CPU，hypervisor需要对SGI进行虚拟化，以确保VM之间的隔离性和透明性。</p>
<h4 id="hypervisor对sgi的拦截"><a class="header" href="#hypervisor对sgi的拦截">Hypervisor对SGI的拦截</a></h4>
<p>在虚拟化环境中，当VM试图发送SGI时，通常通过修改guest的GIC相关寄存器来触发。VM本身无法直接访问物理的GIC Distributor（GICD）寄存器，因此这些写操作会被hypervisor拦截。</p>
<ul>
<li><strong>vCPU到vCPU的SGI</strong>：VM发送SGI给自己的vCPU或同一个VM中的其他vCPU。</li>
</ul>
<h4 id="sgi的处理与路由"><a class="header" href="#sgi的处理与路由">SGI的处理与路由</a></h4>
<p>在SGI虚拟化中，hypervisor负责以下操作：</p>
<ul>
<li><strong>拦截和解析SGI</strong>：当VM写入GICD_SGIR寄存器（用于触发SGI），hypervisor会拦截该写操作。它解析出目标vCPU以及SGI的ID。</li>
<li><strong>SGI的重定向</strong>：hypervisor根据解析出的SGI信息，将SGI重新路由到目标vCPU，这里应该有有一个接口能够根据vcpu_id注入指定的中断。
<ul>
<li>vCPU活跃：直接发送到指定的vCPU</li>
<li>vCPU休眠：唤醒vCPU后，再发送到指定vCPU</li>
</ul>
</li>
<li><strong>中断优先级和状态管理</strong>：hypervisor需要维护虚拟中断的优先级和状态（如等待、激活等），以确保VM感知到的中断行为与物理硬件一致。</li>
</ul>
<h4 id="虚拟gic的支持"><a class="header" href="#虚拟gic的支持">虚拟GIC的支持</a></h4>
<p>为了让VM能够像使用物理GIC一样处理中断，hypervisor会提供虚拟的GIC接口（vGIC）。vGIC负责模拟GICD和GICC（CPU接口）的寄存器操作，并将这些寄存器映射到VM的地址空间。</p>
<p>虚拟GIC支持VM的SGI管理，包括：</p>
<ul>
<li><strong>虚拟GICD_SGIR寄存器</strong>：VM通过这个寄存器触发SGI，hypervisor在接收到写操作后进行中断重定向。</li>
<li><strong>虚拟中断路由表</strong>：hypervisor维护一个虚拟的中断路由表List Registers，用来追踪SGI应该被路由到哪个vCPU。</li>
</ul>
<p><img src="architecture/irq/../../assets/vgicv2/case1.png" alt="" /></p>
<h3 id="ppi-私有外设中断"><a class="header" href="#ppi-私有外设中断">PPI 私有外设中断</a></h3>
<p>PPI通常用于管理特定于处理器的外设中断。在GICv2中，每个核心都有其专属的PPI，通常包括定时器中断和其他本地外设中断。在虚拟化环境中，hypervisor需要虚拟化这些中断，以便每个VM能够透明地访问和使用它们。</p>
<h5 id="vm发起ppi请求"><a class="header" href="#vm发起ppi请求">VM发起PPI请求</a></h5>
<p>当VM中的vCPU需要处理PPI时，通常是通过对GIC的寄存器进行操作。例如，vCPU可能会读取或清除某个PPI的状态，这一操作需要经过hypervisor的拦截。</p>
<h5 id="hypervisor拦截请求"><a class="header" href="#hypervisor拦截请求">Hypervisor拦截请求</a></h5>
<ul>
<li><strong>拦截操作</strong>：Hypervisor监测对PPI相关寄存器的访问请求，特别是GIC的PPI寄存器。</li>
<li><strong>解析请求</strong>：Hypervisor解析该请求以确定哪个vCPU或VM正在进行操作，并根据需要处理这些请求。</li>
</ul>
<h5 id="ppi的路由和分发"><a class="header" href="#ppi的路由和分发">PPI的路由和分发</a></h5>
<ul>
<li><strong>管理PPI状态</strong>：Hypervisor需要维护每个VM的PPI状态，确保在VM运行时，PPI的状态能够正确反映在对应的vCPU上。</li>
<li><strong>中断注入</strong>：当PPI中断发生时，hypervisor负责将中断注入到对应的vCPU中。对于PPI，hypervisor可以直接向目标vCPU发送中断请求，而不需要重定向。</li>
</ul>
<h5 id="目标vcpu处理中断"><a class="header" href="#目标vcpu处理中断">目标vCPU处理中断</a></h5>
<ul>
<li><strong>vCPU处理PPI</strong>：一旦PPI被触发，目标vCPU会进入中断处理程序，执行相应的处理逻辑。</li>
<li><strong>状态恢复</strong>：处理完成后，vCPU会清除PPI中断状态，并恢复执行状态。</li>
</ul>
<h5 id="hypervisor的清理工作"><a class="header" href="#hypervisor的清理工作">Hypervisor的清理工作</a></h5>
<ul>
<li><strong>状态管理</strong>：Hypervisor在处理完PPI中断后，负责清理中断状态和相关的寄存器，确保后续中断请求的正确性。</li>
<li><img src="architecture/irq/../../assets/vgicv2/case_ppi.png" alt="" /></li>
</ul>
<h3 id="spi-共享外设中断"><a class="header" href="#spi-共享外设中断">SPI 共享外设中断</a></h3>
<p>在虚拟化环境中，SPI（Shared Peripheral Interrupt，共享外设中断）是一种用于处理多个处理器核心共享外设的中断。与SGI和PPI不同，SPI是针对共享设备的中断，允许多个CPU响应同一外设生成的中断。hypervisor在虚拟化SPI时需要确保VM之间的隔离，同时提供对共享外设的正确中断管理。</p>
<p>SPI通常用于系统中那些可以被多个处理器访问的外设，例如网络适配器、存储控制器等。在GICv2中，SPI由GIC的Distributor（GICD）管理，允许多个处理器核接收来自同一外设的中断。在虚拟化环境中，hypervisor需要将SPI虚拟化为适合多个VM使用的形式。</p>
<h5 id="vm发起spi请求"><a class="header" href="#vm发起spi请求">VM发起SPI请求</a></h5>
<p>当外设生成中断时，它将通过物理GIC将SPI传递给相应的处理器核心。在虚拟化环境中，物理中断首先会传递到hypervisor。</p>
<h5 id="hypervisor的拦截和管理"><a class="header" href="#hypervisor的拦截和管理">Hypervisor的拦截和管理</a></h5>
<ul>
<li><strong>拦截中断</strong>：Hypervisor拦截来自外设的SPI请求，并识别该中断的目标VM（如果已映射）。</li>
<li><strong>中断映射</strong>：Hypervisor维护一个中断映射表，将物理中断与VM中的虚拟中断进行关联。</li>
</ul>
<h5 id="spi的路由和重定向"><a class="header" href="#spi的路由和重定向">SPI的路由和重定向</a></h5>
<ul>
<li><strong>目标VM识别</strong>：Hypervisor通过中断映射表确定SPI应该路由到哪个VM的vCPU。</li>
<li><strong>中断注入</strong>：Hypervisor将SPI注入到目标VM的对应vCPU中，以触发中断处理。</li>
</ul>
<h5 id="目标vcpu处理中断-1"><a class="header" href="#目标vcpu处理中断-1">目标vCPU处理中断</a></h5>
<ul>
<li><strong>处理SPI中断</strong>：目标vCPU接收到中断请求后，执行相应的中断处理程序。此过程包括保存上下文、执行处理逻辑以及清除中断状态。</li>
<li><strong>状态恢复</strong>：处理完成后，vCPU需要恢复到正常执行状态，并清除中断标志。</li>
</ul>
<h5 id="hypervisor的清理工作-1"><a class="header" href="#hypervisor的清理工作-1">Hypervisor的清理工作</a></h5>
<ul>
<li><strong>状态更新</strong>：Hypervisor在处理完SPI中断后，更新中断的状态，以反映当前的处理中断情况。</li>
</ul>
<p><img src="architecture/irq/../../assets/vgicv2/case4.png" alt="" /></p>
<h4 id="list-register"><a class="header" href="#list-register">List Register</a></h4>
<p><img src="architecture/irq/../../assets/vgicv2/lr.png" alt="img" /></p>
<p>对于有虚拟化扩展的 GIC，Hypervisor使用 List Registers 来维护高优先级虚拟中断的一些上下文信息。</p>
<pre><code class="language-c">struct gich_lr {
    uint32_t vid : 10;  // virq 中断号
    uint32_t pid : 10;  // 此 field 根据 hw 值不同而不同
                        // hw=1，表示此虚拟中断关联了一个物理中断，此 pid 为实际的 physical irq 中断号
                        // hw=0，bit19表示是否 signal eoi，给 maintenance interrupt 使用，不做讨论
                                 //bit12-10，如果这是一个 sgi 中断，即 virtual interrupt id &lt; 15，那么此位域表示 requesting cpu id

    uint32_t resv : 3;  // 保留
    uint32_t pr : 5;    // 该virtual integrrupt 的优先级
    uint32_t state : 2; // 指示该中断的状态，invalid、pending、active、pending and active
    uint32_t grp1 : 1;  // 表示该 virtual integrrupt 是否是 group 1 virtual integrrupt
                        // 0 表示这是一个 group 0 virtual interrupt，表示安全虚拟中断，可配置是按照 virq 还是 vfiq 发送给 vcpu
                        // 1 表示这是一个 group 1 virtual interrupt，表示非安全虚拟中断，该中断以 virq 的形式触发，而不是 vfiq

    uint32_t hw : 1;    // 该虚拟中断是否关联了一个硬件物理中断
                        // 0 表示否，这是 triggered in software，当 deactivated 的时候不会通知 distributor
                        // 1 表示是，那么 deactivate 这个虚拟中断也会向对应的物理中断也执行 deactivate 操作
                        // 而具体的 deactivate 操作，如果 gicv_ctlr.eoimode=0，写 gicv_eoir 寄存器表示 drop priority 和 deactive 操作同时进行 
                        // 如果 gicv_ctlr.eoimode=1，写 gicv_eoir 寄存器表示 drop priority，写 GICV_DIR 表示 deactive
};
</code></pre>
<h3 id="vgic-寄存器虚拟化"><a class="header" href="#vgic-寄存器虚拟化">VGIC 寄存器虚拟化</a></h3>
<p>有的寄存器是单个32位长，有的寄存器是多个32位长，所以使用宏来定义各个寄存器，提供直观的访问方式</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Macro to define GIC register enums
macro_rules! generate_gic_registers {
    (
        // Single register definitions
        singles {
            $(
                $single_name:ident = $single_offset:expr // Single register name and offset
            ),* $(,)?
        }
        // Range register definitions
        ranges {
            $(
                $range_name:ident = {
                    offset: $range_offset:expr, // Range register base offset
                    size: $range_size:expr // Number of registers in the range
                }
            ),* $(,)?
        }
    ) =&gt; {
        #[derive(Debug, Clone, Copy, PartialEq)]
        pub enum GicRegister {
            // Generate single register variants
            $(
                $single_name, // Single register variant
            )*
            // Generate range register variants (with index)
            $(
                $range_name(u32), // Range register variant with index
            )*
        }

        impl GicRegister {

            // Convert address to register enum
            pub fn from_addr(addr: u32) -&gt; Option&lt;Self&gt; {
                match addr {
                    // Match single registers
                    $(
                        addr if addr == $single_offset =&gt; Some(Self::$single_name), // Single register match
                    )*
                    // Match range registers
                    $(
                        addr if addr &gt;= $range_offset &amp;&amp; addr &lt; $range_offset + ($range_size * 4) =&gt; {
                            let idx = (addr - $range_offset) / 4; // Calculate index
                            if idx &lt; $range_size {
                                Some(Self::$range_name(idx)) // Range register match
                            } else {
                                None
                            }
                        },
                    )*
                    _ =&gt; None, // No match
                }
            }
        }
    };
}

// Use the macro to generate specific register definitions
generate_gic_registers! {
    singles {
        // Distributor Control Register
        GicdCtlr = 0x0000,
        // Distributor Type Register
        GicdTyper = 0x0004,
        // Distributor Implementer Identification Register
        GicdIidr = 0x0008,
        // Distributor Status Register
        GicdStatusr = 0x0010,
    }
    ranges {
        // Interrupt Group Register
        GicdIgroupr = {
            offset: 0x0080,
            size: 32
        },
        // Interrupt Enable Set Register
        GicdIsenabler = {
            offset: 0x0100,
            size: 32
        },
        // Interrupt Enable Clear Register
        GicdIcenabler = {
            offset: 0x0180,
            size: 32
        },
        // Interrupt Pending Set Register
        GicdIspendr = {
            offset: 0x0200,
            size: 32
        },
        GicdIcpendr = {
            offset: 0x0280,
            size: 32
        },
        // Interrupt Active Set Register
        GicdIsactiver = {
            offset: 0x0300,
            size: 32
        },
        // Interrupt Active Clear Register
        GicdIcactiver = {
            offset: 0x0380,
            size: 32
        },
        // Interrupt Priority Register
        GicdIpriorityr = {
            offset: 0x0400,
            size: 256
        },
        // Interrupt Target Register
        GicdItargetsr = {
            offset: 0x0800,
            size: 256
        },
        // Interrupt Configuration Register
        GicdIcfgr = {
            offset: 0x0c00,
            size: 64
        },
        // PPI Status Register
        GicdPpisr = {
            offset: 0x0d00,
            size: 32
        },
        // SPI Status Register
        GicdSpisr = {
            offset: 0x0d04,
            size: 32
        },
        // Non-Secure Access Control Register
        GicdNsacr = {
            offset: 0x0e00,
            size: 32
        },
        // Software Generated Interrupt Register
        GicdSgir = {
            offset: 0x0f00,
            size: 32
        },
        // Pending Software Generated Interrupt Register
        GicdCpendsgir = {
            offset: 0x0f10,
            size: 32
        },
        // Software Generated Interrupt Pending Register
        GicdSpendsgir = {
            offset: 0x0f20,
            size: 32
        },
    }
}

// 访问寄存器的方法
match GicRegister::from_addr(addr as u32) {
    Some(reg) =&gt; match reg {
        GicRegister::GicdCtlr =&gt; Ok(self.vgicd.lock().ctrlr as usize),
        GicRegister::GicdTyper =&gt; Ok(self.vgicd.lock().typer as usize),
        GicRegister::GicdIidr =&gt; Ok(self.vgicd.lock().iidr as usize),
        GicRegister::GicdStatusr =&gt; self.read_statusr(),
        GicRegister::GicdIgroupr(idx) =&gt; self.read_igroupr(idx),
        GicRegister::GicdIsenabler(idx) =&gt; Ok(self.vgicd.lock().vgicd_isenabler_read(idx)),
        GicRegister::GicdIcenabler(idx) =&gt; self.read_icenabler(idx),
        GicRegister::GicdIspendr(idx) =&gt; self.read_ispendr(idx),
        _ =&gt; {
            error!("Read register address: {addr:#x}");
        }
    },
    None =&gt; {
        error!("Invalid read register address: {addr:#x}");
    }
}

<span class="boring">}</span></code></pre></pre>
<h3 id="kvm关于vgic的设计"><a class="header" href="#kvm关于vgic的设计">KVM关于VGIC的设计</a></h3>
<pre><code class="language-c">kvm_vm_ioctl
	kvm_vm_ioctl_irq_line
	    irq_type = (irq &gt;&gt; KVM_ARM_IRQ_TYPE_SHIFT) &amp; KVM_ARM_IRQ_TYPE_MASK;	/* SPI 类型 */
    	vcpu_idx = (irq &gt;&gt; KVM_ARM_IRQ_VCPU_SHIFT) &amp; KVM_ARM_IRQ_VCPU_MASK;	/* vcpu_idx: 0*/
    	irq_num = (irq &gt;&gt; KVM_ARM_IRQ_NUM_SHIFT) &amp; KVM_ARM_IRQ_NUM_MASK;		/* 中断号：32+7 = 39 */
    	
   	case KVM_ARM_IRQ_TYPE_CPU:	/* 发往特定CPU上的快速中断 */
        if (irqchip_in_kernel(kvm))
            return -ENXIO;

        if (vcpu_idx &gt;= nrcpus)
            return -EINVAL;

        vcpu = kvm_get_vcpu(kvm, vcpu_idx);	/* 根据cpuid取出vcpu结构体*/
        if (!vcpu)
            return -EINVAL;

        if (irq_num &gt; KVM_ARM_IRQ_CPU_FIQ)
            return -EINVAL;
		/* 立即投递到cpu的中断状态字段，然后kick cpu进行处理
		 * 由于是快速中断，KVM直接更新的irq_lines字段，没有将中断信号放到vgic_cpu的ap_list上排队
		 */
        return vcpu_interrupt_line(vcpu, irq_num, level);		
    case KVM_ARM_IRQ_TYPE_PPI:	/* CPU私有类型的中断 */
        if (!irqchip_in_kernel(kvm))
            return -ENXIO;

        if (vcpu_idx &gt;= nrcpus)
            return -EINVAL;

        vcpu = kvm_get_vcpu(kvm, vcpu_idx);	/* 根据cpuid取出vcpu结构体 */
        if (!vcpu)
            return -EINVAL;

        if (irq_num &lt; VGIC_NR_SGIS || irq_num &gt;= VGIC_NR_PRIVATE_IRQS)
            return -EINVAL;
		/* 非快速中断，取出目的vcpu后，将中断信号放到vcpu的ap_list字段排队，等待vcpu处理 */
        return kvm_vgic_inject_irq(kvm, vcpu-&gt;vcpu_id, irq_num, level, NULL);	
    case KVM_ARM_IRQ_TYPE_SPI:
        if (!irqchip_in_kernel(kvm))
            return -ENXIO;

        if (irq_num &lt; VGIC_NR_PRIVATE_IRQS)
            return -EINVAL;
		/* 非快速中断，SPI默认发送vcpu 0上，同样将中断信号放到vcpu的ap_list字段排队，等待vcpu处理 */
        return kvm_vgic_inject_irq(kvm, 0, irq_num, level, NULL);
    }

```&lt;style&gt;.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }&lt;/style&gt;&lt;button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"&gt; &lt;i class="fa fa-angle-up"&gt;&lt;/i&gt;&lt;/button&gt;&lt;script&gt;const scrollToTop = () =&gt; window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () =&gt; { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY &lt;200); });&lt;/script&gt;&lt;style&gt;.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }&lt;/style&gt;&lt;div style="display: none" data-id="0.2.11" class="announcement-banner"&gt; &lt;p&gt;&lt;em&gt;正在逐步完善中。。。&lt;/em&gt;&lt;/p&gt; &lt;button type="button" data-close&gt;X&lt;/button&gt;&lt;/div&gt;&lt;script&gt;(() =&gt; { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () =&gt; { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();&lt;/script&gt;&lt;style&gt;.giscus { margin-top: 6rem; }&lt;/style&gt;&lt;script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async&gt;&lt;/script&gt;&lt;script&gt;(() =&gt; { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) =&gt; (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) =&gt; { btn.addEventListener("click", (event) =&gt; { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();&lt;/script&gt;&lt;style&gt;footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }&lt;/style&gt;&lt;footer&gt;&lt;p&gt;Copyright © 2025 • Created by ArceOS Team&lt;/p&gt;&lt;/footer&gt;</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="虚拟-local-apic"><a class="header" href="#虚拟-local-apic">虚拟 Local APIC</a></h1>
<p>本节描述了虚拟 Local APIC 的实现。</p>
<h2 id="全虚拟化"><a class="header" href="#全虚拟化">全虚拟化</a></h2>
<h3 id="寄存器虚拟化"><a class="header" href="#寄存器虚拟化">寄存器虚拟化：</a></h3>
<p>Local APIC 的寄存器通过内存映射（MMIO）访问。虚拟机对 APIC 寄存器的读写会触发 VM-exit，由虚拟化层（如 VMM/Hypervisor）模拟这些操作，维护每个虚拟 CPU（vCPU）的虚拟寄存器状态。</p>
<h3 id="中断注入"><a class="header" href="#中断注入">中断注入：</a></h3>
<p>当物理中断需要传递给虚拟机时，虚拟化层将其转换为虚拟中断（如虚拟 IRQ），并通过修改虚拟 APIC 的状态（如 IRR/ISR 寄存器）或直接注入中断（如 Intel 的 vmcs VM_ENTRY_INTR_INFO）通知虚拟机。</p>
<h3 id="定时器虚拟化"><a class="header" href="#定时器虚拟化">定时器虚拟化：</a></h3>
<p>虚拟 APIC 定时器需根据虚拟机的配置（如周期和计数）模拟中断。Hypervisor 可能使用物理定时器（如 host 的 hrtimer）或时间偏移技术来触发虚拟中断。</p>
<h2 id="硬件辅助虚拟化"><a class="header" href="#硬件辅助虚拟化">硬件辅助虚拟化</a></h2>
<p>现代 CPU（如 Intel VT-x 和 AMD-V）提供了硬件加速特性，显著优化性能：</p>
<h3 id="apicvintel--avicamd"><a class="header" href="#apicvintel--avicamd">APICv（Intel） / AVIC（AMD）：</a></h3>
<p>硬件直接支持虚拟 APIC 状态维护，减少 VM-exit。例如：</p>
<ul>
<li>
<p>Virtual APIC Page：在 VMCS 中维护虚拟 APIC 的寄存器，允许虚拟机直接访问，无需陷入。</p>
</li>
<li>
<p>中断投递优化：硬件自动将中断路由到目标 vCPU 的虚拟 APIC。</p>
</li>
<li>
<p>自动处理 EOI：某些中断的确认（EOI）由硬件处理，避免 VM-exit。</p>
</li>
</ul>
<h3 id="posted-interruptsintel"><a class="header" href="#posted-interruptsintel">Posted Interrupts（Intel）：</a></h3>
<ul>
<li>物理中断可直接“投递”到虚拟机的虚拟 APIC，绕过 Hypervisor 干预，极大降低延迟。</li>
</ul>
<h2 id="具体实现"><a class="header" href="#具体实现">具体实现</a></h2>
<p>代码位于 <a href="https://github.com/arceos-hypervisor/x86_vlapic">x86-vlapic</a></p>
<p><code>EmulatedLocalApic</code> 实现了虚拟中断的基本方法，通过 <code>handle_read</code> <code>handle_write</code> 实现读写虚拟中断寄存器的功能。</p>
<p><code>VirtualApicRegs</code> 包含了 <code>APIC</code> 所有寄存器，保存客户机虚拟中断的寄存器状态</p>
<h3 id="local-apic-寄存器"><a class="header" href="#local-apic-寄存器">Local APIC 寄存器</a></h3>
<p>本地APIC寄存器被内存映射到MP/MADT表中可找到的地址。若使用分页，请确保将这些寄存器映射到虚拟内存。每个寄存器均为32位长，并期望以32位整数形式进行读写。尽管每个寄存器占用4个字节，但它们都按16字节边界对齐。
本地APIC寄存器列表（待办事项：为所有寄存器添加描述）：</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>register_structs! {
    #[allow(non_snake_case)]
    pub LocalAPICRegs {
        (0x00 =&gt; _reserved0),
        /// Local APIC ID register (VID): the 32-bit field located at offset 000H on the virtual-APIC page.
        (0x20 =&gt; pub ID: ReadWrite&lt;u32&gt;),
        (0x24 =&gt; _reserved1),
        /// Local APIC Version register (VVER): the 32-bit field located at offset 030H on the virtual-APIC page.
        (0x30 =&gt; pub VERSION: ReadOnly&lt;u32&gt;),
        (0x34 =&gt; _reserved2),
        /// Virtual task-priority register (VTPR): the 32-bit field located at offset 080H on the virtual-APIC page.
        (0x80 =&gt; pub TPR: ReadWrite&lt;u32&gt;),
        (0x84 =&gt; _reserved3),
        /// Virtual APIC-priority register (VAPR): the 32-bit field located at offset 090H on the virtual-APIC page.
        (0x90 =&gt; pub APR: ReadOnly&lt;u32&gt;),
        (0x94 =&gt; _reserved4),
        /// Virtual processor-priority register (VPPR): the 32-bit field located at offset 0A0H on the virtual-APIC page.
        (0xA0 =&gt; pub PPR: ReadOnly&lt;u32&gt;),
        (0xA4 =&gt; _reserved5),
        /// Virtual end-of-interrupt register (VEOI): the 32-bit field located at offset 0B0H on the virtual-APIC page.
        (0xB0 =&gt; pub EOI: WriteOnly&lt;u32&gt;),
        (0xB4 =&gt; _reserved6),
        /// Virtual Remote Read Register (RRD): the 32-bit field located at offset 0C0H on the virtual-APIC page.
        (0xC0 =&gt; pub RRD: ReadOnly&lt;u32&gt;),
        (0xC4 =&gt; _reserved7),
        /// Virtual Logical Destination Register (LDR): the 32-bit field located at offset 0D0H on the virtual-APIC page.
        (0xD0 =&gt; pub LDR: ReadWrite&lt;u32&gt;),
        (0xD4 =&gt; _reserved8),
        /// Virtual Destination Format Register (DFR): the 32-bit field located at offset 0E0H on the virtual-APIC page.
        (0xE0 =&gt; pub DFR: ReadWrite&lt;u32&gt;),
        (0xE4 =&gt; _reserved9),
        /// Virtual Spurious Interrupt Vector Register (SVR): the 32-bit field located at offset 0F0H on the virtual-APIC page.
        (0xF0 =&gt; pub SVR: SpuriousInterruptVectorRegisterMmio),
        (0xF4 =&gt; _reserved10),
        /// Virtual interrupt-service register (VISR):
        /// the 256-bit value comprising eight non-contiguous 32-bit fields at offsets
        /// 100H, 110H, 120H, 130H, 140H, 150H, 160H, and 170H on the virtual-APIC page.
        (0x100 =&gt; pub ISR: [ReadOnly&lt;u128&gt;; 8]),
        /// Virtual trigger-mode register (VTMR):
        /// the 256-bit value comprising eight non-contiguous 32-bit fields at offsets
        /// 180H, 190H, 1A0H, 1B0H, 1C0H, 1D0H, 1E0H, and 1F0H on the virtual-APIC page.
        (0x180 =&gt; pub TMR: [ReadOnly&lt;u128&gt;; 8]),
        /// Virtual interrupt-request register (VIRR):
        /// the 256-bit value comprising eight non-contiguous 32-bit fields at offsets
        /// 200H, 210H, 220H, 230H, 240H, 250H, 260H, and 270H on the virtual-APIC page.
        /// Bit x of the VIRR is at bit position (x &amp; 1FH) at offset (200H | ((x &amp; E0H) » 1)).
        /// The processor uses only the low 4 bytes of each of the 16-Byte fields at offsets 200H, 210H, 220H, 230H, 240H, 250H, 260H, and 270H.
        (0x200 =&gt; pub IRR: [ReadOnly&lt;u128&gt;; 8]),
        /// Virtual error-status register (VESR): the 32-bit field located at offset 280H on the virtual-APIC page.
        (0x280 =&gt; pub ESR: ReadWrite&lt;u32&gt;),
        (0x284 =&gt; _reserved11),
        /// Virtual LVT Corrected Machine Check Interrupt (CMCI) Register
        (0x2F0 =&gt; pub LVT_CMCI: LvtCmciRegisterMmio),
        (0x2F4 =&gt; _reserved12),
        /// Virtual Interrupt Command Register (ICR): the 64-bit field located at offset 300H on the virtual-APIC page.
        (0x300 =&gt; pub ICR_LO: ReadWrite&lt;u32&gt;),
        (0x304 =&gt; _reserved13),
        (0x310 =&gt; pub ICR_HI: ReadWrite&lt;u32&gt;),
        (0x314 =&gt; _reserved14),
        /// Virtual LVT Timer Register: the 32-bit field located at offset 320H on the virtual-APIC page.
        (0x320 =&gt; pub LVT_TIMER: LvtTimerRegisterMmio),
        (0x324 =&gt; _reserved15),
        /// Virtual LVT Thermal Sensor register: the 32-bit field located at offset 330H on the virtual-APIC page.
        (0x330 =&gt; pub LVT_THERMAL: LvtThermalMonitorRegisterMmio),
        (0x334 =&gt; _reserved16),
        /// Virtual LVT Performance Monitoring Counters register: the 32-bit field located at offset 340H on the virtual-APIC page.
        (0x340 =&gt; pub LVT_PMI: LvtPerformanceCounterRegisterMmio),
        (0x344 =&gt; _reserved17),
        /// Virtual LVT LINT0 register: the 32-bit field located at offset 350H on the virtual-APIC page.
        (0x350 =&gt; pub LVT_LINT0: LvtLint0RegisterMmio),
        (0x354 =&gt; _reserved18),
        /// Virtual LVT LINT1 register: the 32-bit field located at offset 360H on the virtual-APIC page.
        (0x360 =&gt; pub LVT_LINT1: LvtLint1RegisterMmio),
        (0x364 =&gt; _reserved19),
        /// Virtual LVT Error register: the 32-bit field located at offset 370H on the virtual-APIC page.
        (0x370 =&gt; pub LVT_ERROR: LvtErrorRegisterMmio),
        (0x374 =&gt; _reserved20),
        /// Virtual Initial Count Register (for Timer): the 32-bit field located at offset 380H on the virtual-APIC page.
        (0x380 =&gt; pub ICR_TIMER: ReadWrite&lt;u32&gt;),
        (0x384 =&gt; _reserved21),
        /// Virtual Current Count Register (for Timer): the 32-bit field located at offset 390H on the virtual-APIC page.
        (0x390 =&gt; pub CCR_TIMER: ReadOnly&lt;u32&gt;),
        (0x394 =&gt; _reserved22),
        /// Virtual Divide Configuration Register (for Timer): the 32-bit field located at offset 3E0H on the virtual-APIC page.
        (0x3E0 =&gt; pub DCR_TIMER: ReadWrite&lt;u32&gt;),
        (0x3E4 =&gt; _reserved23),
        /// Virtual SELF IPI Register: the 32-bit field located at offset 3F0H on the virtual-APIC page.
        (0x3F0 =&gt; pub SELF_IPI: WriteOnly&lt;u32&gt;),
        (0x3F4 =&gt; _reserved24),
        (0x1000 =&gt; @END),
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="eoi-寄存器"><a class="header" href="#eoi-寄存器">EOI 寄存器</a></h3>
<p>使用值0向偏移量为0xB0的寄存器写入，以信号通知中断结束。使用非零值可能会导致通用保护故障。</p>
<h3 id="local-vector-table-寄存器"><a class="header" href="#local-vector-table-寄存器">Local Vector Table 寄存器</a></h3>
<p>处理器和LAPIC自身可以生成一些特殊的中断。虽然外部中断是在I/O APIC中配置的，但这些中断必须使用LAPIC中的寄存器进行配置。最有趣的寄存器包括：0x320 = LAPIC定时器，0x350 = LINT0，0x360 = LINT1。更多详情请参见 <code>Intel SDM vol 3</code>。</p>
<p>寄存器格式：</p>
<div class="table-wrapper"><table><thead><tr><th>位范围</th><th>描述</th></tr></thead><tbody>
<tr><td>0-7</td><td>向量编号</td></tr>
<tr><td>8-10（定时器保留）</td><td>如果是NMI则为100b</td></tr>
<tr><td>11</td><td>保留</td></tr>
<tr><td>12</td><td>如果中断挂起则设置</td></tr>
<tr><td>13（定时器保留）</td><td>极性，设置为低电平触发</td></tr>
<tr><td>14（定时器保留）</td><td>远程IRR</td></tr>
<tr><td>15（定时器保留）</td><td>触发模式，设置为电平触发</td></tr>
<tr><td>16</td><td>设置以屏蔽</td></tr>
<tr><td>17-31</td><td>保留</td></tr>
</tbody></table>
</div>
<h3 id="spurious-interrupt-vector-寄存器"><a class="header" href="#spurious-interrupt-vector-寄存器">Spurious Interrupt Vector 寄存器</a></h3>
<p>偏移量是0xF0。低字节包含伪中断的编号。如上所述，您应该将此设置为0xFF。要启用APIC，请设置此寄存器的第8位（或0x100）。如果设置了第12位，则EOI消息不会被广播。其余的所有位目前都是保留的。</p>
<h3 id="interrupt-command-寄存器-icr"><a class="header" href="#interrupt-command-寄存器-icr">Interrupt Command 寄存器 (ICR)</a></h3>
<p>中断命令寄存器由两个32位寄存器组成；一个位于0x300，另一个位于0x310。它用于向不同的处理器发送中断。中断是在0x300被写入时发出的，而不是在0x310被写入时发出的。因此，要发送中断命令，应该首先写入0x310，然后写入0x300。在0x310处有一个位于位24-27的字段，它是目标处理器的本地APIC ID（针对物理目的地模式）。这里是0x300的结构：</p>
<div class="table-wrapper"><table><thead><tr><th>位范围</th><th>描述</th></tr></thead><tbody>
<tr><td>0-7</td><td>向量编号，或SIPI的起始页号</td></tr>
<tr><td>8-10</td><td>交付模式。0表示正常，1表示最低优先级，2表示SMI，4表示NMI，5可以是INIT或INIT级别解除，6表示SIPI</td></tr>
<tr><td>11</td><td>目的地模式。清除表示物理目的地，或者设置表示逻辑目的地。如果该位被清除，则0x310中的目的地字段被视为正常处理</td></tr>
<tr><td>12</td><td>交付状态。当中断被目标接受时清除。通常应在发送中断后等待此位清除</td></tr>
<tr><td>13</td><td>保留</td></tr>
<tr><td>14</td><td>清除表示INIT级别解除，否则设置</td></tr>
<tr><td>15</td><td>设置表示INIT级别解除，否则清除</td></tr>
<tr><td>18-19</td><td>目的地类型。如果&gt;0，则忽略0x310中的目的地字段。1总是发送中断给自己，2发送给所有处理器，3发送给除当前处理器外的所有处理器。最好避免使用模式1、2和3，并坚持使用0</td></tr>
<tr><td>20-31</td><td>保留</td></tr>
</tbody></table>
</div><style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () => window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () => { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY <200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() => { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () => { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() => { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) => (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) => { btn.addEventListener("click", (event) => { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="设备直通device-passthrough"><a class="header" href="#设备直通device-passthrough">设备直通（Device Passthrough）</a></h1>
<p>设备直通是一种高级虚拟化技术，允许虚拟机（VM）直接访问和控制物理硬件设备。它本质上是一种特殊的设备模拟方式，其特点是将物理设备完全隔离并独占分配给特定虚拟机使用。这种技术绕过了虚拟化层的常规设备模拟过程，提供了接近原生硬件的性能表现。</p>
<h2 id="核心优势"><a class="header" href="#核心优势">核心优势</a></h2>
<ul>
<li>接近原生性能：直通设备几乎能提供与裸机系统相同的性能表现，尤其适用于I/O密集型设备</li>
<li>低延迟响应：最小化了虚拟化层引入的额外延迟，关键应用场景如高性能计算、实时数据处理等尤为重要</li>
<li>功能完整性：虚拟机可访问设备的全部功能集，不受虚拟化层功能模拟的限制</li>
<li>硬件加速：允许使用特定硬件的加速功能（如GPU计算、网卡卸载等）</li>
</ul>
<h2 id="技术实现机制"><a class="header" href="#技术实现机制">技术实现机制</a></h2>
<p>设备直通技术主要依赖于以下关键技术：</p>
<ul>
<li>IOMMU（I/O内存管理单元）：负责虚拟机I/O地址到物理地址的转换，保障安全隔离</li>
<li>中断重映射：将设备中断正确路由到对应的虚拟机</li>
<li>DMA重映射：确保设备的直接内存访问操作被正确限制在虚拟机的内存空间内</li>
</ul>
<h2 id="axvisor设备直通配置解析"><a class="header" href="#axvisor设备直通配置解析">axvisor设备直通配置解析</a></h2>
<p>以下是<a href="https://github.com/arceos-hypervisor/axvisor">Axvisor</a>在ARM平台上基于QEMU架构实现的设备直通配置示例：</p>
<pre><code>Pass-through devices.
# Name Base-Ipa Base-Pa Length Alloc-Irq.
passthrough_devices = [
    ["intc@8000000", 0x800_0000, 0x800_0000, 0x50_000, 0x1],
    ["pl011@9000000", 0x900_0000, 0x904_0000, 0x1000, 0x1],
    ["pl031@9010000", 0x901_0000, 0x901_0000, 0x1000, 0x1],
    ["pl061@9030000", 0x903_0000, 0x903_0000, 0x1000, 0x1],
    ["virtio_mmio", 0xa00_0000, 0xa00_0000, 0x4000, 0x1],
]
</code></pre>
<p><strong>配置参数详解</strong></p>
<p>每个设备条目包含5个关键参数：</p>
<ul>
<li>设备标识符（Name）：唯一标识直通设备，通常包含设备类型和基址信息</li>
<li>中间物理地址（Base-Ipa）：虚拟机内部看到的设备基址，用于VM内部的内存映射</li>
<li>物理地址（Base-Pa）：设备在宿主机上的实际物理内存地址</li>
<li>映射长度（Length）：设备内存映射区域的大小，以字节为单位</li>
<li>中断分配标志（Alloc-Irq）：控制是否为该设备分配中断资源（1=启用，0=禁用）</li>
</ul>
<p><strong>示例中的直通设备详情</strong></p>
<div class="table-wrapper"><table><thead><tr><th>设备名称</th><th>功能描述</th><th>技术特点</th></tr></thead><tbody>
<tr><td><code>intc@8000000</code></td><td>中断控制器</td><td>管理系统中断，允许VM直接处理硬件中断事件</td></tr>
<tr><td><code>pl011@9000000</code></td><td>PL011 UART串口控制器</td><td>提供串行通信能力，常用于调试和控制台访问</td></tr>
<tr><td><code>pl031@9010000</code></td><td>PL031实时时钟(RTC)</td><td>提供精确的时间功能，确保VM时间准确性</td></tr>
<tr><td><code>pl061@9030000</code></td><td>PL061 GPIO控制器</td><td>管理通用输入/输出接口，用于控制外部设备</td></tr>
<tr><td><code>virtio_mmio</code></td><td>VirtIO内存映射I/O设备</td><td>提供高效的半虚拟化I/O接口，平衡性能与兼容性</td></tr>
</tbody></table>
</div>
<p>设备直通是构建高性能虚拟化环境的关键组件，可以实现在保持虚拟化灵活性的同时，提供接近于物理机的性能。<style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () =&gt; window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () =&gt; { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY &lt;200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() =&gt; { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () =&gt; { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() =&gt; { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) =&gt; (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) =&gt; { btn.addEventListener("click", (event) =&gt; { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer></p>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li><a href="https://github.com/arceos-hypervisor/axdevice">axdevice</a> 是 ArceOS 的一个模块，提供设备仿真支持
<ul>
<li>部分架构独立</li>
<li>不同的仿真设备实现需要被分离到独立的 crate 中
<ul>
<li><a href="https://github.com/arceos-hypervisor/x86_vlapic">x86_vlapic</a></li>
<li><a href="https://github.com/arceos-hypervisor/arm_vgic">arm_vgic</a> (v2,v3,v4)</li>
<li>riscv_vplic</li>
<li>virtio-blk</li>
<li>virtio-net</li>
<li>...</li>
</ul>
</li>
</ul>
</li>
</ul>
<style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () => window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () => { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY <200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() => { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () => { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() => { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) => (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) => { btn.addEventListener("click", (event) => { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="pci"><a class="header" href="#pci">PCI</a></h1>
<p>PCI（外设组件互连）是一种广泛使用的设备总线标准，用于连接计算机的外设（如网卡、显卡等）与系统通信。CPU可以通过load/store指令来访问PCI设备，PCI设备有如下三种不同内存：</p>
<ul>
<li>MMIO</li>
<li>PCI IO space</li>
<li>PCI configuration space</li>
</ul>
<p>配置一个PCI设备通常需要对其BAR（Base Address Register）进行配置并启用设备，遍历每个BAR，检查BAR的内存类型并分配地址，<code>root.bar_info(bdf, bar)</code>调用返回一个关于指定设备和BAR的详细信息。从分配器申请地址，根据BAR类型（32位或64位）调用<code>set_bar_32</code> 或 <code>set_bar_64</code>。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let info = root.bar_info(bdf, bar).unwrap(); // 获取BAR元数据
if let BarInfo::Memory { address_type, address, size, .. } = info {
    if size &gt; 0 &amp;&amp; address == 0 { // 需要分配的未初始化BAR
        let new_addr = allocator
            .as_mut()
            .expect("No memory ranges available for PCI BARs!")
            .alloc(size as _)
            .ok_or(DevError::NoMemory)?;

        if address_type == MemoryBarType::Width32 {
            root.set_bar_32(bdf, bar, new_addr as _);
        } else if address_type == MemoryBarType::Width64 {
            root.set_bar_64(bdf, bar, new_addr);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>检查当前BAR是否占用两个条目，若当前BAR是64位类型，则需递增<code>bar</code>两次，跳过下一个索引。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>bar += 1;
if info.takes_two_entries() {
    bar += 1;
}
<span class="boring">}</span></code></pre></pre>
<p>启用设备的IO/内存访问及总线主控</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (_status, cmd) = root.get_status_command(bdf);
  root.set_command(
    bdf,
    cmd | Command::IO_SPACE | Command::MEMORY_SPACE | Command::BUS_MASTER,
  );
<span class="boring">}</span></code></pre></pre>
<p><strong>命令寄存器设置</strong>：</p>
<ul>
<li><strong>IO_SPACE</strong>: 允许设备响应IO端口访问。</li>
<li><strong>MEMORY_SPACE</strong>: 允许设备响应内存映射访问。</li>
<li><strong>BUS_MASTER</strong>: 启用设备作为总线主设备。</li>
</ul>
<h1 id="emulated-pci"><a class="header" href="#emulated-pci">Emulated PCI</a></h1>
<p>设备的虚拟化是通过模拟（Emulation）和直通（Passthrough）技术来实现的。</p>
<p>Emulated PCI正是通过软件模拟PCI设备实现的，这些虚拟设备与真实的硬件PCI设备类似，但并非直接依赖Hardware Devices的支持，而是通过Hypervisor层来模拟和管理，用于在虚拟化环境中为VM提供对物理PCI设备的访问能力。</p>
<div align="center">
<img src="architecture/device/../../assets/vpci.png" width="75%">
</div>
<h3 id="guest-vm层"><a class="header" href="#guest-vm层"><strong>Guest VM层</strong></a></h3>
<ul>
<li>虚拟PCI设备驱动，Guest VM认为存在真实PCI设备，通过标准PCI驱动发起I/O请求。</li>
</ul>
<h3 id="hypervisor层"><a class="header" href="#hypervisor层">Hypervisor层</a></h3>
<ul>
<li><strong>虚拟PCI总线（Virtual PCI Bus）</strong>
<ul>
<li>模拟PCI总线拓扑结构，管理虚拟设备的配置空间。</li>
<li>实现PCI枚举过程，向Guest OS暴露虚拟设备列表。</li>
</ul>
</li>
<li><strong>PCI设备模型（Device Model）</strong>
<ul>
<li><strong>寄存器模拟</strong>：对设备寄存器的读写操作进行拦截和模拟。</li>
<li><strong>DMA模拟</strong>：通过虚拟地址转换（GPA→HPA）处理Guest发起的DMA操作。</li>
<li><strong>中断模拟</strong>：将虚拟设备中断映射为虚拟中断。</li>
</ul>
</li>
</ul>
<h3 id="host-os--hardware层"><a class="header" href="#host-os--hardware层">Host OS &amp; Hardware层</a></h3>
<ul>
<li>物理资源交互，对于纯软件模拟设备，由Host用户态程序处理I/O请求。</li>
</ul>
<h2 id="核心机制"><a class="header" href="#核心机制">核心机制</a></h2>
<ul>
<li>
<p><strong>配置空间模拟</strong></p>
<p>PCI设备通过配置空间定义其资源需求（如I/O端口、内存映射地址等），虚拟化时，Axvisor模拟PCI总线的拓扑关系和设备的配置空间，例如，虚拟设备的BAR（基址寄存器） 由Axvisor动态分配，客户机操作系统通过写入BAR来请求资源，Axvisor则映射到宿主机物理地址或虚拟资源。</p>
</li>
<li>
<p><strong>设备发现与枚举</strong></p>
<p>GuestOS启动时，会像物理机一样枚举PCI总线以发现设备。Axvisor模拟BIOS/UEFI固件的行为，向GuestOS呈现虚拟PCI总线及挂接的设备。</p>
</li>
<li>
<p><strong>I/O访问与中断处理</strong></p>
<p>GuestOS对虚拟设备的I/O端口（PMIO）或内存映射（MMIO）访问会被VMM截获。中断则通过虚拟APIC或注入虚拟中断信号通知GuestOS。<style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () =&gt; window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () =&gt; { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY &lt;200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() =&gt; { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () =&gt; { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() =&gt; { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) =&gt; (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) =&gt; { btn.addEventListener("click", (event) =&gt; { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="virtio-device"><a class="header" href="#virtio-device">Virtio-Device</a></h1>
<p><img src="architecture/device/../../assets/io.png" alt="" /></p>
<h2 id="virtio设备的基本组成结构"><a class="header" href="#virtio设备的基本组成结构">virtio设备的基本组成结构</a></h2>
<p>virtio设备代表了一类I/O通用设备，为了让设备驱动能够管理和使用设备。在程序员的眼里，I/O设备基本组成结构包括如下恩利：</p>
<ul>
<li>呈现模式：设备一般通过寄存器、内存或特定I/O指令等方式让设备驱动能看到和访问到设备；</li>
<li>特征描述：让设备驱动能够了解设备的静态特性（可通过软件修改），从而决定是否或如何使用该设备；</li>
<li>状态表示：让设备驱动能够了解设备的当前动态状态，从而确定如何进行设备管理或I/O数据传输；</li>
<li>交互机制：交互包括事件通知和数据传输；对于事件通知，让设备驱动及时获知设备的状态变化的机制（可基于中断等机制），以及让设备及时获得设备驱动发出的I/O请求（可基于寄存器读写等机制）；对于数据传输，让设备驱动能处理设备给出的数据，以及让设备能处理设备驱动给出的数据，如（可基于DMA或virtqueue等机制）。
virtio设备具体定义了设备驱动和设备之间的接口，包括设备呈现模式、设备状态域、特征位、通知、设备配置空间、虚拟队列等，覆盖了上述的基本接口描述。</li>
</ul>
<h2 id="virtio设备的基本组成要素"><a class="header" href="#virtio设备的基本组成要素">virtio设备的基本组成要素</a></h2>
<p>virtio设备的基本组成要素如下：</p>
<ul>
<li>设备状态域（Device status field）</li>
<li>特征位（Feature bits）</li>
<li>通知（Notifications）</li>
<li>设备配置空间（Device Configuration space）</li>
<li>一个或多个虚拟队列（virtqueue）
其中的设备特征位和设备配置空间属于virtio设备的特征描述；设备状态域属于virtio设备初始化时的状态表示；通知和虚拟队列属于virtio设备的交互机制，也包含virtio设备运行时的状态表示。</li>
</ul>
<h2 id="virtio设备的呈现模式"><a class="header" href="#virtio设备的呈现模式">virtio设备的呈现模式</a></h2>
<p>virtio设备的基本组成要素如下：</p>
<ul>
<li>设备状态域（Device status field）</li>
<li>特征位（Feature bits）</li>
<li>通知（Notifications）</li>
<li>设备配置空间（Device Configuration space）</li>
<li>一个或多个虚拟队列（virtqueue）
其中的设备特征位和设备配置空间属于virtio设备的特征描述；设备状态域属于virtio设备初始化时的状态表示；通知和虚拟队列属于virtio设备的交互机制，也包含virtio设备运行时的状态表示。</li>
</ul>
<h2 id="virtio设备的特征描述"><a class="header" href="#virtio设备的特征描述">virtio设备的特征描述</a></h2>
<p>virtio设备特征描述包括设备特征位和设备配置空间。<br />
<strong>特征位</strong><br />
特征位用于表示VirtIO设备具有的各种特性和功能。其中bit0 – 23是特定设备可以使用的feature bits， bit24 – 37预给队列和feature协商机制，bit38以上保留给未来其他用途。驱动程序与设备对设备特性进行协商，形成一致的共识，这样才能正确的管理设备。<br />
<strong>设备配置空间</strong><br />
设备配置空间通常用于配置不常变动的设备参数（属性），或者初始化阶段需要设置的设备参数。设备的特征位中包含表示配置空间是否存在的bit位，并可通过在特征位的末尾添加新的bit位来扩展配置空间。
设备驱动程序在初始化virtio设备时，需要根据virtio设备的特征位和配置空间来了解设备的特征，并对设备进行初始化。</p>
<h2 id="virtio设备状态表示"><a class="header" href="#virtio设备状态表示">virtio设备状态表示</a></h2>
<p>virtio设备状态表示包括在设备初始化过程中用到的设备状态域，以及在设备进行I/O传输过程中用到的I/O数据访问状态信息和I/O完成情况等。<br />
<strong>设备状态域</strong>
设备状态域包含对设备初始化过程中virtio设备的6种状态：</p>
<ul>
<li>ACKNOWLEDGE（1）：驱动程序发现了这个设备，并且认为这是一个有效的virtio设备；</li>
<li>DRIVER (2) : 驱动程序知道该如何驱动这个设备；</li>
<li>FAILED (128) : 由于某种错误原因，驱动程序无法正常驱动这个设备；</li>
<li>FEATURES_OK (8) : 驱动程序认识设备的特征，并且与设备就设备特征协商达成一致；</li>
<li>DRIVER_OK (4) : 驱动程序加载完成，设备可以正常工作了；</li>
<li>DEVICE_NEEDS_RESET (64) ：设备触发了错误，需要重置才能继续工作。
在设备驱动程序对virtio设备初始化的过程中，需要经历一系列的初始化阶段，这些阶段对应着设备状态域的不同状态。<br />
<strong>I/O传输状态</strong><br />
设备驱动程序控制virtio设备进行I/O传输过程中，会经历一系列过程和执行状态，包括 I/O请求状态、 I/O处理状态、 I/O完成状态、I/O错误状态、 I/O后续处理状态等。设备驱动程序在执行过程中，需要对上述状态进行不同的处理。
virtio设备进行I/O传输过程中，设备驱动会指出 I/O请求队列的当前位置状态信息，这样设备能查到I/O请求的信息，并根据 I/O请求进行I/O传输；而设备会指出 I/O完成队列的当前位置状态信息，这样设备驱动通过读取 I/O完成数据结构中的状态信息，就知道设备是否完成I/O请求的相应操作，并进行后续事务处理。
比如，virtio_blk设备驱动发出一个读设备块的I/O请求，并在某确定位置给出这个I/O请求的地址，然后给设备发出’kick’通知(读或写相关I/O寄存器映射的内存地址)，此时处于I/O请求状态；设备在得到通知后，此时处于 I/O处理状态，它解析这个I/O请求，完成这个I/O请求的处理，即把磁盘块内容读入到内存中，并给出读出的块数据的内存地址，再通过中断通知设备驱动，此时处于 I/O完成状态；如果磁盘块读取发生错误，此时处于 I/O错误状态；设备驱动通过中断处理例程，此时处于 I/O后续处理状态，设备驱动知道设备已经完成读磁盘块操作，会根据磁盘块数据所在内存地址，把数据传递给文件系统进行进一步处理；如果设备驱动发现磁盘块读错误，则会进行错误恢复相关的后续处理。</li>
</ul>
<h2 id="virtio设备交互机制"><a class="header" href="#virtio设备交互机制">virtio设备交互机制</a></h2>
<p>virtio设备交互机制包括基于Notifications的事件通知和基于virtqueue虚拟队列的数据传输。事件通知是指设备和驱动程序必须通知对方，它们有数据需要对方处理。数据传输是指设备和驱动程序之间进行I/O数据（如磁盘块数据、网络包）传输。<br />
<strong>Notification通知</strong><br />
驱动程序和设备在交互过程中需要相互通知对方：驱动程序组织好相关命令/信息要通知设备去处理I/O事务，设备处理完I/O事务后，要通知驱动程序进行后续事务，如回收内存，向用户进程反馈I/O事务的处理结果等。
驱动程序通知设备可用<code>门铃 doorbell</code>机制，即采用PIO或MMIO方式访问设备特定寄存器，QEMU进行拦截再通知其模拟的设备。设备通知驱动程序一般用中断机制，即在QEMU中进行中断注入，让CPU响应并执行中断处理例程，来完成对I/O执行结果的处理。<br />
<strong>virtqueue虚拟队列</strong><br />
在virtio设备上进行批量数据传输的机制被称为虚拟队列（virtqueue），virtio设备的虚拟队列（virtqueue）可以由各种数据结构（如数组、环形队列等）来具体实现。每个virtio设备可以拥有零个或多个virtqueue，每个virtqueue占用多个物理页，可用于设备驱动程序给设备发I/O请求命令和相关数据（如磁盘块读写请求和读写缓冲区），也可用于设备给设备驱动程序发I/O数据（如接收的网络包）。</p>
<h2 id="virtqueue虚拟队列"><a class="header" href="#virtqueue虚拟队列">virtqueue虚拟队列</a></h2>
<p>virtio协议中一个关键部分是virtqueue，在virtio规范中，virtqueue是virtio设备上进行批量数据传输的机制和抽象表示。在设备驱动实现和Qemu中virtio设备的模拟实现中，virtqueue是一种数据结构，用于设备和驱动程序中执行各种数据传输操作。
操作系统在Qemu上运行时，virtqueue是 virtio 驱动程序和 virtio 设备访问的同一块内存区域。
当涉及到 virtqueue 的描述时，有很多不一致的地方。有将其与vring（virtio-rings或VRings）等同表示，也有将二者分别单独描述为不同的对象。我们将在这里单独描述它们，因为vring是virtqueues的主要组成部分，是达成virtio设备和驱动程序之间数据传输的数据结构， vring本质是virtio设备和驱动程序之间的共享内存，但 virtqueue 不仅仅只有vring。
virtqueue由三部分组成（如下图所示）：</p>
<ul>
<li>描述符表 Descriptor Table：描述符表是描述符为组成元素的数组，每个描述符描述了一个内存buffer 的address/length。而内存buffer中包含I/O请求的命令/数据（由virtio设备驱动填写），也可包含I/O完成的返回结果（由virtio设备填写）等。</li>
<li>可用环 Available Ring：一种vring，记录了virtio设备驱动程序发出的I/O请求索引，即被virtio设备驱动程序更新的描述符索引的集合，需要virtio设备进行读取并完成相关I/O操作；</li>
<li>已用环 Used Ring：另一种vring，记录了virtio设备发出的I/O完成索引，即被virtio设备更新的描述符索引的集合，需要vrtio设备驱动程序进行读取并对I/O操作结果进行进一步处理。
<img src="architecture/device/../../assets/virtqueue.png" alt="" />
<strong>描述符表 Descriptor Table</strong><br />
描述符表用来指向virtio设备I/O传输请求的缓冲区（buffer）信息，由 Queue Size 个Descriptor（描述符）组成。描述符中包括buffer的物理地址 – addr字段，buffer的长度 – len字段，可以链接到 next Descriptor 的next指针（用于把多个描述符链接成描述符链）。buffer所在物理地址空间需要设备驱动程序在初始化时分配好，并在后续由设备驱动程序在其中填写IO传输相关的命令/数据，或者是设备返回I/O操作的结果。多个描述符（I/O操作命令，I/O操作数据块，I/O操作的返回结果）形成的描述符链可以表示一个完整的I/O操作请求。<br />
<strong>可用环 Available Ring</strong><br />
可用环在结构上是一个环形队列，其中的条目（item）仅由驱动程序写入，并由设备读出。可用环中的条目包含了一个描述符链的头部描述符的索引值。可用环用头指针（idx）和尾指针（last_avail_idx）表示其可用条目范围。virtio设备通过读取可用环中的条目可获取驱动程序发出的I/O操作请求对应的描述符链，然后virtio设备就可以进行进一步的I/O处理了。描述符指向的缓冲区具有可读写属性，可读的缓冲区用于Driver发送数据，可写的缓冲区用于接收数据。
比如，对于virtio-blk设备驱动发出的一个读I/O操作请求包含了三部分内容，由三个buffer承载，需要用到三个描述符 ：（1） “读磁盘块”，（2）I/O操作数据块 – “数据缓冲区”，（3）I/O操作的返回结果 –“结果缓冲区”）。这三个描述符形成的一个完成的I/O请求链，virtio-blk从设备可通过读取第一个描述符指向的缓冲区了解到是“读磁盘块”操作，这样就可把磁盘块数据通过DMA操作放到第二个描述符指向的“数据缓冲区”中，然后把“OK”写入到第三个描述符指向的“结果缓冲区”中。<br />
<strong>已用环 Used Ring</strong><br />
已用环在结构上是一个环形队列，其中的的条目仅由virtio设备写入，并由驱动程序读出。已用环中的条目也一个是描述符链的头部描述符的索引值。已用环也有头指针（idx）和尾指针（last_avail_idx）表示其已用条目的范围。
比如，对于virtio-blk设备驱动发出的一个读I/O操作请求（由三个描述符形成的请求链）后，virtio设备完成相应I/O处理，即把磁盘块数据写入第二个描述符指向的“数据缓冲区”中，可用环中对应的I/O请求条目“I/O操作的返回结果”的描述符索引值移入到已用环中，把“OK”写入到第三个描述符指向的“结果缓冲区”中，再在已用环中添加一个已用条目，即I/O操作完成信息；然后virtio设备通过中断机制来通知virtio驱动程序，并让virtio驱动程序读取已用环中的描述符，获得I/O操作完成信息，即磁盘块内容。
上面主要说明了virqueue中的各个部分的作用。对如何基于virtqueue进行I/O操作的过程还缺乏一个比较完整的描述。我们把上述基于virtqueue进行I/O操作的过程小结一下，大致需要如下步骤：</li>
</ul>
<ol>
<li>初始化过程：（驱动程序执行）<br />
1.1 virtio设备驱动在对设备进行初始化时，会申请virtqueue（包括描述符表、可用环、已用环）的内存空间；<br />
1.2 并把virtqueue中的描述符、可用环、已用环三部分的物理地址分别写入到virtio设备中对应的控制寄存器（即设备绑定的特定内存地址）中。至此，设备驱动和设备就共享了整个virtqueue的内存空间。</li>
<li>I/O请求过程：（驱动程序执行）<br />
2.1 设备驱动在发出I/O请求时，首先把I/O请求的命令/数据等放到一个或多个buffer中；<br />
2.2 然后在描述符表中分配新的描述符（或描述符链）来指向这些buffer；<br />
2.3 再把描述符（或描述符链的首描述符）的索引值写入到可用环中，更新可用环的idx指针；<br />
2.4 驱动程序通过kick机制（即写virtio设备中特定的通知控制寄存器）来通知设备有新请求；</li>
<li>I/O完成过程：（设备执行）<br />
3.1 virtio设备通过kick机制（知道有新的I/O请求，通过访问可用环的idx指针，解析出I/O请求；<br />
3.2 根据I/O请求内容完成I/O请求，并把I/O操作的结果放到I/O请求中相应的buffer中；<br />
3.3 再把描述符（或描述符链的首描述符）的索引值写入到已用环中，更新已用环的idx指针；<br />
3.4 设备通过再通过中断机制来通知设备驱动程序有I/O操作完成；</li>
<li>I/O后处理过程：（驱动程序执行）<br />
4.1 设备驱动程序读取已用环的idx信息，读取已用环中的描述符索引，获得I/O操作完成信息。  <style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () =&gt; window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () =&gt; { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY &lt;200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() =&gt; { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () =&gt; { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() =&gt; { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) =&gt; (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) =&gt; { btn.addEventListener("click", (event) =&gt; { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多层vm-exit处理机制"><a class="header" href="#多层vm-exit处理机制"><a href="https://github.com/orgs/arceos-hypervisor/discussions/19">多层VM-Exit处理机制</a></a></h1>
<p>众所周知，VM-Exit 对于获取客户虚拟机的运行状态以及与客户虚拟机进行交互至关重要。</p>
<p>VM-Exit 用于设备仿真和 vCPU 调度。</p>
<p>在 x86_64、aarch64 和 riscv64 架构中，VM-Exit 遵循相同的设计逻辑，但实现方式略有不同。</p>
<p><img src="architecture/../assets/vmexit-handling.png" alt="" /></p>
<h1 id="inner-vcpu处理"><a class="header" href="#inner-vcpu处理">Inner-VCpu处理</a></h1>
<p>在 x86_64 架构下，某些 VM-Exit 项目是特定于架构的（例如 <code>VmxExitReason::CR_ACCESS</code>、<code>VmxExitReason::CPUID</code>）。在我们当前的设计中，这些 VM-Exit 由 [<code>VmxVcpu</code>] 本身通过 <code>builtin_vmexit_handler</code> 处理，而其他 VM-Exit 类型则由 <code>vcpu.run()</code> 返回，并由调用 <code>vcpu.run()</code> 的程序来处理。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;H: AxVMHal&gt; VmxVcpu&lt;H&gt; {
    /// Handle vm-exits than can and should be handled by [`VmxVcpu`] itself.
    ///
    /// Return the result or None if the vm-exit was not handled.
    fn builtin_vmexit_handler(&amp;mut self, exit_info: &amp;VmxExitInfo) -&gt; Option&lt;AxResult&gt; {
        // Following vm-exits are handled here:
        // - interrupt window: turn off interrupt window;
        // - xsetbv: set guest xcr;
        // - cr access: just panic;
        match exit_info.exit_reason {
            VmxExitReason::INTERRUPT_WINDOW =&gt; Some(self.set_interrupt_window(false)),
            VmxExitReason::PREEMPTION_TIMER =&gt; Some(self.handle_vmx_preemption_timer()),
            VmxExitReason::XSETBV =&gt; Some(self.handle_xsetbv()),
            VmxExitReason::CR_ACCESS =&gt; Some(self.handle_cr()),
            VmxExitReason::CPUID =&gt; Some(self.handle_cpuid()),
            _ =&gt; None,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>此外，<code>VmxExitReason::IoRead/IoWrite</code> 和 <code>VmxExitReason::MsrRead/MsrWrite</code> 也是 x86_64 特有的，但这些 VM-Exit 与端口 I/O 或 Msr 设备仿真相关，因此更适合在 <code>vcpu.run()</code> 之外处理。</p>
<h1 id="inner-vm处理"><a class="header" href="#inner-vm处理">Inner-VM处理</a></h1>
<p>由于 axvm 中的虚拟机结构负责虚拟机的资源管理，例如模拟设备和地址空间（axaddrspace），所以更倾向于将与设备模拟相关的以及与页面错误相关的（数据中止）虚拟机退出保留在 axvm 内部。</p>
<p>也就是说，在虚拟机结构中提供一个 <code>run_vcpu()</code> 函数，并将与设备模拟相关的 VM 退出处理整合到 <code>vm.run_vcpu()</code></p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;H: AxVMHal&gt; AxVM&lt;H&gt; {
    pub fn run_vcpu(&amp;self, vcpu_id: usize) -&gt; AxResult&lt;AxVCpuExitReason&gt; {
        let vcpu = self
            .vcpu(vcpu_id)
            .ok_or_else(|| ax_err_type!(InvalidInput, "Invalid vcpu_id"))?;

        vcpu.bind()?;

        let exit_reason = loop {
            let exit_reason = vcpu.run()?;

            trace!("{exit_reason:#x?}");
            let handled = match &amp;exit_reason {
                AxVCpuExitReason::MmioRead { addr: _, width: _ } =&gt; true,
                AxVCpuExitReason::MmioWrite {
                    addr: _,
                    width: _,
                    data: _,
                } =&gt; true,
                AxVCpuExitReason::IoRead { port: _, width: _ } =&gt; true,
                AxVCpuExitReason::IoWrite {
                    port: _,
                    width: _,
                    data: _,
                } =&gt; true,
                AxVCpuExitReason::NestedPageFault { addr, access_flags } =&gt; self
                    .inner_mut
                    .address_space
                    .lock()
                    .handle_page_fault(*addr, *access_flags),
                _ =&gt; false,
            };
            if !handled {
                break exit_reason;
            }
        };

        vcpu.unbind()?;
        Ok(exit_reason)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>因此，将设备模拟操作整合到 <code>axvm</code> 模块中，这样 <code>vmm-app</code> 只需要传入配置文件就可以，然后根据需要创建模拟设备实例，而不必关心模拟设备的特定运行时行为以及地址空间。</p>
<p>当然，这是在这些 VM-exit 不触发 vCPU 调度的条件下。</p>
<h1 id="outer-vm-vmm-app处理"><a class="header" href="#outer-vm-vmm-app处理">(Outer-VM) vmm-app处理</a></h1>
<p>我们重用 task 来实现 vcpu 的运行时管理和调度。</p>
<p>这个逻辑是在 <code>vmm-app</code> 中实现的，因为 VMM 自然需要关注 vCPU 调度，并且它在 <code>vmm-app</code> 中整合了对 ArceOS 的 axtask 的依赖。</p>
<p>对于前两层没有处理的 VM-Exit，它们将从 <code>vcpu::run()</code> 的返回值中获取，并在这里进行处理，包括处理 hypercalls（在 VMM 中处理这个似乎也相当合理）和任何需要 vcpu 调度或 vcpu 退出的 VM-Exit 类型。</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        let mut task = TaskInner::new(
            || {
                let curr = axtask::current();

                let vm = curr.task_ext().vm.clone();
                let vcpu = curr.task_ext().vcpu.clone();
                let vm_id = vm.id();
                let vcpu_id = vcpu.id();

                info!("VM[{}] Vcpu[{}] waiting for running", vm.id(), vcpu.id());
                wait_for(vm_id, || vm.running());

                info!("VM[{}] Vcpu[{}] running...", vm.id(), vcpu.id());

                loop {
                    match vm.run_vcpu(vcpu_id) {
                        // match vcpu.run() {
                        Ok(exit_reason) =&gt; match exit_reason {
                            AxVCpuExitReason::Hypercall { nr, args } =&gt; {
                                debug!("Hypercall [{}] args {:x?}", nr, args);
                            }
                            AxVCpuExitReason::FailEntry {
                                hardware_entry_failure_reason,
                            } =&gt; {
                                warn!(
                                    "VM[{}] VCpu[{}] run failed with exit code {}",
                                    vm_id, vcpu_id, hardware_entry_failure_reason
                                );
                            }
                            AxVCpuExitReason::ExternalInterrupt { vector } =&gt; {
                                debug!("VM[{}] run VCpu[{}] get irq {}", vm_id, vcpu_id, vector);
                            }
                            AxVCpuExitReason::Halt =&gt; {
                                debug!("VM[{}] run VCpu[{}] Halt", vm_id, vcpu_id);
                                wait(vm_id)
                            }
                            AxVCpuExitReason::Nothing =&gt; {}
                            _ =&gt; {
                                warn!("Unhandled VM-Exit");
                            }
                        },
                        Err(err) =&gt; {
                            warn!("VM[{}] run VCpu[{}] get error {:?}", vm_id, vcpu_id, err);
                            wait(vm_id)
                        }
                    }
                }
            },
            format!("VCpu[{}]", vcpu.id()),
            KERNEL_STACK_SIZE,
        );
```&lt;style&gt;.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }&lt;/style&gt;&lt;button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"&gt; &lt;i class="fa fa-angle-up"&gt;&lt;/i&gt;&lt;/button&gt;&lt;script&gt;const scrollToTop = () =&gt; window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () =&gt; { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY &lt;200); });&lt;/script&gt;&lt;style&gt;.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }&lt;/style&gt;&lt;div style="display: none" data-id="0.2.11" class="announcement-banner"&gt; &lt;p&gt;&lt;em&gt;正在逐步完善中。。。&lt;/em&gt;&lt;/p&gt; &lt;button type="button" data-close&gt;X&lt;/button&gt;&lt;/div&gt;&lt;script&gt;(() =&gt; { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () =&gt; { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();&lt;/script&gt;&lt;style&gt;.giscus { margin-top: 6rem; }&lt;/style&gt;&lt;script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async&gt;&lt;/script&gt;&lt;script&gt;(() =&gt; { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) =&gt; (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) =&gt; { btn.addEventListener("click", (event) =&gt; { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();&lt;/script&gt;&lt;style&gt;footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }&lt;/style&gt;&lt;footer&gt;&lt;p&gt;Copyright © 2025 • Created by ArceOS Team&lt;/p&gt;&lt;/footer&gt;
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><p>待添加。。。<style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () =&gt; window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () =&gt; { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY &lt;200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() =&gt; { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () =&gt; { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() =&gt; { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) =&gt; (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) =&gt; { btn.addEventListener("click", (event) =&gt; { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="构建"><a class="header" href="#构建">构建</a></h1>
<style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () => window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () => { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY <200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() => { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () => { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() => { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) => (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) => { btn.addEventListener("click", (event) => { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer><div style="break-before: page; page-break-before: always;"></div><style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () => window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () => { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY <200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() => { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () => { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() => { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) => (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) => { btn.addEventListener("click", (event) => { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="客户机适配"><a class="header" href="#客户机适配">客户机适配</a></h1>
<style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () => window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () => { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY <200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() => { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () => { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() => { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) => (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) => { btn.addEventListener("click", (event) => { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="在-qemu-arm-平台上启动两个nimbos并分别注入-timer-中断"><a class="header" href="#在-qemu-arm-平台上启动两个nimbos并分别注入-timer-中断">在 QEMU-ARM 平台上启动两个nimbos，并分别注入 timer 中断</a></h1>
<h2 id="clone代码"><a class="header" href="#clone代码">Clone代码</a></h2>
<p>新建创建项目的<code>clone.sh</code>，然后<code>bash clone.sh</code>自动创建项目</p>
<pre><code class="language-bash">#!/bin/bash

BRANCH="-b debin/2vm_timer"

mkdir -p crates

git clone $BRANCH https://github.com/arceos-hypervisor/arceos-umhv.git 

cd arceos-umhv

# 克隆arceos主仓库
git clone $BRANCH https://github.com/arceos-hypervisor/arceos.git ../arceos

# 克隆其他仓库到crates目录
REPOS=(
    "axvm"
    "axvcpu"
    "axaddrspace"
    "arm_vcpu"
    "axdevice"
    "arm_vgic"
    "arm_gicv2"
    "axdevice_crates"
)

for repo in "${REPOS[@]}"; do
    git clone $BRANCH "https://github.com/arceos-hypervisor/${repo}.git" "../crates/${repo}"
done

echo "所有仓库克隆完成！"

# 创建临时文件
temp_file=$(mktemp)

# 要添加的新内容
cat &gt; "$temp_file" &lt;&lt; 'EOF'
[patch."https://github.com/arceos-hypervisor/arceos.git".axstd]
path = "../arceos/ulib/axstd"
[patch."https://github.com/arceos-hypervisor/arceos.git".axhal]
path = "../arceos/modules/axhal"
[patch."https://github.com/arceos-hypervisor/axvm.git".axvm]
path = "../crates/axvm"
[patch."https://github.com/arceos-hypervisor/axvcpu.git".axvcpu]
path = "../crates/axvcpu"
[patch."https://github.com/arceos-hypervisor/axaddrspace.git".axaddrspace]
path = "../crates/axaddrspace"
[patch."https://github.com/arceos-hypervisor/arm_vcpu.git".arm_vcpu]
path = "../crates/arm_vcpu"
[patch."https://github.com/arceos-hypervisor/axdevice.git".axdevice]
path = "../crates/axdevice"
[patch."https://github.com/arceos-hypervisor/arm_vgic.git".arm_vgic]
path = "../crates/arm_vgic"
[patch."https://github.com/arceos-hypervisor/axdevice_crates.git".axdevice_base]
path = "../crates/axdevice_crates/axdevice_base"
[patch."https://github.com/arceos-hypervisor/arm_gicv2.git".arm_gicv2]
path = "../crates/arm_gicv2"

EOF

# 将原文件内容追加到临时文件
cat Cargo.toml &gt;&gt; "$temp_file"

# 将临时文件移回原文件
mv "$temp_file" Cargo.toml

echo "成功更新 Cargo.toml"

cd .. &amp;&amp; mkdir .vscode

cat &gt; .vscode/settings.json &lt;&lt; 'EOF'
{
    "rust-analyzer.cargo.target": "aarch64-unknown-none-softfloat",
    "rust-analyzer.check.allTargets": false,
    "rust-analyzer.cargo.features": ["irq", "hv"],
    "rust-analyzer.cargo.extraEnv": {
        "RUSTFLAGS": "--cfg platform_family=\"aarch64-qemu-virt\""
    }
}
EOF

</code></pre>
<h2 id="编译nimbos"><a class="header" href="#编译nimbos">编译nimbos</a></h2>
<p>因为加载到任意地址的功能还没有实现，所以只能通过硬配置来做，得单独编译两个nimbos</p>
<h3 id="nimbosvm1"><a class="header" href="#nimbosvm1">nimbos（VM1）</a></h3>
<pre><code class="language-bash">git clone https://github.com/arceos-hypervisor/nimbos.git
</code></pre>
<h3 id="nimbosvm2"><a class="header" href="#nimbosvm2">nimbos（VM2）</a></h3>
<pre><code class="language-bash">git clone -b debin/0x800 https://github.com/arceos-hypervisor/nimbos.git
</code></pre>
<h2 id="创建diskimg文件"><a class="header" href="#创建diskimg文件">创建<code>disk.img</code>文件</a></h2>
<p>生成一个disk.img，然后将编译好的nimbos.bin重命名并放入里面</p>
<pre><code class="language-bash">cd arceos-umhv/arceos-vmm/
mkdir mnt
make disk_img
sudo mount disk_img mnt
cp nimbos_0x408_0000.bin ./mnt
cp nimbos_0x808_0000.bin ./mnt
cd .. &amp;&amp; sudo umount mnt
</code></pre>
<h2 id="启动vmms"><a class="header" href="#启动vmms">启动VMMS</a></h2>
<pre><code class="language-bash">cd arceos-umhv/arceos-vmm/
bash run.sh

# 在qemu启动后，打开第二个终端使用telnet连接串口2
telnet localhost 4321
</code></pre>
<p>就可以正常注入timer了</p>
<h3 id="vm1"><a class="header" href="#vm1">VM1</a></h3>
<pre><code class="language-bash">NN   NN  iii               bb        OOOOO    SSSSS
NNN  NN       mm mm mmmm   bb       OO   OO  SS
NN N NN  iii  mmm  mm  mm  bbbbbb   OO   OO   SSSSS
NN  NNN  iii  mmm  mm  mm  bb   bb  OO   OO       SS
NN   NN  iii  mmm  mm  mm  bbbbbb    OOOO0    SSSSS
              ___    ____    ___    ___
             |__ \  / __ \  |__ \  |__ \
             __/ / / / / /  __/ /  __/ /
            / __/ / /_/ /  / __/  / __/
           /____/ \____/  /____/ /____/

arch = aarch64
platform = qemu-virt-arm
build_mode = release
log_level = info

Initializing kernel heap at: [0xffff0000401200e0, 0xffff0000405200e0)
[INFO  nimbos] Logging is enabled.
Initializing frame allocator at: [PA:0x40521000, PA:0x48000000)
Mapping .text: [0xffff000040080000, 0xffff000040094000)
Mapping .rodata: [0xffff000040094000, 0xffff00004009b000)
Mapping .data: [0xffff00004009b000, 0xffff00004011a000)
Mapping .bss: [0xffff00004011e000, 0xffff000040521000)
Mapping boot stack: [0xffff00004011a000, 0xffff00004011e000)
Mapping physical memory: [0xffff000040521000, 0xffff000048000000)
[  0.280129 1:9 arceos_vmm::vmm::vcpus:243] VM[2] Vcpu[0] waiting for running
[  0.280591 1:9 arceos_vmm::vmm::vcpus:246] VM[2] Vcpu[0] running...
Mapping MMIO: [0xffff000009000000, 0xffff000009001000)
Mapping MMIO: [0xffff000008000000, 0xffff000008020000)
Initializing drivers...
[  0.291414 0:8 arm_vgic::interrupt:76] Setting interrupt 30 enable to true
Initializing task manager...
/**** APPS ****
cyclictest
exit
fantastic_text
forktest
forktest2
forktest_simple
forktest_simple_c
forktree
hello_c
hello_world
matrix
poweroff
sleep
sleep_simple
stack_overflow
thread_simple
user_shell
usertests
yield
**************/
Running tasks...
test kernel task: pid = TaskId(2), arg = 0xdead
[  0.294993 INFO  nimbos::task::structs][0:2] task exit with code 0
test kernel task: pid = TaskId(3), arg = 0xbeef
[  0.296126 INFO  nimbos::task::structs][0:3] task exit with code 0
[  0.296457 INFO  nimbos::arch::aarch64::context][0:4] user task start: entry=0x211cfc, ustack=0xfffffffff000, kstack=0xffff000040138000
Rust user shell
&gt;&gt; [  0.298106 1:9 arm_vgic::interrupt:76] Setting interrupt 30 enable to true
[  3.349047 0:8 axhal::irq:23] Unhandled IRQ 33
s[  3.583202 0:8 axhal::irq:23] Unhandled IRQ 33
l[  3.898013 0:8 axhal::irq:23] Unhandled IRQ 33
e[  4.067715 0:8 axhal::irq:23] Unhandled IRQ 33
e[  4.214772 0:8 axhal::irq:23] Unhandled IRQ 33
p[  4.829631 0:8 axhal::irq:23] Unhandled IRQ 33

[  4.830637 INFO  nimbos::arch::aarch64::context][0:5] user task start: entry=0x211d28, ustack=0xffffffffee10, kstack=0xffff000040134000
[  4.832135 INFO  nimbos::arch::aarch64::context][0:6] user task start: entry=0x210744, ustack=0xffffffffef40, kstack=0xffff000040130000
sleep 1 x 1 seconds.
sleep 2 x 1 seconds.
sleep 3 x 1 seconds.
sleep 4 x 1 seconds.
sleep 5 x 1 seconds.
[  9.879593 INFO  nimbos::task::structs][0:6] task exit with code 0
use 5048222 usecs.
sleep passed!
[  9.880587 INFO  nimbos::task::structs][0:5] task exit with code 0
Shell: Process 5 exited with code 0
&gt;&gt; QEMU: Terminated
</code></pre>
<h3 id="vm2"><a class="header" href="#vm2">VM2</a></h3>
<pre><code class="language-bash">Trying 127.0.0.1...
Connected to localhost.
Escape character is '^]'.
a
NN   NN  iii               bb        OOOOO    SSSSS
NNN  NN       mm mm mmmm   bb       OO   OO  SS
NN N NN  iii  mmm  mm  mm  bbbbbb   OO   OO   SSSSS
NN  NNN  iii  mmm  mm  mm  bb   bb  OO   OO       SS
NN   NN  iii  mmm  mm  mm  bbbbbb    OOOO0    SSSSS
              ___    ____    ___    ___
             |__ \  / __ \  |__ \  |__ \
             __/ / / / / /  __/ /  __/ /
            / __/ / /_/ /  / __/  / __/
           /____/ \____/  /____/ /____/

arch = aarch64
platform = qemu-virt-arm
build_mode = release
log_level = info

Initializing kernel heap at: [0xffff0000801200e0, 0xffff0000805200e0)
[INFO  nimbos] Logging is enabled.
Initializing frame allocator at: [PA:0x80521000, PA:0x88000000)
Mapping .text: [0xffff000080080000, 0xffff000080094000)
Mapping .rodata: [0xffff000080094000, 0xffff00008009b000)
Mapping .data: [0xffff00008009b000, 0xffff00008011a000)
Mapping .bss: [0xffff00008011e000, 0xffff000080521000)
Mapping boot stack: [0xffff00008011a000, 0xffff00008011e000)
Mapping physical memory: [0xffff000080521000, 0xffff000088000000)
Mapping MMIO: [0xffff000009000000, 0xffff000009001000)
Mapping MMIO: [0xffff000008000000, 0xffff000008020000)
Initializing drivers...
Initializing task manager...
/**** APPS ****
cyclictest
exit
fantastic_text
forktest
forktest2
forktest_simple
forktest_simple_c
forktree
hello_c
hello_world
matrix
poweroff
sleep
sleep_simple
stack_overflow
thread_simple
user_shell
usertests
yield
**************/
Running tasks...
test kernel task: pid = TaskId(2), arg = 0xdead
[  0.301555 INFO  nimbos::task::structs][0:2] task exit with code 0
test kernel task: pid = TaskId(3), arg = 0xbeef
[  0.302448 INFO  nimbos::task::structs][0:3] task exit with code 0
[  0.302702 INFO  nimbos::arch::aarch64::context][0:4] user task start: entry=0x211cfc, ustack=0xfffffffff000, kstack=0xffff000080138000
Rust user shell
&gt;&gt; sleep
[ 13.410960 INFO  nimbos::arch::aarch64::context][0:5] user task start: entry=0x211d28, ustack=0xffffffffee10, kstack=0xffff000080134000
[ 13.412543 INFO  nimbos::arch::aarch64::context][0:6] user task start: entry=0x210744, ustack=0xffffffffef40, kstack=0xffff000080130000
sleep 1 x 1 seconds.
sleep 2 x 1 seconds.
sleep 3 x 1 seconds.
sleep 4 x 1 seconds.
sleep 5 x 1 seconds.
[ 18.460517 INFO  nimbos::task::structs][0:6] task exit with code 0
use 5048755 usecs.
sleep passed!
[ 18.461516 INFO  nimbos::task::structs][0:5] task exit with code 0
Shell: Process 5 exited with code 0
&gt;&gt; Connection closed by foreign host.
</code></pre>
<h2 id="多虚拟串口支持"><a class="header" href="#多虚拟串口支持">多虚拟串口支持</a></h2>
<p>如果不能正常启动，考虑使用修改版的qemu</p>
<pre><code class="language-bash">git clone https://github.com/luodeb/qemu.git
./configure --enable-slirp --target-list=aarch64-softmmu,aarch64-linux-user --prefix=/path/to/qemu-9.2.0
make -j
make install
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>串口</th><th>地址</th><th>中断号offset</th></tr></thead><tbody>
<tr><td>UART0</td><td>0x09000000</td><td>1</td></tr>
<tr><td>UART1</td><td>0x09040000</td><td>8</td></tr>
<tr><td>UART2</td><td>0x09100000</td><td>21</td></tr>
<tr><td>UART3</td><td>0x09140000</td><td>22</td></tr>
</tbody></table>
</div><style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () => window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () => { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY <200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() => { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () => { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() => { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) => (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) => { btn.addEventListener("click", (event) => { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="简介"><a class="header" href="#简介">简介</a></h1>
<p>AxVisor 的开发以 Github 的 Project 和 Milestones 作为开发任务和目标的管理及跟踪工具。Github 的组织结构框图如下图所示。</p>
<p><img src="development/project/./images/Github.png" alt="Github" /></p>
<h2 id="github-project"><a class="header" href="#github-project">GitHub Project</a></h2>
<p>GitHub Project 是一个看板（Kanban）风格的任务管理工具，与 Issues、Pull Requests (PR)、仓库深度集成。Project 属于个人或者组织，不同的仓库可以共用同一个，它可以将不同仓库的 Issues 组织在一起提供管理。</p>
<h2 id="milestones"><a class="header" href="#milestones">Milestones</a></h2>
<p>GitHub 的 Milestone 主要用于指定仓库的 Issues 和 Pull Requests (PRs) 的版本或阶段管理。每个仓库的 Milestones 是独立的，它只能组织当前仓库里的各个 Issues 来提供管理。</p>
<h2 id="issues"><a class="header" href="#issues">Issues</a></h2>
<p>Issues 是 Project 和 Milestones 管理的基本单元，其分为了不同的类型，可以是 Task 也可以是 BUG。GitHub Project 和 Milestone 通过组织管理各个 Issues 的方式来提供开发任务和目标的管理及跟踪。</p>
<h1 id="axvisor-开发"><a class="header" href="#axvisor-开发">AxVisor 开发</a></h1>
<p>AxVisor 的开发目前主要涉及 <a href="https://github.com/arceos-hypervisor/axvisor">axvisor</a> 和 <a href="https://github.com/arceos-hypervisor/doc">doc</a> 这两个仓库，他们共用 <a href="https://github.com/orgs/arceos-hypervisor/projects/3">ArceOS Hypervisor Tasks</a> 这个 Project 来组织所有的开发任务。而 <a href="https://github.com/arceos-hypervisor/axvisor">axvisor</a> 和 <a href="https://github.com/arceos-hypervisor/doc">doc</a> 中各有自己的 Milestone 来追踪阶段目标。</p>
<p><img src="development/project/./images/axvisor.png" alt="axvisor" /></p>
<h2 id="开发任务"><a class="header" href="#开发任务">开发任务</a></h2>
<p>两个仓库中的每个 Issue 都是一个开发的任务（以任务类型区分），其会有一个或多个人员负责开发跟进。</p>
<p><img src="development/project/./images/task_new.png" alt="task_new" /></p>
<ol>
<li>
<p>Issues 的内容描述基本开发情况</p>
</li>
<li>
<p>以在 Issues 中评论的形式记录遇到问题</p>
</li>
</ol>
<h2 id="任务完成"><a class="header" href="#任务完成">任务完成</a></h2>
<p>每当完成一个 Issue 之后，要求在 Issue 中以评论的形式列出相关 Commit 的 HASH 作为自己任务的记录，然后关闭 Issue 即可</p>
<p><img src="development/project/./images/task_finish.png" alt="task_finish" /></p>
<style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () => window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () => { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY <200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() => { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () => { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() => { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) => (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) => { btn.addEventListener("click", (event) => { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="简介-1"><a class="header" href="#简介-1">简介</a></h1>
<p>AxVisor Book 是使用 <a href="https://rust-lang.github.io/mdBook/">mdbook</a> 搭建的统一模块化虚拟机管理程序 AxVisor 的在线文档。mdbook 是 Rust 官方开发的一个用于创建、维护和部署静态网站的网站生成工具。</p>
<h2 id="开发"><a class="header" href="#开发">开发</a></h2>
<h3 id="开发环境"><a class="header" href="#开发环境">开发环境</a></h3>
<p>默认安装 Rust 后并不会同步安装 mdbook 工具，我们需要使用 <code>cargo install mdbook mdbook-pagetoc mdbook-embedify mdbook-i18n-helpers i18n-report</code> 手动进行安装它及本文档使用的相关插件，mdbook 可执行文件会被放到 <code>.cargo/bin</code> 目录中。</p>
<h3 id="编写文档"><a class="header" href="#编写文档">编写文档</a></h3>
<p>mdbook 是一个将 Markdown 文档作为源文件的文档系统，因此，我们只需要以 Markdown 语法编写源文件即可。</p>
<p>源码中的 <code>./src/SUMMARY.md</code> 是文档的目录，当新增了源文件之后，需要在其中添加上对应的文件路径</p>
<h3 id="构建-1"><a class="header" href="#构建-1">构建</a></h3>
<p>mdbook 是一个命令行工具，使用命令 <code>mdbook build</code> 就可以自动生成对应的静态网页。使用命令 <code>mdbook serve</code> 可以在本地启动一个 HTTP 服务端，然后我们就可以在浏览器 http://localhost:3000 中预览文档。其他参数如下：</p>
<pre><code>$ mdbook -h
Creates a book from markdown files

Usage: mdbook [COMMAND]

Commands:
  init         Creates the boilerplate structure and files for a new book
  build        Builds a book from its markdown files
  test         Tests that a book's Rust code samples compile
  clean        Deletes a built book
  completions  Generate shell completions for your shell to stdout
  watch        Watches a book's files and rebuilds it on changes
  serve        Serves a book at http://localhost:3000, and rebuilds it on changes
  help         Print this message or the help of the given subcommand(s)

Options:
  -h, --help     Print help
  -V, --version  Print version

For more information about a specific command, try `mdbook &lt;command&gt; --help`
The source code for mdBook is available at: https://github.com/rust-lang/mdBook
</code></pre>
<h2 id="部署"><a class="header" href="#部署">部署</a></h2>
<p>目前，AxVisor 的文档网站托管在了 GitHub Pages 上：https://arceos-hypervisor.github.io/doc/ ，仓库默认配置为通过 GitHub Action 进行部署（Github 本身支持 Actions 和 Branch 两种部署方式，当前使用 Branch 方式），当把源码提交到仓库的 main 分支之后将自动触发 GitHub Action 进行部署。</p>
<h2 id="如何贡献"><a class="header" href="#如何贡献">如何贡献</a></h2>
<p>欢迎 FORK 本仓库，然后提交 PR。</p>
<h2 id="许可协议"><a class="header" href="#许可协议">许可协议</a></h2>
<p>AxVisor Book 使用如下开源协议：</p>
<ul>
<li>Apache-2.0</li>
<li>MulanPubL-2.0</li>
<li>MulanPSL2</li>
<li>GPL-3.0-or-later<style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () =&gt; window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () =&gt; { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY &lt;200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() =&gt; { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () =&gt; { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() =&gt; { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) =&gt; (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) =&gt; { btn.addEventListener("click", (event) =&gt; { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="简介-2"><a class="header" href="#简介-2">简介</a></h1>
<p>本文档使用了 Google 提供的 <a href="https://github.com/google/mdbook-i18n-helpers">mdbook-i18n-helpers</a> 来提供国际化支持。mdbook-i18n-helpers 中主要包含了 mdbook-xgettext 和 mdbook-gettext 这两个可执行程序，其中，mdbook-xgettext 是一个 mdbook 渲染器，帮助我们提取需要翻译的源文本，而 mdbook-gettext 是一个 mdbook 预处理器，负责将翻译后的文本重新注入到 Markdown 文件中。</p>
<h1 id="翻译"><a class="header" href="#翻译">翻译</a></h1>
<p>mdbook-i18n-helpers 使用的是 GNU 的 <a href="https://www.gnu.org/software/gettext/manual/html_node/index.html">Gettext</a> 系统进行翻译。GNU gettext 是一组实用程序，它提供了一个框架，在这个框架中我们可以方便的进行多种语言的翻译。该系统广泛用于开源软件的翻译，并且对于文档的翻译也相当有效。</p>
<h2 id="po-文件"><a class="header" href="#po-文件"><code>.po</code> 文件</a></h2>
<p>在 GNU gettext 中，每种语言都对应一个以 ISO 639 中定义的语言名为文件名的 <code>.po</code> 文件，例如，<code>en.po</code>，其中记录了所有原始需要翻译的内容以及对应的翻译后的内容。因此，我们的翻译工作无需复制原始的 Markdown 文件并手动跟踪更改，而只需要修改<code>.po</code> 文件即可。</p>
<h2 id="新增翻译"><a class="header" href="#新增翻译">新增翻译</a></h2>
<p>当我们的原始文档编写完成之后，首先需要创建所需要的语言对应的 <code>.po</code> 文件，以实现国际化支持。mdbook-xgettext 可以帮助我们提取原始文档中所有需要翻译的内容，并生成一个 <code>.pot</code> 文件（一个 PO 模板），我们以此为基础创建出不同语言的 <code>.po</code> 文件即可。</p>
<ol>
<li>
<p>执行 <code>MDBOOK_OUTPUT='{"xgettext": {"pot-file": "messages.pot"}}' mdbook build -d po</code> 自动提取原始文档中所有需要翻译的内容并生成 <code>messages.pot</code> 文件。命令执行之后就会生成默认的 <code>po/messages.pot</code> 文件</p>
<blockquote>
<p>如果在 <code>book.toml</code> 文件中添加了 <code>output.xgettext.pot-file = messages.pot</code> 配置项，则每次执行 <code>mdbook build</code> 时都会自动输出 <code>book/xgettext/messages.pot</code></p>
</blockquote>
<blockquote>
<p>不要编辑 <code>po/messages.pot</code> 文件，也不要将它签入你的存储库，因为它是完全从源 Markdown 文件生成。</p>
</blockquote>
</li>
<li>
<p>执行 <code>msginit -i po/messages.pot -l xx -o po/xx.po</code> 生成对应语言的 <code>.po</code> 文件。其中，<code>xx</code> 为 ISO 639 中定义的语言名，例如，en、zh-CN 等</p>
<blockquote>
<p>可以直接将 <code>po/messages.pot</code> 修改为 <code>po/xx.po</code>，但是必须手动将标题（第一个带有 <code>msgid ""</code> 条目）更新为正确的语言</p>
</blockquote>
</li>
<li>
<p>手动翻译 <code>po/xx.po</code> 文件中各条 <code>msgstr</code> 对应的内容即可。其中，<code>xx</code> 为 ISO 639 中定义的语言名，例如，en、zh-CN 等</p>
<blockquote>
<p>不要编辑 <code>po/xx.po</code> 文件中的 <code>msgid</code> 条目</p>
</blockquote>
</li>
</ol>
<h2 id="更新翻译"><a class="header" href="#更新翻译">更新翻译</a></h2>
<p>随着文档内容的逐步增加或者减少，对应的翻译内容也需要进行对应变动。此时，我们需要使用 mdbook-xgettext 重新提取文档中所有需要翻译的内容生成 <code>.pot</code> 文件，然后根据 <code>.pot</code> 文件更新各种语言对应的 <code>.po</code> 文件，而不是简单的直接编辑原始文档和<code>.po</code> 文件。</p>
<ol>
<li>
<p>执行 <code>MDBOOK_OUTPUT='{"xgettext": {"pot-file": "messages.pot"}}' mdbook build -d po</code> 自动提取原始文档中所有需要翻译的内容并生成 <code>messages.pot</code> 文件。命令执行之后就会生成默认的 <code>po/messages.pot</code> 文件</p>
<blockquote>
<p>如果在 <code>book.toml</code> 文件中添加了 <code>output.xgettext.pot-file = messages.pot</code> 配置项，则每次执行 <code>mdbook build</code> 时都会自动输出 <code>book/xgettext/messages.pot</code></p>
</blockquote>
<blockquote>
<p>不要编辑 <code>po/messages.pot</code> 文件，也不要将它签入你的存储库，因为它是完全从源 Markdown 文件生成。</p>
</blockquote>
</li>
<li>
<p>执行 <code>msgmerge --update po/xx.po po/messages.pot</code> 更新对应语言的 <code>.po</code> 文件。其中，<code>xx</code> 为 ISO 639 中定义的语言名，例如，en、zh-CN 等</p>
<blockquote>
<p>未更改的内容将保持原样，删除的讯息会被标记为旧内容，更新的讯息则标注为“fuzzy”。“fuzzy” 条目会沿用之前的翻译，我们需要检查并根据需要更新它，再移除 “fuzzy” 标记。</p>
</blockquote>
</li>
<li>
<p>手动翻译 <code>po/xx.po</code> 文件中有变动的各条 <code>msgstr</code> 对应的内容即可。其中，<code>xx</code> 为 ISO 639 中定义的语言名，例如，en、zh-CN 等</p>
<blockquote>
<p>不要编辑 <code>po/xx.po</code> 文件中的 <code>msgid</code> 条目</p>
</blockquote>
</li>
</ol>
<h1 id="应用翻译"><a class="header" href="#应用翻译">应用翻译</a></h1>
<p>应用我们翻译好的内容是通过 mdbook-gettext 预处理器完成的。</p>
<h2 id="配置"><a class="header" href="#配置">配置</a></h2>
<p>首先，需要将如下配置项添加到我们的 <code>book.toml</code> 文件中，以便在项目中启用它。这将使能在执行完诸如 <code>{{ #include }}</code> 等操作后对源码运行 mdbook-gettext，从而使得翻译包含的源代码成为可能。</p>
<pre><code class="language-toml">[preprocessor.gettext]
after = ["links"]
</code></pre>
<p>如果要在每次更改 <code>po/xx.po</code> 文件时自动重新加载我们的文档，则需要将如下配置项添加到项目的 <code>book.toml</code> 文件中：</p>
<pre><code class="language-toml">[build]
extra-watch-dirs = ["po"]
</code></pre>
<h2 id="构建-2"><a class="header" href="#构建-2">构建</a></h2>
<p>增加了以上配置项之后，每当我们执行 <code>mdbook build</code> 构建时，将自动根据 <code>book.toml</code> 文件中的 <code>book.language</code> 指定的语言选择并应用对应的 <code>po/xx.po</code> 并在 <code>book</code> 目录下生成对应语言的文档。</p>
<blockquote>
<p>如果没有设置语言或者找不到与该语言对应的 <code>.po</code> 文件，那么将自动使用未翻译的内容</p>
</blockquote>
<p>如果要单独构建指定语言的文档，则可以使用 <code>MDBOOK_BOOK__LANGUAGE=xx mdbook build -d book/xx</code> 命令在 <code>book/xx</code> 目录中生成 xx 语言的文档 。其中，<code>xx</code> 为 ISO 639 中定义的语言名，例如，en、zh-CN 等</p>
<blockquote>
<p>每种语言都对应一个独立的完整文档</p>
</blockquote>
<h2 id="在线预览"><a class="header" href="#在线预览">在线预览</a></h2>
<p>由于构建是根据 <code>book.toml</code> 文件中的 <code>book.language</code> 指定的语言生成的对应语言的文档，因此，使用 <code>mdbook serve</code> 名在本地在线查看的也是对应语言的文档。</p>
<p>如果要单独查看指定语言的文档，则可以使用 <code>MDBOOK_BOOK__LANGUAGE=xx mdbook serve -d book/xx</code> 命令来在线查看。其中，<code>xx</code> 为 ISO 639 中定义的语言名，例如，en、zh-CN 等</p>
<h1 id="动态切换"><a class="header" href="#动态切换">动态切换</a></h1>
<p>多语言的支持需要动态切换，而不是分别独立部署。但是，由于 mdbook 本身不支持国际化，其默认主题中也没有用于切换不同语言的菜单，因此，我们需要修改默认的主题模板文件才能实现动态切换不同的语言。</p>
<h2 id="indexhbs"><a class="header" href="#indexhbs">index.hbs</a></h2>
<p>index.hbs 是 mdbook 的生成的所有页面的基础 HTML 模板，我们可以创建 <code>theme/index.hbs</code> 文件然后修改其中的内容，在构建时，mdbook 将自动使用当前目录下的 <code>theme/index.hbs</code> 文件，从而实现自定义主题！</p>
<p>对于要支持国际化的需求，我们首先需要在原在 index.hbs 的基础上，在顶部菜单栏的右侧增加一个切换不同语言的图标以及各种语言的菜单，并实现用户单击语言图标显示语言菜单以及点击语言菜单项时切换对应的语言的文档的功能。其次，当切换对应语言之后，还需要同步更新 URL 的路径并刷新显示。具体修改参见 <code>theme/index.hbs</code> 文件！</p>
<h2 id="增加样式"><a class="header" href="#增加样式">增加样式</a></h2>
<p>为了美化样式，我们还需要增加了一个 CSS 样式文件 <code>theme/language-picker.css</code>，用于控制新增的语言选择菜单的样式。而且，要使该文件生效，需要在 <code>book.toml</code> 文件中的 <code>output.html.additional-css</code> 中显式指明该文件。</p>
<h1 id="部署-github-pages"><a class="header" href="#部署-github-pages">部署 Github Pages</a></h1>
<p>mdbook 生成的文档本身就支持部署在 Github Pages，但是，在我们增加了国际化之后需要增加一些额外的执行步骤。</p>
<p>在没有国际化时，我们只需要通过 <code>mdbook build</code> 构建出文档，而支持国际化之后，则需要额外构建出每个语言对应的文档，并将构建出的不同语言的文档放到原构建目录中以 ISO 639 中定义的语言名为文件夹名字的子目录中即可（这是由于我们修改的 <code>index.hbs</code> 中强制写死了文件名）。具体修改见 <code>.github/workflows/build_deploy.yml</code></p>
<h1 id="局限性"><a class="header" href="#局限性">局限性</a></h1>
<ol>
<li>
<p>由于 mdbook 本身不支持国际化，因此需要对 mdbook 做比价多的改动</p>
</li>
<li>
<p>mdbook 的搜索不支持中文</p>
</li>
<li>
<p>目前无法再本地同时预览多个语言的版本（我们添加的动态切换无效），这是由于 mdbook 会清理掉其他语言的文档。暂时的解决方法是，在启动 <code>mdbook serve</code> 之后，再把构建的其他语言的文档放到 <code>book</code> 目录下<style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () =&gt; window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () =&gt; { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY &lt;200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() =&gt; { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () =&gt; { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() =&gt; { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) =&gt; (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) =&gt; { btn.addEventListener("click", (event) =&gt; { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () => window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () => { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY <200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() => { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () => { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() => { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) => (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) => { btn.addEventListener("click", (event) => { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer><div style="break-before: page; page-break-before: always;"></div><style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () => window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () => { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY <200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() => { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () => { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() => { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) => (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) => { btn.addEventListener("click", (event) => { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer><div style="break-before: page; page-break-before: always;"></div><h1 id="axvisor-design-discussions"><a class="header" href="#axvisor-design-discussions">AxVisor Design <a href="https://github.com/orgs/arceos-hypervisor/discussions">Discussions</a></a></h1>
<style>.scroll-to-top { font-size: 2.5rem; width: 3.2rem; height: 3.2rem; display: none; align-items: center; justify-content: center; position: fixed; padding: 0.75rem; bottom: 4rem; right: calc(1.25rem + 90px + var(--page-padding)); z-index: 999; cursor: pointer; border: none; color: var(--bg); background: var(--fg); border-radius: 50%; } .scroll-to-top.hidden { display: none; } .scroll-to-top i { transform: translateY(-2px); } @media (min-width: 1080px) { .scroll-to-top { display: flex; } }</style><button type="button" aria-label="scroll-to-top" class="scroll-to-top hidden" onclick="scrollToTop()"> <i class="fa fa-angle-up"></i></button><script>const scrollToTop = () => window.scroll({ top: 0, behavior: "smooth" }); window.addEventListener("scroll", () => { const button = document.querySelector(".scroll-to-top"); button.classList.toggle("hidden", window.scrollY <200); });</script><style>.announcement-banner { --site-announcement-bar-stripe-color1: #e5e7eb; --site-announcement-bar-stripe-color2: #d1d5db; z-index: 150; position: relative; flex-direction: column; justify-content: center; align-items: center; margin: 0; padding: 1rem 3.5rem; background: repeating-linear-gradient( 45deg, var(--site-announcement-bar-stripe-color1), var(--site-announcement-bar-stripe-color1) 20px, var(--site-announcement-bar-stripe-color2) 10px, var(--site-announcement-bar-stripe-color2) 40px ); } html:is(.navy, .coal, .ayu) .announcement-banner { --site-announcement-bar-stripe-color1: #1f2937; --site-announcement-bar-stripe-color2: #111827; } .announcement-banner p { color: var(--fg); width: 100%; margin: 0; padding: 0; overflow: hidden; text-align: center; white-space: nowrap; text-overflow: ellipsis; text-wrap: balance; } .announcement-banner button[data-close] { top: 50%; right: 1rem; position: absolute; transform: translateY(-50%); width: 3rem; height: 3rem; cursor: pointer !important; border: none; font-weight: 900; border-radius: 50%; background-color: transparent; }</style><div style="display: none" data-id="0.2.11" class="announcement-banner"> <p><em>正在逐步完善中。。。</em></p> <button type="button" data-close>X</button></div><script>(() => { const banner = document.querySelector(".announcement-banner"); const id = banner.getAttribute("data-id"); const message = banner.querySelector("p").textContent; const localData = JSON.parse(localStorage.getItem("mdbook-announcement-banner")); if (!localData || localData.id !== id || localData.hide !== true) { banner.style.display = "flex"; const page = document.querySelector(".page"); page.parentNode.insertBefore(banner, page); banner.querySelector("button").addEventListener("click", () => { banner.remove(); localStorage.setItem("mdbook-announcement-banner", JSON.stringify({ id, hide: true, message })); }); } })();</script><style>.giscus { margin-top: 6rem; }</style><script src="https://giscus.app/client.js" data-repo="arceos-hypervisor/doc" data-repo-id="R_kgDOLMHfvQ" data-category="Comments" data-category-id="DIC_kwDOLMHfvc4CoqAB" data-mapping="title" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-lang="zh-CN" data-loading="eager" crossorigin="anonymous" data-theme="light" async></script><script>(() => { const giscusScript = document.querySelector("script[data-repo][data-repo-id]"); if (giscusScript?.getAttribute("data-theme") !== "book") return; const mapTheme = (theme) => (["light", "rust"].includes(theme) ? "light" : "dark"); const bookTheme = localStorage.getItem("mdbook-theme") || html.getAttribute("class"); giscusScript.setAttribute("data-theme", mapTheme(bookTheme)); document.querySelectorAll("button[role='menuitem'].theme").forEach((btn) => { btn.addEventListener("click", (event) => { const theme = mapTheme(event.target.id); const iframe = document.querySelector("iframe.giscus-frame"); if (iframe) iframe.contentWindow.postMessage({ giscus: { setConfig: { theme } } }, "*"); }); }); })();</script><style>footer { text-align: center; text-wrap: balance; margin-top: 5rem; display: flex; flex-direction: column; justify-content: center; align-items: center; } footer p { margin: 0; }</style><footer><p>Copyright © 2025 • Created by ArceOS Team</p></footer>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/pagetoc.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
